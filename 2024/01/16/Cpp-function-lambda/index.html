<!DOCTYPE html><html lang="zh" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++中function关键字及lambda表达式 | Hexo</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>C++中function关键字及lambda表达式</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-01-16T01:23:44.000Z" id="date"> 2024-01-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-01-16T01:28:03.166Z" id="updated"> 2024-01-16</time></div></span></div></div><hr><div id="post-content"><h2 id="function关键字"><a href="#function关键字" class="headerlink" title="function关键字"></a>function关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>举例说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; dp = [&amp;](<span class="hljs-keyword">int</span> i)-&gt;<span class="hljs-keyword">int</span> &#123;...&#125;;<span class="hljs-comment">//注意分号;结尾</span><br></code></pre></td></tr></table></figure>

<p>上面是用function关键字定义的lambda表达式，其中<code>function&lt;int(int)&gt;中int(int)</code>部分的含义为：</p>
<p>前一个<code>int</code>，即紧跟着尖括号“<code>&lt;</code>”的<code>int</code>表示返回值类型；小括号中的<code>(int)</code>表示参数类型。</p>
<p>再举一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = add; <span class="hljs-comment">// 定义一个函数对象，指向函数add</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>int(int, int)</code>表示函数的参数列表和返回值类型，其中<code>int</code>表示返回值类型，<code>(int, int)</code>表示参数列表，表示该函数接受两个<code>int</code>类型参数。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>以下来自ChatGPT</strong></p>
<p>在C++中，<code>function</code>是一个函数对象，它可以像普通函数一样调用。<code>function</code>通常用于实现回调函数、函数指针、函数对象等功能。</p>
<p><code>function</code>的用法有以下几种：</p>
<ul>
<li><strong>1、定义函数对象</strong></li>
</ul>
<p>可以使用<code>function</code>关键字定义一个函数对象，该函数对象可以像普通函数一样调用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = add;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<code>function</code>定义了一个名为<code>add_func</code>的函数对象，该对象接受两个整数参数并返回它们的和。我们将其初始化为指向函数<code>add</code>的指针，并使用<code>add_func</code>调用该函数。</p>
<ul>
<li><strong>2、定义Lambda表达式</strong></li>
</ul>
<p>可以使用<code>function</code>关键字定义一个Lambda表达式，该表达式可以像普通函数一样调用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用<code>function</code>定义了一个名为<code>add_func</code>的函数对象，该对象接受两个整数参数并返回它们的和。我们将其初始化为一个Lambda表达式，并使用<code>add_func</code>调用该表达式。</p>
<ul>
<li><strong>3、实现回调函数</strong></li>
</ul>
<p>可以使用<code>function</code>定义一个回调函数，该函数可以作为参数传递给其他函数，并在需要时被调用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; callback)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> result = a + b;<br>  callback(result);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  doSomething(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [](<span class="hljs-keyword">int</span> result) &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个函数<code>doSomething</code>，该函数接受两个整数参数和一个回调函数作为参数。在函数内部，我们计算两个整数的和，并将结果传递给回调函数。我们在<code>main</code>函数中调用<code>doSomething</code>函数，并传递一个Lambda表达式作为回调函数，该表达式输出计算结果。</p>
<p>需要注意的是，<code>function</code>可以接受任意类型的函数或Lambda表达式作为参数，并可以返回任意类型的值。这使得<code>function</code>非常灵活和通用。</p>
<h2 id="lambda函数（C-11新特性）"><a href="#lambda函数（C-11新特性）" class="headerlink" title="lambda函数（C++11新特性）"></a>lambda函数（C++11新特性）</h2><p>lambda 表达式可以说是 c++11 引用的最重要的特性之一， 它定义了一个匿名函数， 可以捕获一定范围的变量在函数内部使用，<br> 一般有如下语法形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = [capture] (params) opt -&gt; ret &#123; func_body &#125;;<br></code></pre></td></tr></table></figure>

<p>其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt： 不需要可以省略，ret 是返回值类型，func_body 是函数体。<br>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> a) -&gt; <span class="hljs-keyword">int</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-keyword">auto</span> func2 = [](<span class="hljs-keyword">int</span> a) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>; &#125;;<br><span class="hljs-built_in">cout</span> &lt;&lt; func1(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; func2(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>

<h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><table>
<thead>
<tr>
<th>[]</th>
<th>不捕捉任何变量</th>
</tr>
</thead>
<tbody><tr>
<td>[&amp;]</td>
<td>捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</td>
</tr>
<tr>
<td>[=]</td>
<td>捕获外部作用域所有变量，在函数内内有个副本使用,拷贝的副本在匿名函数体内部是只读的</td>
</tr>
<tr>
<td>[=,&amp;foo]</td>
<td>按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</td>
</tr>
<tr>
<td>[bar]</td>
<td>按值捕获 bar 变量，同时不捕获其他变量</td>
</tr>
<tr>
<td>[&amp;bar]</td>
<td>按引用捕获 bar 变量，同时不捕获其他变量</td>
</tr>
<tr>
<td>[this]</td>
<td>捕获当前类中的 this 指针,让 lambda 表达式拥有和当前类成员函数同样的访问权限,如果已经使用了 &amp; 或者 =, 默认添加此选项</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//auto x1 = [] &#123;return m_number; &#125;;                      // error</span><br>        <span class="hljs-keyword">auto</span> x2 = [=] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x3 = [&amp;] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x4 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number; &#125;;                  <span class="hljs-comment">// ok</span><br>        <span class="hljs-comment">//auto x5 = [this] &#123;return m_number + x + y; &#125;;          // error</span><br>        <span class="hljs-keyword">auto</span> x6 = [<span class="hljs-keyword">this</span>, x, y] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;    <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x7 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number++; &#125;;                <span class="hljs-comment">// ok</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> m_number = <span class="hljs-number">100</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>x1</th>
<th>错误，没有捕获外部变量，不能使用类成员 m_number</th>
</tr>
</thead>
<tbody><tr>
<td>x2</td>
<td>正确，以值拷贝的方式捕获所有外部变量</td>
</tr>
<tr>
<td>x3</td>
<td>正确，以引用的方式捕获所有外部变量</td>
</tr>
<tr>
<td>x4</td>
<td>正确，捕获 this 指针，可访问对象内部成员</td>
</tr>
<tr>
<td>x5</td>
<td>错误，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</td>
</tr>
<tr>
<td>x6</td>
<td>正确，捕获 this 指针，x，y</td>
</tr>
<tr>
<td>x7</td>
<td>正确，捕获 this 指针，并且可以修改对象内部变量的值</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>   <span class="hljs-comment">// auto f1 = [] &#123;return a; &#125;;                        // error</span><br>    <span class="hljs-keyword">auto</span> f2 = [&amp;] &#123;<span class="hljs-keyword">return</span> a++; &#125;;                     <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">auto</span> f3 = [=] &#123;<span class="hljs-keyword">return</span> a; &#125;;                       <span class="hljs-comment">// ok</span><br>  <span class="hljs-comment">//  auto f4 = [=] &#123;return a++; &#125;;                     // error</span><br> <span class="hljs-comment">//   auto f5 = [a] &#123;return a + b; &#125;;                   // error</span><br>    <span class="hljs-keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>f1</th>
<th>错误，没有捕获外部变量，因此无法访问变量 a</th>
</tr>
</thead>
<tbody><tr>
<td>f2</td>
<td>正确，使用引用的方式捕获外部变量，可读写</td>
</tr>
<tr>
<td>f3</td>
<td>正确，使用值拷贝的方式捕获外部变量，可读</td>
</tr>
<tr>
<td>f4</td>
<td>错误，使用值拷贝的方式捕获外部变量，可读不能写</td>
</tr>
<tr>
<td>f5</td>
<td>错误，使用拷贝的方式捕获了外部变量 a，没有捕获外部变量 b，因此无法访问变量 b</td>
</tr>
<tr>
<td>f6</td>
<td>正确，使用拷贝的方式捕获了外部变量 a，只读，使用引用的方式捕获外部变量 b，可读写</td>
</tr>
<tr>
<td>f7</td>
<td>正确，使用值拷贝的方式捕获所有外部变量以及 b 的引用，b 可读写，其他只读</td>
</tr>
</tbody></table>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 完整的lambda表达式定义</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> a) -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+<span class="hljs-number">10</span>;  <br>&#125;;<br><br><span class="hljs-comment">// 忽略返回值的lambda表达式定义</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">return</span> a+<span class="hljs-number">10</span>;  <br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，<code>但需要注意的是 labmda表达式不能通过列表初始化自动推导出返回值类型</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ok，可以自动推导出返回值类型</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// error，不能推导出返回值类型</span><br><span class="hljs-keyword">auto</span> f1 = []()<br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;	<span class="hljs-comment">// 基于列表初始化推导返回值，错误</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数本质"><a href="#函数本质" class="headerlink" title="函数本质"></a>函数本质</h3><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=] &#123;<span class="hljs-keyword">return</span> a++; &#125;;              <span class="hljs-comment">// error, 按值捕获外部变量, a是只读的</span><br><span class="hljs-keyword">auto</span> f2 = [=]()<span class="hljs-keyword">mutable</span> &#123;<span class="hljs-keyword">return</span> a++; &#125;;     <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<p>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。<br>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。<br>mutable 选项的作用就在于取消 operator () 的 const 属性。</p>
<p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 包装可调用函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; f1 = [](<span class="hljs-keyword">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;;<br>    <span class="hljs-comment">// 绑定可调用函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; f2 = bind([](<span class="hljs-keyword">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;, placeholders::_1);<br><br>    <span class="hljs-comment">// 函数调用</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; f1(<span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; f2(<span class="hljs-number">200</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func_ptr = <span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>);<br><span class="hljs-comment">// 没有捕获任何外部变量的匿名函数</span><br>func_ptr f = [](<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">return</span> a;  <br>&#125;;<br><span class="hljs-comment">// 函数调用</span><br>f(<span class="hljs-number">1314</span>);<br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/01/18/cpp-static/">← Next C++类的静态成员</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/01/08/hexo-g-error/">hexo-g-error Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Dr.Unglaus</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#function%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">function关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基本用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0%EF%BC%88C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">lambda函数（C++11新特性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">捕获列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.3.</span> <span class="toc-text">函数本质</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>
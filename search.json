[{"title":"大家一起学英语","url":"/2023/03/07/English-Word/","content":"引言在学习OCC、PCL等C++库，或是其他一些技术时，通常需要阅读官方提供的技术手册，而这些手册大多是英文编写，虽然可以直接使用翻译软件进行翻译，但毕竟翻译软件有时翻译的也是词不达意，加之它可能把人家定义的类名之类的东西也翻译成中文，还不如直接看英文。综上，长远来看，提升自己的英文水平总没错，本文用来收集阅读英文手册或教程时遇到的各种不认识的单词，也不指望能将这些单词全部融汇贯通，但希望下次见到时最起码能认得它是个什么意思。\nOCC\ngeometry：几何学\nparametric：参数\ndimension：纬度\ninfinity：无限大\nsecond order：二阶\ncriteria：标准\nscaled ellipse：缩放的椭圆\ncylinder：圆筒\nconjugate：共轭的\nprojection：投影\nintersection：交叉点\ntopology：拓扑学\n\nPCL\ncomplicate：复杂化\ntrim：修剪\noutliers：离群值、异常值\ndeviation：偏差\n\nCloudCompare Wiki\nmesh：网格\n\n不定期更新中。。。\n","categories":["英文学习"],"tags":["English Word"]},{"title":"OCC7.6+VS2022配置","url":"/2023/03/08/OCC7.6-VS2022-config/","content":"OCC安装与编译安装OCC安装很简单，就是去官网https://dev.opencascade.org/ 下载安装包安装即可。\n这里用的是OCC7.6版本。\n\n\n注意：安装的时候路径不要有空格和汉字。\nVS2022编译v142的OCC安装之后得到的是OCC的编译前的资源文件，而想要使用OCC提供的方法还需要将这些文件进行编译。即编译后得到的文件才是我们使用OCC所必须的。\n这里我安装的VS版本为2022，其默认的生成工具是v143，而OCC7.6最新支持的生成工具是v142，所以需要稍微操作一下，使VS2022能编译OCC。\n需要注意的是，因为要用到v142生成工具，肯定要保证VS安装了v142的生成工具，没安的话打开Visual Studio Installer安一下即可。\n\n\n下面是OCC部分编译前的一些操作：打开安装目录下 \\opencascade-7.6.0 目录下的custom.bat，将其中要求的vcvarsall.bat文件所在路径填写完整，该路径跟VS安装的位置有关，下图我的路径配置。\n\n\n如果实在不知道在哪，可以安装一个软件”everything“，用它来查找vcvarsall.bat的位置即可\n\n\n之后，还是在 \\opencascade-7.6.0 目录下，打开env.bat，在图示位置添加：set “VCVER=vc143”\n\n\n再打开 \\opencascade-7.6.0\\adm\\msvc目录下，复制一份vc142并重命名为vc143，这就是前面提到的，OCC7.6还没有对应的2022版本（vc143）\n\n\n至此准备工作结束，可以用VS2022编译OCC7.6了\n回到目录 \\opencascade-7.6.0，双击msvc.bat，它会根据前面的配置打开对应版本的OCCT.sln，打开后会需要确认是否升级平台工具集，记得选择”无升级“。\n\n\n之后找到“解决方案资源管理器”，右键“解决方案”，选择“生成解决方案”即可\n\n\n等待VS编译完成\n（编译完成图–等我在新电脑上配的时候截一张，懒得再重新生成一遍了）\n编译完成后生成的文件在 \\opencascade-7.6.0\\win64\\vc14 目录下\n\n\n其中的bind文件夹、libd文件夹中的文件是我们使用OCC所必需的的文件。一般是bin文件夹和lib文件夹，不过在OCC这里是bind和libd，应该是分别表示bin和lib的debug版本。因为我一直用的debug版本调试，找的教程也都是说配bind和libd的，不太清楚这个bin和lib是不是在release版本下用的，等之后如果用到release调试的时候试一下看看，等试过之后再来补充。\nlibd文件夹，存放程序运行时所需要的lib文件，lib文件是指程序库（library）文件，也称为静态链接库（static library），它包含了一组可在程序中共享的函数和资源的代码。\nbind文件夹，存放运行lib时所必需的的dll文件，DLL（Dynamic Link Library）是一种可执行文件格式，它包含一组可在多个程序中共享的函数和资源。它通常被用于在 Windows 操作系统中实现共享库和插件的功能。一个 DLL 文件可以包含多个函数和资源，其他程序可以通过动态链接库（Dynamic Link Library）的方式调用 DLL 文件中的函数。\nVS中配置OCC环境前面也提到，我们所需的bind文件夹和libd文件夹生成好了之后，就可以配置在VS中使用OCC所需的一些属性，像OCC、PCL、VTK这种C++的库，其项目属性配置基本都是一致的，基本就是三步走。\n第一步，将dll文件所在路径，在OCC这里即是上述提到的bind文件夹路径，添加到系统环境变量Path中\n\n\n之后在我们所建的项目中，在解决方案栏中，右键点击项目，选择属性一栏\n\n\n在属性页找到 调试—&gt;环境，输入 PATH=%PATH% ，使调试时能找到环境变量中bind所在路径，进一步能找到dll文件\n\n\n第二步，在属性页中找到 链接器—&gt;常规—&gt;附加库目录，将libd所在路径添加进去，方便编译器编译时能找到lib文件\n\n\n再找到 链接器—&gt;输入—&gt;附加依赖项，将libd文件夹下所有的lib文件添加进去\n\n\n至于如何快速取得文件夹下所有lib文件列表，找到目标文件夹libd，在该文件夹下“shift+右键”，选择 Powershell打开\n\n\n在该命令窗口输入 ls *.lib -n，即可得到该文件夹下所有lib结尾的文件列表，其中-n是指定列出来的信息只包含文件名和后缀，可以自己试试不带-n的结果\n\n\n第三步，在属性页找到 C/C++—&gt;常规—&gt;附加库包含目录，将OCC的头文件路径添加进去，该路径为安装目录下 \\opencascade-7.6.0\\inc ，其中存放的是在使用OCC时所需的所有头文件\n\n\n上面三步无关顺序，能配完就行。\n至此，就可以在C++程序中使用OCC提供的各种功能啦，开始愉快编程啦~\nVS属性表的使用新建属性表上面配置的VS属性页只针对当前项目有效，如果要新建项目并使用OCC，需要将上面的三个步骤再配置一遍，很不方便。而使用VS属性表就可以实现只用配置一次，下次直接拿来用即可的效果\n在VS窗口上边菜单栏找到 视图—&gt;其他窗口—&gt;属性管理器\n\n\n选择之后，属性管理器就会出现在解决方案管理器旁边的位置\n\n\n找到自己需要的版本，比如我一般使用Debug|x64版本，我就在对应项旁边右键，选择 添加新项目属性表\n\n\n因为是给OCC配置的属性表，就叫OCC.props吧，至于这个位置，它默认是建在当前项目所在的文件夹中，可以自定义一个文件夹位置，就光用来存这种属性表，当时候项目中需要哪个属性表，就直接去那个文件夹中好就行。\n\n\n在建好的属性表里，把前面第二步、第三步里，关于“C/C++”和“链接器”选项中的部分复现一下即可，简单概括就是“C/C++”的附加包含目录里添加头文件目录，”链接器“的附加库目录里添加lib库路径、附加依赖项里把lib库中的所有lib添加进去。\n\n\n可以看到这个属性表里没有第一步中“调试”选项，所以在 调试—&gt;环境，输入 PATH=%PATH% 这一步还是需要在具体的新建项目中配置一下，步骤参考前面第一步。\n使用已有属性表上面属性表建好之后，下次新的项目要是用OCC的时候，直接把这个属性表引入即可\n在属性管理器，要是用的对应版本处右键点击，选择 添加现有属性页\n\n\n找到之前建好的属性表，添加即可\n\n\n需要注意的是，通过这种添加现有项方式加入的属性表并不是把之前建的表复制了一个放在新项目里，新项目中是找不到这个属性表文件的，它实际还是之前建的那个属性表，只是编译器把它链接了过来，使我们可以使用该表的配置。这也意味着你如果在对这个属性表进行改动，会影响到所有使用该属性表的项目，一定要注意。\n\n\n当然，其实也可以将之前建的属性表复制一个到新建项目的文件夹里，然后在添加现有项时添加当前这一个，这样就可以随便改了，也不会对别的项目有什么影响。\n以上。\n","categories":["教程"],"tags":["OCC"]},{"title":"PCL1.12.1+VS2022+Qt6.4 配置(未完待续)","url":"/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/","content":"本教程分为两部分，第一部分为PCL+VS的配置，第二部分为PCL+VS+QT的配置。\n如果只是要在VS用用PCL，学习一下PCL点云库，只看第一部分PCL+VS的配置即可。\n而如果还需要配合QT做界面，相关的配置会在第二部分PCL+VS+QT的配置中介绍。\nPCL+VS 配置PCL安装前言PCL（Point Cloud Library）官方网站 https://pointclouds.org/\n官方github网站 https://github.com/PointCloudLibrary/pcl\nPCL官方的github提供了各种版本的PCL源码，同时还提供了已经编译好的PCL供使用。\n解释一下，PCL正常来配置的话，是需要自己安装PCL依赖的第三方库，一般有Boost、Eigen、FLANN、OpenNI2、Qhull、VTK，我们需要将这些第三方库从各自官网下载下来，分别用Cmake编译好，然后再编译PCL的源码，因为PCL编译时要依赖上述第三库编译出的文件，包括库文件（library）等二进制文件。这样的优势在于编译PCL的时候可以自选PCL的一些组件，比如可以指定PCL的GPU加速模块（默认是不带的），还可以指定要与Qt6配合使用，它应该就会在编译时往与Qt6适配这方面有进一步的优化。但缺点就是麻烦，要把上面每一个第三方库都安装编译一遍可不是一般的麻烦，而且各个第三方库版本之间的兼容性、适配度也需要自己摸索。\n所以官方也提供了已经完全编译好的PCL安装包供我们使用，该安装包包含上述的所有第三方库编译好的文件，以及依赖它们所编译好的PCL文件。当然，官方提供的这种安装包得到的PCL只提供了最基本的功能，不含GPU模块等扩展。而且其中所带的第三库也都是最基本的配置，就比如其中自带的VTK，就没有针对Qt6做额外的配置，缺少与Qt6配合所需的文件。\n因此，个人认为，最佳的PCL配置安装路线是，1、先使用官方提供的AllInOn安装包，就是之前提过的官方提供的自带编译好的第三方库及编译好的PCL的安装包。补充一下，这个安装包自带的第三方库安好后，从各自的文件夹名字基本能得知每个第三库的版本，即我们可以从中得知当前PCL版本要与第三方库的哪些版本配合兼容性好。2、根据自己的需求，自己安装编译对应版本的第三方库，并用它替换掉PCL自带的对应部分的第三方库。就比如，我要使用VTK配合Qt的组件，而PCL自带的VTK显然不带与Qt配合的部分。因此我去VTK官网自己下一个VTK源码，并自己编译，编译时配置与Qt配合，那我得到的编译后的文件就带有我所需的与Qt配合的部分。之后我用我自己编译好的VTK文件（包括bin、lib、include等），把PCL自带的VTK的这些文件都替换掉。当然，如果没有这类需求，只是想自己编译一下PCL，比如自己编译PCL增加一个GPU模块，那这第2步就没有必要。3、前面是编译PCL的准备步骤，准备好PCL编译所依赖的第三方库文件（编译好的），下面就是编译PCL，去官网下载对应版本的PCL源码，使用CMake编译即可，编译的时候绑定好这些第三方库的位置、选好要用的PCL模块。具体操作见本教程第二部分“PCL+VS+QT 配置” 。\n官方编译版安装下面开始官方编译版PCL的安装教程，因为如果只是配合VS来学习PCL库，安这个也就够用了，有进一步的自定义需求的可以接着看第二部分。\n在官方github网站（PCL项目）的右侧找到Releases部分\n\n\n\n\n他这里把最新的版本放在前面，可以看到是PCL1.13.0版本，如果想安装其他版本就点“+30 releases”去找自己想安的版本，因为我之前安装的是PCL1.12.1，所以我还是以该版本为例来写。\n\n\n点开相应版本下的“Assets”，就能看到具体提供的安装资源，其中的AllInOne安装包就是官方提供的编译好的第三方库及PCL文件。\n\n\n之后点击安装即可，这里提点安装时的个人小建议，一是选择添加环境变量到PATH，能为后面配环境变量省一点事儿\n\n\n然后是选择安装路径的时候，官方自动给的路径中“PCL 1.12.1”里面有个空格，为了方便后续编译PCL时的方便，建议把这个空格去掉，或是换成下划线之类的，总之路径里最后不要有空格，中文最好也别有（这个没试过，可能没事）\n\n\n然后在安装过程中如果之前没有安装过OpenNI2，会弹出窗口问是否安装OpenNI2，点击安装即可。\n（OpenNI2安装提示图，等去欢儿电脑截一张）\n 比较坑的是，这个OpenNI2一般不会老老实实按照我们PCL安装路径安装，而是安装在C盘。不过也不用在意，等PCL安装程序全部安装完成后，找到安装目录\\PCL_1.12.1\\3rdParty，该目录下就是PCL官方为我们打包好的，编译好的第三方库\n（PCL_1.12.1\\3rdParty目录图）\n打开其中的OpenNI2目录，如果里面是空的，只有一个OpenNI-Windows-x64-2.2.msi文件，那恭喜，这东西成功安到C盘去了。。。\n（OpenNI2空空图片）\n但不用担心，这个msi文件就是OpenNI2的安装文件，我们可以通过它，把安在C盘的OpenNI2卸载\n（OpenNI2卸载图）\n然后再通过这个msi把它安装回来，主要是因为通过这个msi文件来安装的时候，它会让你选安装路径，我们就把安到\\PCL_1.12.1\\3rdParty\\OpenNI2路径，这样就让PCL的第三库整整齐齐在一起了。\n（msi安装OpenNI2时，选路径的图）\n当然，不介意OpenNI2安在C盘，与其他第三方库天各一方的话，就不用把它卸了又装。\n现在打开系统环境变量来看一下，因为我们之前选择了添加PCL环境变量到PATH，所以这里已经自动帮我们配好了一部分。（外：PCL_ROOT,OpenNI2三项；Path内：PCL/bin，VTK/bin）\n(环境变量图)\n除了他帮我们配好的这一部分，我们还需要把其他第三方库跟dll有关的路径添加上\n%PCL_ROOT%\\3rdParty\\FLANN\\bin%PCL_ROOT%\\3rdParty\\Qhull\\bin%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n一开始我以为我没用到上面的模块，这些环境变量没必要加，结果不加它们在运行的时候报了缺少OpenNI2.dll的错误，所以我估计虽然没有直接使用这些第三方库，但PCL毕竟是依赖它们编译出来的，在运行时估计还是需要用到这些东西，所以还是把上面这些都加到环境变量里吧。\n对了，既然说到这了，提供一种程序运行时出现缺少xxx.dll文件时的解决思路\n\n\n这种一般就是程序调试的时候找不到相关的dll导致的（废话。。。），所以我们首先要找到这个dll的位置，还是通过之前的软件“everything”，查找到这个dll所在位置\n\n\n之后有两种办法 ，一是直接将这个dll文件复制到程序运行目录下，二是将这个dll文件所在的路径添加到环境变量Path中，然后在VS的调试属性中告诉它去哪里找这些dll文件。上面这么多路径，选一个加到环境变量里即可。\n\n\n在这个例子里，通过网上的参考，只要把下面两个路径加到环境变量里，应该就包含OpenNI2所需的所有dll文件了。\n%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n而在不知道哪个路径里包含程序运行所需的所有dll文件的情况下，就只能是缺一个，找个一路径加一下这样。。。当然，因为你加的路径里包含多个dll文件，在有多个dll路径可选的时候，是有可能你选的那个路径，就是包含你当前程序运行所需的所有dll文件的路径。提这个就是想说，选哪个路径加到环境变量里的时候，还是可以稍微思考一下的，哎嘿。\n题外话，不过让我纳闷的是，上面配置的所有PCL相关环境时，里面没有Boost相关的环境变量，甚至我程序中都显式地使用了Boost相关的代码，它也没报过缺少dll文件的错。而且其实在第三方库Boost的安装路径\\PCL_1.12.1\\3rdParty\\Boost里，可以看到是没有bin文件夹的，找了找也没有像OpenNI2那样把dll分散到别的文件夹里，Boost好像就是没有dll文件。看样Boost在使用时跟别人都不一样，不需要这个dll文件就能用。这一段是见识短的我的一点小感慨，等我见识长了，看看能不能有什么新的认识补充。\nVS配置PCL+VS+QT 配置VTK编译PCL源码","categories":["教程"],"tags":["PCL"]},{"title":"更改PyCharm缓存路径","url":"/2023/03/15/PyCharm-Cache/","content":"越来越小的C盘最近C盘的空间越来越小了，于是便又开始找找有没有什么能删的垃圾文件。\n推荐一个软件“SpaceSniffer”，它可以扫描分析每个盘里面各个文件所占的大小，我用他扫描了一下我的C盘结果看到用户目录下的PyCharm文件夹里有个文件“content.dat.storage.data”有4.4个G的大小。\n\n\n网上一查是PyCharm的缓存文件，补充一下，该文件存放在Caches文件夹里，Cache一般就是指缓存文件夹，用来存缓存文件的，当时没反应过来，不过就算直到Cache放缓存文件可能也还是查一查确认一下放心。\n这个缓存文件可以直接删除。但删除并不能从根源解决问题，因为下次使用PyCharm还是会生成缓存文件，早晚还是会一点一点挤占C盘的位置，所以最好的办法就是给PyCharm换一个缓存路径。\n更换PyCharm缓存路径找到PyCharm的安装目录下的bin文件夹，如E:\\PyCharm Community Edition 2022.3.2\\bin，找到其中的idea.properties文件\n\n\n打开该文件，修改其中的四处位置，推荐用“NotePad++”打开。当然，记事本，VS Code之类的都可以。\n\n\n上面红框就是我们要修改的部分，它注释掉的语句应该是它本来默认的存放路径，不过可能因为注释掉了，所以其实并没有存在这个路径中，但还是在C盘建了别的文件夹来放这些文件。我们将这些路径改为我们想让它存放的路径。我在PyCharm的安装目录下新建了一个”.PyCharmCE2022.3”文件夹，并将这个路径改到了该文件夹下。\n\n修改config路径\n\n# idea.config.path=$&#123;user.home&#125;/.PyCharmCE/configidea.config.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/config\n\n\n修改system路径\n\n# idea.system.path=$&#123;user.home&#125;/.PyCharmCE/systemidea.system.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/system\n\n\n修改plugins路径\n\n# idea.plugins.path=$&#123;idea.config.path&#125;/pluginsidea.plugins.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/plugins\n\n\n修改log路径\n\n# idea.log.path=$&#123;idea.system.path&#125;/logidea.log.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/log\n\n之后重启PyCharm，它会自动检测之前的配置所在位置，并提示导入之前的配置\n\n\n点击ok就行了，然后就可以把之前C盘里的都删掉了。\n不过因为前面提到的，它配置文件里那四个部分都默认是注释掉的，所以它实际存放的位置是在C盘别的位置，我的位置是在：\nC:\\Users\\REINHARDT\\AppData\\Local\\JetBrains\\PyCharmCE2022.3C:\\Users\\REINHARDT\\AppData\\Roaming\\JetBrains\\PyCharmCE2022.3\n\n不过删完那个4.4G的缓存文件之后我看这两占内存也不是很大我就没删，以防之后发现上面的配置方法有问题，我好回来找。不过一般也没问题，咬咬牙删了也没事。\n","categories":["C盘减负"],"tags":["PyCharm"]},{"title":"Qt项目的文件结构","url":"/2023/03/16/Qt-Project-Structure/","content":"之前新建Qt项目看它那个代码，总是感觉怪怪的，直到今天在问ChatGPT关于Qt6和OCC7.6的配合时，它给出了一个Qt+OCC的显示模型的例程，看了这个之后我感觉对Qt程序的创建执行才算理解了一点。\n#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QVBoxLayout&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsView&gt;#include &lt;OpenGl_GraphicDriver.hxx&gt;#include &lt;V3d_View.hxx&gt;#include &lt;AIS_InteractiveContext.hxx&gt;#include &lt;BRepPrimAPI_MakeSphere.hxx&gt;int main(int argc, char *argv[])&#123;    // 初始化 Qt 应用程序    QApplication app(argc, argv);    // 创建主窗口    QWidget window;    window.setWindowTitle(&quot;OCC and Qt Integration&quot;);    window.resize(640, 480);    // 创建图形场景和视图    QGraphicsScene scene;    QGraphicsView view(&amp;scene);    view.setViewport(new QOpenGLWidget());  // 使用 OpenGL 视口    // 创建 OCC 视图    Handle(OpenGl_GraphicDriver) aDriver = new OpenGl_GraphicDriver();    Handle(V3d_View) aView = new V3d_View(aDriver);    Handle(AIS_InteractiveContext) aContext = new AIS_InteractiveContext(aView);    aView-&gt;SetContext(aContext);    // 创建 OCC 对象并将其添加到场景中    BRepPrimAPI_MakeSphere aSphere(50);    TopoDS_Shape aShape = aSphere.Shape();    Handle(AIS_Shape) anAisShape = new AIS_Shape(aShape);    aContext-&gt;Display(anAisShape, Standard_True);    aContext-&gt;UpdateCurrentViewer();    // 将 OCC 视图绑定到 Qt 视图中    aView-&gt;SetWindow(view.winId());    aView-&gt;MustBeResized();    view.show();    // 将 Qt 视图添加到主窗口中    QVBoxLayout layout;    layout.addWidget(&amp;view);    window.setLayout(&amp;layout);    window.show();    // 运行 Qt 应用程序    return app.exec();&#125;\n\n重点不在如何显示OCC模型，而在于该程序是标准的从int main（）主函数来构建程序的写法。从中我们可以加深对Qt代码的真实执行过程的理解。\n将上面的代码与下面新建的Qt项目所给出的int main（）比较，可以看到只有寥寥几行代码，当初被下面这几行代码整蒙了，寻思这是干嘛呢，但其实对照上面的代码来分析就比较好读懂了。上面把定义窗口组件的代码直接写在主函数main中，而下面这种其实就是把窗口定义之类的代码写到了类里，这里这个类是OCC_QT，然后OCC_QT w;这句其实是调用了该类的默认构造函数，通过构造函数的执行，来实现了窗口的创建等功能。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n下面来看OCC_QT这个类，先看头文件OCC_QT.h，这里就是类的声明，其中构造函数OCC_QT(QWidget *parent = nullptr);\n#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include &quot;ui_OCC_QT.h&quot;class OCC_QT : public QMainWindow&#123;    Q_OBJECTpublic:    OCC_QT(QWidget *parent = nullptr);    ~OCC_QT();private:    Ui::OCC_QTClass ui;&#125;;\n\n我们可以看到它引入了一个头文件“ui_OCC_QT.h”，这里面就是窗口组件相关的代码\n具体来看“ui_OCC_QT.h”，这里面定义了各种窗口组件的代码，包括页面组件的声明、布局的位置等。\n/********************************************************************************** Form generated from reading UI file &#x27;OCC_QT.ui&#x27;**** Created by: Qt User Interface Compiler version 6.4.0**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_OCC_QT_H#define UI_OCC_QT_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QMainWindow&gt;#include &lt;QtWidgets/QMenuBar&gt;#include &lt;QtWidgets/QStatusBar&gt;#include &lt;QtWidgets/QToolBar&gt;#include &lt;QtWidgets/QWidget&gt;QT_BEGIN_NAMESPACEclass Ui_OCC_QTClass&#123;public:    QMenuBar *menuBar;    QToolBar *mainToolBar;    QWidget *centralWidget;    QStatusBar *statusBar;    void setupUi(QMainWindow *OCC_QTClass)    &#123;        if (OCC_QTClass-&gt;objectName().isEmpty())            OCC_QTClass-&gt;setObjectName(&quot;OCC_QTClass&quot;);        OCC_QTClass-&gt;resize(600, 400);        menuBar = new QMenuBar(OCC_QTClass);        menuBar-&gt;setObjectName(&quot;menuBar&quot;);        OCC_QTClass-&gt;setMenuBar(menuBar);        mainToolBar = new QToolBar(OCC_QTClass);        mainToolBar-&gt;setObjectName(&quot;mainToolBar&quot;);        OCC_QTClass-&gt;addToolBar(mainToolBar);        centralWidget = new QWidget(OCC_QTClass);        centralWidget-&gt;setObjectName(&quot;centralWidget&quot;);        OCC_QTClass-&gt;setCentralWidget(centralWidget);        statusBar = new QStatusBar(OCC_QTClass);        statusBar-&gt;setObjectName(&quot;statusBar&quot;);        OCC_QTClass-&gt;setStatusBar(statusBar);        retranslateUi(OCC_QTClass);        QMetaObject::connectSlotsByName(OCC_QTClass);    &#125; // setupUi    void retranslateUi(QMainWindow *OCC_QTClass)    &#123;        OCC_QTClass-&gt;setWindowTitle(QCoreApplication::translate(&quot;OCC_QTClass&quot;, &quot;OCC_QT&quot;, nullptr));    &#125; // retranslateUi&#125;;namespace Ui &#123;    class OCC_QTClass: public Ui_OCC_QTClass &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_OCC_QT_H\n\n最后再来看OCC_QT.cpp，这里面就是OCC_QT类的各种函数功能的具体实现。这里别看这个构造函数就一句话，当时我也懵了一下，寻思这怎么就能把窗口之类的东西都弄出来了？现在懂了，就像上面说的，窗口之类的代码实现实际上都在上面ui_OCC_QT.h里，所以cpp这里的构造函数只需要调用一下setupUi（）函数，把窗口布局的代码运行一下即可。\n#include &quot;OCC_QT.h&quot;OCC_QT::OCC_QT(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);&#125;OCC_QT::~OCC_QT()&#123;&#125;\n\n分析完这个OCC_QT类，再来看主函数的代码就很好理解了，调用OCC_QT的构造函数将窗口组件都定义好了，之后再使用w.show()函数显示在w这个类中声明与定义的窗口即可。其中这个show()函数我们注意到并没有定义在OCC_QT类中，它应该是继承自QMainWindow的方法。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n\n\n了解了Qt项目的这些结构之后，我们对Qt项目的搭建就有了基本的了解，就可以开始编写自己的Qt项目。（用词、说法待修改）\n可以就依赖它给出的这种结构来写，也可以按自己想法来写不按它上面的这种结构，步骤对了就行\n槽函数的声明、定义、与信号的连接等基本步骤见后续的Qt学习笔记，想记录一下两种方式，一种是配合Qt Designer的可视化编程，一种就是纯代码开发的方式。在第一种方式里，想着用上上面说的Qt项目自带的这种文件结果，把OCC_QT.h，OCC_QT.cpp，ui_OCC_QT.h三个文件都用上。在第二中纯代码的方式里，就不要这个ui_OCC_QT.h文件了，毕竟这个文件其实是为了配合Qt Designer可视化编程而存在的，把里面的组件声明、定义等代码都放到外面来。\n","categories":["Qt学习"],"tags":["Qt"]},{"title":"Qt6.4.2-PCL1.12.1-VTK9.2.6-error","url":"/2023/03/09/Qt6.4-PCL1.12.1-VTK9.2.6-error/","content":"问题描述一开始因为PCL自带一个VTK9.1环境，因为要VTK和Qt配合，去官网下了完整VTK9.2自己编译了一下，然后又在Qt项目里配了一下VTK的环境，估计是他先找到了PCL自带的VTK9.1环境，就没管我自己配的VTK9.2，导致报了个“未定义标识符VTK_UNICODE_STRING”的错\n考虑到两个VTK环境冲突的问题，就把PCL自带的那个VTK9.2的环境配置都删了一遍，结果又出现了下面的问题\n\n\n看到这个dll想到可能是因为环境变量里PCL自带的VTK9,1和自己编译的VTK9.2冲突了，忘记改了，因为程序寻找dll文件是从环境变量PATH中从头到尾在找，当找到一个对应的目录的时候它就认定在这个目录里寻找dll文件了，而不会再往下找了，应该就是因为我把PCL自带的VTK9.1的bin路径放在了自己编译的VTK9.2的bin路径之前导致的问题\n结果一看不对啊，自己编译的VTK9.2的bin路径是在上面的呀，惊了。。。\n然后我又试了试直接把PCL自带的VTK9.1的bin路径删掉，结果程序报错找不到vtk9.1d的dll了，说明程序哪里还用着pcl自带的vtk9.1 。。。\n话说pcl自带的vtk9.1有QVTKOpenGLNativeWidget吗，有的话我直接用PCL自带vtk9.1算了。。。\n去看了一下没有，然后想起来了，这个模块是要编译VTK的时候选一下配合Qt才会生成，乐，还是要用自己配的。。。\n可能是PCL一些东西配合自带的VTK才能实现，明天试试把自己编译的VTK覆盖PCL自带的VTK试一下。。。记得做好备份\n实在不行就得把PCL编译需要的东西都下一遍，然后用CMake从头编译一下来弄了。。。\n第二天继续试，把VTK覆盖试了试好像不行\n然后开始调试，看看是哪个语句的问题，发现是初始化语句的问题，因为初始化用的是qvtkwidget版本时的代码，所以可能有些问题，于是就去找了QVTKOpenGLNativeWidget版本显示点云数据的代码\n结果照着别人的代码敲还是有问题\n\n\n找了找资料发现出现这种问题一般是因为这个类没有定义，其实就是vtkGenericOpenGLRenderWindow这个类的头文件没有引入，这里不得不吐槽一下，既然头文件没引入，你上面的的没啥不报错啊。。。\n引入头文件：\n#include &lt;vtkGenericOpenGLRenderWindow.h&gt;\n\n之后该语句就不会报错了\n\n\n以为终于没问题的时候，在执行到语句\nviewer.reset(new pcl::visualization::PCLVisualizer(renderer,renderWindow,&quot;viewer&quot;, false));\n\n的时候还是报错了。\n\n\n估计还是因为弄了两个vtk导致的，可能pcl1.12和自己配的这个vtk9.2不太搭，网上查了查资料，也都是自己下一个vtk9.1自己编译一下，然后覆盖原来的pcl自带的vtkk，然后再编译PCL。\n这次就老实照这个来一遍https://blog.csdn.net/qq_40732350/article/details/125394920，他跟我想的一样，除了vtk自己编译，其他直接用pcl自带的编译好的就行，省事。\n等开完会试一下。。。\n解决经过一番尝试，我已经完全理解了。\n正确的做法就是用自己编译的vtk替代pcl自带的vtk，然后从官网下载pcl源码，然后重新编译pcl，让它和自己编译的vtk配合起来。这样既有了自己编译的vtk的Qt相关插件，又可以让pcl跟自己配的vtk适配，正常用pcl库。\n具体的步骤见“PCL编译（暂定）”\n分析复盘要使用Qt+PCL显示点云，需要用到VTK来控制Qt窗口组件来显示。而PCL自带的vtk是不含与Qt配合相关的文件的。于是，我就想着去vtk官网下一个vtk自己用cmake编译一下，选上qt6组件。也成功编译了，问题就在，我以为就是用一下这个组件，就给项目既配了PCL（自带vtk9.1）环境，又配了自己编译的vtk9.2环境，而这两个都有的情况下，编译器编译的时候会有各种冲突，除非你能精准挑出来pcl用的vtk9.1的哪部分，Qt用的vtk9.2的哪部分，然后只把这些用到的引入，其他无关的全部不要引到环境里，其实就算这样pcl和qt用的vtk的部分也可能重合，比如pcl要用9.1的vtkcommon.dll而qt要用9.2的vtkcommon.dll，所以还是不行，这样肯定冲突。\n然后你又不能直接把pcl中vtk9.1的部分直接删掉或者替换成vtk9.2的，因为这个pcl是官网提供的编译好的，它是按照vtk9.1来编译的，对这个vtk9.1肯定又依赖。\n所以，只有按上面解决办法来才是正解。而且顺便还可以配一下GPU模块。\n","categories":["问题记录"],"tags":["PCL","Qt","VTK"]},{"title":"Hello World","url":"/2021/03/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]
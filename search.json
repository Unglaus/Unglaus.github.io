[{"title":"cmake使用笔记","url":"/2023/05/05/CMake-Note/","content":"界面最近再新电脑上使用cmake-gui的时候发现选项都列在一起，没有像之前旧电脑上那样把每一项归好类\n\n\n旧电脑上是3.25版本的，这个新的是3.26，一开始以为是版本升级的负优化，结果重新下了个3.25还是一样的。\n最后发现原来在界面上有个“Grouped”选项，选一下就好了。。。\n","categories":["笔记"],"tags":["cmake"]},{"title":"C/C++笔记","url":"/2022/11/01/C-Note/","content":"C/C++相关变量声明如果变量声明在主函数外部，即作为全局变量的时候，其默认是为0；而如果变量声明在函数内部，变量的值是随机的，而不是默认为零，需要进行初始化\n#include&lt;iostream&gt;using namespace std;const int N=10;int a[N];int main()&#123;\tint b[N];    for(int i=0;i&lt;N;++i)&#123;        cout&lt;&lt;&quot;a[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;&lt;&lt;b[i]&lt;&lt;endl;    &#125;    return 0;&#125;\n\n一次运行的结果如下：\na[0]:0 b[0]:8a[1]:0 b[1]:0a[2]:0 b[2]:4199705a[3]:0 b[3]:0a[4]:0 b[4]:8a[5]:0 b[5]:0a[6]:0 b[6]:48a[7]:0 b[7]:0a[8]:0 b[8]:15603440a[9]:0 b[9]:0\n\n可以看到作全局变量的a[]，其中所有值都默认为0；而作局部变量的b[]，其中的值是随机赋予的，下一次运行时，其中的值又不一定是什么了，所以对于声明在函数内部的局部变量一定要注意初始化问题，防止由此引发的错误。\n注意：不是只有数组是这样，只要是变量，都符合上述性质，局部变量的默认值是随机的，全局变量的默认值才是0。\n关于输入、输出输入scanf(&quot;%d&quot;,&amp;a);//输入整数//&quot;%d&quot;表示整数int//&quot;%lf&quot;表示长浮点数double//&quot;%f&quot;表示浮点数float//&quot;%s&quot;表示字符串string//&quot;%c&quot;表示字符char\n\n注意：scanf ( )是有返回值的，返回值表示成功匹配和赋值的个数（int）\n输出printf(&quot;%d\\n&quot;,a);//输出整数,\\n表示输出a之后回车printf(&quot;%d %d&quot;,a,b);//输出的两个数之间也会空一格空格，跟&quot;%d %d&quot;保持一致\n\n若要使输出保留固定几位小数\nprintf(&quot;%.2lf&quot;,a);//&quot;.2lf&quot;表示保留两位小数输出double类型的a\n\n若想输出固定位数长度的整数，且不够的位补0\nprintf(&quot;%03d&quot;,a);//&quot;%03d&quot;表示输出3位整数，不够的位补0，如25如果按&quot;%03d%输出，结果为025\n\n如果不加0，只规定位数，则不够的位会用空格补齐\nprintf(&quot;%3d&quot;,a);//如25按&quot;%3d&quot;输出，结果为·25(前面的‘·’表示空格，方便看)\n\n\n\n数组操作数组初始化\n#include&lt;string.h&gt;memset(a,0,sizeof(a));//把数组a清零\n\n数组间复制\n将数组a复制k个元素到数组b中\n#include&lt;string.h&gt;memcpy(b,a,sizeof(int)*k);//这里就当a和b都是int数组\n\n同理可知若两个都是double数组，则\nmemcpy(b,a,sizeof(double)*k);\n\n把数组a全部复制到数组b中\nmemcpy(b,a,sizeof(a));\n\n\n\n字符数组输入字符数组\nchar s[20];scanf(&quot;%s&quot;,s);//注意这里的s前面没有“&amp;”\n\n上述语句会将读入的字符串存到字符数组s中，遇到空格、TAB和回车会终止读入\n输入字符\nscanf(&quot;%s&quot;,&amp;s[i]);//这时候前面要加“&amp;”\n\n字符数组的复制\n#include&lt;string.h&gt;char a[10],b[10];strcpy(a,b);//将b字符串复制到a\n\n字符串的比较\nstrcmp(s1,s2);\n\n字符串大小的比较是以ASCII 码表上的顺序来决定，此顺序亦为字符的值。strcmp()首先将s1 第一个字符值减去s2 第一个字符值，若差值为0 则再继续比较下个字符，若差值不为0 则将差值返回。\n#include &lt;string.h&gt;main()&#123;    char *a = &quot;aBcDeF&quot;;    char *b = &quot;AbCdEf&quot;;    char *c = &quot;aacdef&quot;;    char *d = &quot;aBcDeF&quot;;    printf(&quot;strcmp(a, b) : %d\\n&quot;, strcmp(a, b));    printf(&quot;strcmp(a, c) : %d\\n&quot;, strcmp(a, c));    printf(&quot;strcmp(a, d) : %d\\n&quot;, strcmp(a, d));     &#125;\n\n输出结果如下：\nstrcmp(a, b) : 32strcmp(a, c) :-31strcmp(a, d) : 0\n\n\n\n字符串的连接\n#include&lt;string.h&gt;char a[10],b[10];strcat(a,b);//将字符串a的内容接到b字符串之后\n\n注意b字符串大小为10，这个大小需要能够容纳连接后的总字符串长度\n连接的过程相当于将a中的字符串顺序填到b字符串后的空余位置\n如a[10]=”aaa”; b[10]=”bbb”， 连接后的结果为b[10]=”bbbaaa”\n把信息输出到字符串\nint a=65,b=97;char buf[20];sprintf(buf,&quot;%d%d&quot;,a,b);//把a、b两个数格式化输出到字符数组buf中\n\n“%d”部分根据要输出到buf中的内容来定，输字符char就是“%c”，字符串string就是“%s”，都一样的。\n最重要的这是格式化输出到buf中，buf中存的信息为“6597”，即buf[0]=’6’; buf[1]=’5’; buf[2]=’9’; buf[3]=’7’ 。\n而不会发生强制类型转换，将a和b所对应ASCII码的字符存入，比如：\nint a=65;char c[10];*c=a;\n\n这种的就会出现强制类型转换，可能是想把65存到c数组中，但实际会发生强制类型转换，将65对应的ASCII码“A”，存到c数组的第一个位置，即c[0]=’A’\n求数组实际长度\n像上面那样实际buf声明了20个字节大小，实际并没有全部用完，如果直接要求输出buf中20个字节的内容会出现错误，这时就需要判断buf的实际使用大小\n需要用到的函数为\nstrlen(buf);\n\n举例：\nfor(int i=0;i&lt;strlen(buf);++i)&#123;    cout&lt;&lt;buf[i]&lt;&lt;&quot; &quot;;&#125;\n\n这样buf中没有用到的部分不会被要去输出，避免出错\n输入字符串\n使用getchar()函数\nint c;while((c=getchar())!=EOF)//EOF是一个特殊的结束标志&#123;\tprintf(&quot;%c&quot;,c);&#125;\n\n\n\n运算符重载（详见《C++ Primer》P490）重载运算符一般是为了方便直接操作自定义的结构体、类，所以现在这里定义一个结构体，方便下面举例\nstruct Point&#123;    int x,y;    Point(int x=0,int y=0):x(x),y(y)&#123;&#125;//构造函数，默认值0&#125;;\n\n\n\n算术操作符重载\n举例：\nPoint operator + (const Point &amp;A,const Point &amp;B)&#123;    return Point(A.x+B.x,A.y+B.y);&#125;\n\n现在可以直接操作两个Point类型的变量进行加法运算，运算的规则即上面加法所定义的规则\n输出运算符重载\n输出运算符的第一个形参是一个非常量ostream对象的引用；第二个形参是一个常量的引用，该常量是我们想要打印的类类型。\n举例：\nostream&amp; operator &lt;&lt; (ostream &amp;out, const Point &amp;p)&#123;    cout&lt;&lt;&quot;(&quot;&lt;&lt;p.x&lt;&lt;&quot;,&quot;&lt;&lt;p.y&lt;&lt;&quot;)&quot;;//用out装相应打印的内容，再将out返回    return out;&#125;\n\n这是我们便可以直接输出结构的内容，输出的形式就是我们上述定义的形式\n上述重载的使用举例：\nint main()&#123;    Point a,b(1,2);    a.x=3;//a.y没有定义,默认为0    cout &lt;&lt; a + b &lt;&lt; endl;//先使用了重载的Point加法运算，再用了重载的Point输出运算    return 0;&#125;\n\n得到的结果为：\n(4,2)\n\n\n\n模板函数模板\ntemplate&lt;typename T&gt;T sum(T *begin , T *end)&#123;    T *p=begin;    T ans = 0;    for(T *p= begin ; p != end; p++)&#123;        ans = ans + *p;    &#125;    return ans;&#125;\n\n这个函数模板的作用是求数组的和，使用时直接传参数使用即可，会根据所传参数的类型自动将上述的“T”代换成对应的类型\nint main&#123;\tdouble a[] = &#123;1.1 , 2.2 , 3.3 , 4.4&#125;;    cout &lt;&lt; sum(a,a+4)&lt;&lt;endl;    Point b[] = &#123;Point(1,2) , Point(3,4) , Point(5,6) , Point(7,8)&#125;;    cout &lt;&lt; sum(b,b+4);    return 0; &#125;\n\n结构体模板\ntemplate&lt;typename T&gt;struct Point&#123;    T x,y;    Point(T x=0,T y=0):x(x),y(y)&#123;&#125;&#125;;\n\n这时在使用Point模板的时候需要主动声明模板中的“T”具体的类型，具体的用法如下：\nint main&#123;\tPoint&lt;int&gt; a(1,2),b(3,4);    Point&lt;double&gt; c(1.1,2.2),d(3.3,4.4);    return 0;&#125;\n\n\n\n类访问控制\nprivate：私有\npublic：公有\nprotected：保护\n\nclass Test&#123;public:    int a=1;private:    int b=2;protected:    int c=3;&#125;int main()&#123;    Test t;    cout&lt;&lt;t.a&lt;&lt;endl;//ok!public,对象可以访问    cout&lt;&lt;t.b&lt;&lt;endl;//no!private,对象不可访问    cout&lt;&lt;t.c&lt;&lt;endl;//no!protected,对象不可访问    return 0;&#125;\n\n继承\npublic：公有继承，父类中公有成员和保护成员在子类中访问属性不变，私有成员在子类中不可直接访问\n\nprivate：私有继承，父类中公有成员和保护成员在子类中以私有成员身份出现，私有成员在子类中不可直接访问；私有继承使得子类进一步继续派生的情况下，原本父类的成员无法再直接发挥作用，因为它们对进一步派生出的子类而言已经是不可直接访问的私有成员\n\nprotected：保护继承，父类中公有成员和保护成员在子类中以保护成员身份出现，私有成员在子类中不可直接访问\n\n\n派生类的构造函数#include&lt;iostream&gt;using namespace std;class Base1&#123;public:    Base1(int i)&#123;        cout&lt;&lt;&quot;Base1 &quot;&lt;&lt;i&lt;&lt;endl;        a=i;    &#125;    int getnum1()&#123;        return a;    &#125;private:    int a;&#125;;class Base2&#123;public:    Base2(int i)&#123;        cout&lt;&lt;&quot;Base2 &quot;&lt;&lt;i&lt;&lt;endl;        b=i;    &#125;    int getnum2()&#123;        return b;    &#125;private:    int b;&#125;;class Base3&#123;public:    Base3()&#123;cout&lt;&lt;&quot;Base3 *&quot;&lt;&lt;endl;&#125;//Base3构造函数无参数，无须赋值，初始化时会自动调用该构造    int getnum3()&#123;        return c;    &#125;private:    int c=99;&#125;;class Derived:public Base2,public Base1,public Base3&#123;//赋值时按继承顺序赋值，先Base2，后Base1，最后Base3public:    Derived(int a,int b,int c ,int d):Base1(a),member2(d),member1(c),Base2(b)&#123;&#125;//赋值顺序见上下两行注释(注意b和d别看岔了)    int getnumD1()&#123;        return member1.getnum1();    &#125;    int getnumD2()&#123;        return member2.getnum2();    &#125;    int getnumD3()&#123;        return member3.getnum3();    &#125;private:    Base1 member1;//赋值时按照声明顺序赋值，先member1，后member2，最后member3    Base2 member2;    Base3 member3;&#125;;int main()&#123;    Derived obj(1,2,3,4);    cout&lt;&lt;obj.getnumD1()&lt;&lt;endl;//子类使用父类做成员时，能够理所当然使用父类的访问函数，访问父类类型的私有成员    cout&lt;&lt;obj.getnumD2()&lt;&lt;endl;    cout&lt;&lt;obj.getnumD3()&lt;&lt;endl;    cout&lt;&lt;obj.getnum1()&lt;&lt;endl;//子类可以直接通过父类的访问函数，访问初始化之后的父类私有成员    cout&lt;&lt;obj.getnum2()&lt;&lt;endl;    cout&lt;&lt;obj.getnum3()&lt;&lt;endl;    return 0;&#125;\n\n结果展示：\nBase2 2Base1 1Base3 *Base1 3Base2 4Base3 *34991299\n\n说明：\n关于继承，不要忘了父类的私有成员也会被继承过来，只是子类不能直接调用，需要通过父类的方法来调用。\nC++11标准中，子类能够从直接父类中继承构造函数并使用（注意只有直接父类才行）。所以，在子类的构造过程中：\nBase1(a)和Base2(b)实际是在子类Derived中调用父类Base1和Base2的构造函数，来对父类继承过来的私有成员a、b进行初始化。要想访问它们，也要使用父类继承过来的方法才行，即obj.getnum1()、obj.getnum2()\n至于number1(c)、nmuber2(d)的初始化，它们是Base1和Base2类型的实例化对象，所以它们的相关操作就是按类Base1和类Base2中的定义来执行的(按Base类中的构造函数初始化、调用方法之类的)。\n关于Base3()和number3()的初始化，因为它们都有无参构造函数，所以在不传参的时候会默认调用它们的无参构造函数进行舒适化。\n最后是关于初始化的顺序，或者说调用构造函数构造的顺序，实现构造基类Base1-3，再构造子类的对象numbe1-3。\n其中基类的构造顺序按照继承时顺序来构造，继承顺序为：class Derived:public Base2,public Base1,public Base3，所以基类构造时的顺序为：Base2()、Base1()、Base3()。\n子类的对象的构造顺序就按照对象声明时的顺序来，声明顺序为Base1 number1;Base2 number2;Base3 number3;所以子类的对象构造顺序为number1()、number2()、number3()。\n另外补充一点：如果有虚基类，虚基类的构造还要排在基类的构造之前。如下例：\n#include &quot;iostream.h&quot;class OBJ1&#123;    public:    OBJ1()&#123;cout&lt;&lt;&quot;OBJ&quot;&lt;&lt;endl;&#125;&#125;class OBJ2&#123;    public:    OBJ2()&#123;cout&lt;&lt;&quot;OBJ2&quot;&lt;&lt;endl;&#125;&#125;class BASE1&#123;    public:    BASE1()&#123;cout&lt;&lt;&quot;BASE1&quot;&lt;&lt;endl;&#125;&#125;class BASE2&#123;    public:    BASE2()&#123;cout&lt;&lt;&quot;BASE2&quot;&lt;&lt;endl;&#125;&#125;class BASE3&#123;    public:    BASE3()&#123;cout&lt;&lt;&quot;BASE3&quot;&lt;&lt;endl;&#125;&#125; class BASE4&#123;    public:    BASE4()&#123;cout&lt;&lt;&quot;BASE4&quot;&lt;&lt;endl;&#125;&#125;class DERIVER :public BASE1,vitural public BASE2              public BASE3,virtual public BASE4&#123;    public:    DERIVER():BASE4(),BASE3(),BASE2(),BASE1(),obj2(),obj1()&#123;cout&lt;&lt;&quot;DERIVER&quot;&lt;&lt;endl;&#125;    protect:    OBJ1 obj1;    OBJ2 obj2;&#125;/*output    BASE2    BASE4    BASE1    BASE3    OBJ1    OBJ2    DRIVER*/\n\n\nDERIVER的虚基类BASE2和BASE4最先构造，所以先输出了BASE2和BASE4，尽管它们在DERIVER类中的顺序不在最前面。\n然后在构造DERIVER的非虚基类，虽然它们排在前面，但是要优先构造虚基类，所以放在了虚基类后面。\n再构造DERIVER的对象obj1和obj2.它们以类定义时，数据成员排在前面的先构造；\n最后构造DERIVER本身。\n\n抽象类实现多态抽象类的作用就是为后续的派生类提供了一个相当于“标准”之类的东西，派生类对抽象类的中的纯虚函数进行实现，之后定义基类指针，指向子类，然后通过这个指针访问函数时，会根据指针指向的类来具体访问指定类的函数，实现多态\n#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Shape&#123;//抽象类public:    virtual float getArea()=0;//纯虚函数，获得面积    virtual string getName()=0;//纯虚函数，获得图形名称&#125;;class Circle:public Shape&#123;//Circle子类，继承自Shapepublic:    Circle(float r):m_r(r)&#123;&#125;    virtual float getArea()&#123;        return 3.14*m_r*m_r;    &#125;    virtual string getName()&#123;        return &quot;Circle&quot;;    &#125;private:    float m_r;&#125;;class Rectangle:public Shape&#123;//Rectangle子类，继承自Shapepublic:    Rectangle(float w,float h):m_w(w),m_h(h)&#123;&#125;    virtual float getArea()&#123;        return m_w*m_h;    &#125;    virtual string getName()&#123;        return &quot;Rectangle&quot;;    &#125;private:    float m_w,m_h;&#125;;int main()&#123;    Shape* shape=NULL;//定义一个空的基类指针    shape=new Circle(5);//基类指针指向子类对象    cout&lt;&lt;shape-&gt;getName()&lt;&lt;&quot;&#x27;s area:&quot;&lt;&lt;shape-&gt;getArea()&lt;&lt;endl;    delete shape;//释放Circle对象所占内存，但指针仍然存在，需要注意的是现在该指针为野指针，使用前一定要重新赋值    shape=new Rectangle(8,9);//基类指针指向新的子类对象    cout&lt;&lt;shape-&gt;getName()&lt;&lt;&quot;&#x27;s area:&quot;&lt;&lt;shape-&gt;getArea()&lt;&lt;endl;    return 0;&#125;\n\n运行结果：\nCircle&#x27;s area:78.5Rectangle&#x27;s area:72\n\n通过上例，可以看到，针对基类指针指向的不同子类对象，调用相同函数时，相同语句分别实现了不同的功能，分别对应了各自子类的方法，实现了多态。\nauto针对比较长的变量类型时可以直接写成auto，C++会自动判断变量的类型，将auto替换成对应的变量类型\n就比如对vector进行遍历操作时\nfor(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;    cout&lt;&lt;*it&lt;&lt;endl;&#125;//此时就可以直接将&quot;vector&lt;int&gt;::iterator&quot;直接替换为autofor(auto it=vec.begin();it!=vec.end();it++)&#123;    cout&lt;&lt;*it&lt;&lt;endl;&#125;\n\n\n\n\n顺序容器string#include&lt;string&gt;\n\n常用函数\nsize()/length() ：返回字符串长度\n\nempty() ：判断字符串是否为空\n\nclear() ：清空字符串\n\nfind(string s)：返回子串s在母串中的初始位置\n\nsubstr(size_t pos = 0, size_t len = npos) ：返回子串，其中第一个参数pos表示子串起始下标，第二个参数表示子串长度\n\nc_str()：返回字符串所在字符数组的起始地址，主要针对printf用的，printf无法直接输出string类型，只能输出字符数组类型的字符串char[]\n\n\nint main ()&#123;\tstring str=&quot;We think in generalities, but we live in details.&quot;;\tstring str2 = str.substr (3,5); // 起始坐标为3,子串长度为5,得到&quot;think&quot;\tsize_t pos = str.find(&quot;live&quot;); // 返回子串&quot;live&quot;在str中的初始位置\tstring str3 = str.substr (pos); //缺省方式调用substr函数,第二个参数len默认为npos,表示字符串长度最大值.即得到从&quot;live&quot;到字符串结束的子串\tcout &lt;&lt; str2 &lt;&lt; &#x27;\\n&#x27; &lt;&lt; str3 &lt;&lt; &#x27;\\n&#x27;;return 0;&#125;\n\n输出结果为：\nthink live in details.\n\n\n\nvector#include&lt;vector&gt;\n\n支持比较运算，按字典算\n构造函数\nvector()：创建一个空vector\nvector(int nSize)：创建一个vector，元素个数为nSize\nvector(int nSize,const T &amp;t)：创建一个vector，元素个数为nSize，且值均为t\nvector(const vector&amp;)：复制构造函数\nvector(vegin,end)：复制[begin,end)区间内另一个数组的元素到vector中（注意区间左闭右开）\n\n用法举例：\n//创建一个空vectorvector&lt;int&gt; v1;//创建了一个元素个数为n的vectorint n;cin&gt;&gt;n;vector&lt;int&gt; v2(n);//其中这n个元素默认值都为0，此时push_back(x)会在这n个0之后添加x//创建了一个元素个数为n的vector，其中n个元素值都为5vector&lt;int&gt; v3(n,5);//此时push_back(x)会接着在这n个5之后添加x//复制构造函数vector&lt;int&gt; v4(v3);//将v3复制给了v4//复制区间[begin,end)区间内另一个数组的元素到vector中int s[] = &#123;1,6,3,2,5&#125;;vector&lt;int&gt; vec(s, s+5);//s+5指向的是s[]中最后一个元素的后一个位置\n\n常用函数\nsize()：返回向量中元素的个数\nempty()：向量为空则返回true\nclear()：清空向量中的所有元素\nfront()：返回第一个元素的引用\nback()：返回最后一个元素的引用\nbegin()：返回指向向量第一个元素的迭代器\nend()：返回指向向量最后一个元素的后一个元素的迭代器\npush_back()：向量尾部增加一个元素\npop_back()：删除向量中最后一个元素\n\n对于vector排序，可以使用sort函数，sort函数默认升序排序（从小到大）。\n使用sort对vector排序时，从小到大排就用vec.begin()和vec.end()\n如果要从大到小排，就用vec.rbegin()和vec.rend()\nint main()&#123;    int s[] = &#123;1,6,3,2,5&#125;;    vector&lt;int&gt; vec(s, s+5);//初始化vector，将s[]中的内容赋给vec&lt;int&gt;    cout&lt;&lt;*vec.begin()&lt;&lt;endl;   //指向第一个元素    cout&lt;&lt;*vec.end()&lt;&lt;endl;     //指向最后一个元素的后一个位置    cout&lt;&lt;*vec.rbegin()&lt;&lt;endl;  //reverse begin  指向最后一个元素    cout&lt;&lt;*vec.rend()&lt;&lt;endl;    //指向第一个元素的前一个元素        //正向排序 即按照从小到大的顺序排序    sort(vec.begin(), vec.end());    //顺序访问    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    //逆向排序 即按照从大到小的顺序进行排序    sort(vec.rbegin(), vec.rend());    //顺序访问    for(vector&lt;int&gt;::iterator it=vec.begin(); it!=vec.end(); it++)&#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;&#125;\n\n\n\nlist和vector基本一致，要注意的是list的内部存储逻辑是双向链表\nstack#include&lt;stack&gt;\n\n构造函数stack&lt;T&gt; sta;\n\n常用函数\nsize()：返回栈的长度（元素个数）\nempty()：判断栈是否为空\npush()：向栈顶插入一个元素（入栈）\npop()：弹出栈顶元素（出栈）\ntop()：返回栈顶元素\n\nqueue#include&lt;queue&gt;\n\n构造函数queue&lt;T&gt; que;\n\n常用函数\nsize()：返回队列长度（元素个数）\nempty()：判断队列是否为空\npush()：向队尾插入一个元素（入队）\npop()：弹出队头元素（出队）\nfront()：返回队头元素\nback()：返回队尾元素\n\ndequeue#include&lt;queue&gt;\n\n构造函数deque&lt;T&gt; dq;\n\n常用函数\nsize()：返回双端队列长度（元素个数）\nempty()：判读双端队列是否为空\nclear()：清空双端队列\nfront()/back()：返回队头/队尾元素\npush_back()/pop_back()：向队尾添加元素/从队尾弹出元素\npush_front()/pop_front()：向队头添加元素/从队头弹出元素\nbegin()：返回指向队中对一个元素的迭代器\nend()：返回指向队列最后一个元素的后一个元素的迭代器（past-the-end，是个理论上的元素）\n\npriority_queue#include&lt;queue&gt;\n\n常用函数\nempty()：队列为空，返回true\ntop()：返回队顶元素\npop()：删除队顶元素\npush()：插入一个元素（根据规则自动排序）\nsize()：返回优先队列中拥有的元素个数\n\n定义template&lt;    class T,    class Container = std::vector&lt;T&gt;,    class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue;\n\n\n\n\n参数\n描述\n默认值\n\n\n\nT\n优先队列中存放的数据类型\n\n\n\nContainer\n用于实现优先队列（潜在）的容器类型\nvector&lt;T&gt;\n\n\nCompare\n比较函数，用于判断一个元素是否小于另一个元素。如果 Compare(x,y) 为真，则 x 小于 y。Q.top()  返回的元素是优先级队列中最大的元素。也就是说，它的属性是，对于优先级队列中的每个其他元素 x，Compare(Q.top(), x) 为  false。\nless&lt;T&gt;\n\n\n\nContainer：必须是用数组实现的容器，如vector、deque，但不能用list。STL中默认使用vector\nCompare：比较方式默认使用less&lt;T&gt;，operator &lt; (小于号)\n如果把后面两个参数缺省，优先队列使用默认参数，为大根堆，队顶元素最大\n\npriority_queue&lt;int&gt; que;//等价于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; que;//编译器比较旧两个将括号中间加空格，保险起见，直接加空格为好，防止识别成右移&quot;&gt;&gt;&quot;\n\n\n\n其中less&lt;T&gt;为仿函数，定义如下：\n// TEMPLATE STRUCT lesstemplate&lt;class _Ty&gt; struct less : public binary_function&lt;_Ty, _Ty, bool&gt;&#123;\t// functor for operator&lt;\tbool operator()(const _Ty&amp; _Left, const _Ty&amp; _Right) const\t&#123;\t// apply operator&lt; to operands\t\treturn (_Left &lt; _Right);\t&#125;&#125;;\n\nless&lt;T&gt;使用的比较规则是基于 &lt;（小于号）的，所以当priority_queue是基于less比较规则的时候，我们可以重载 &lt;（小于号）来实现自定义类型变量的比较\n更改比较函数——仿函数greater&lt;T&gt;上面已经说过默认的比较规则less&lt;T&gt;，由此实现了大根堆的优先队列；STL还定义了与less&lt;T&gt;相对的仿函数greater&lt;T&gt;，将priority_queue的第三个参数，即比较规则改为greater&lt;T&gt;即可实现小根堆。\npriority_queue&lt;int ,vector&lt;int&gt; ,geater&lt;int&gt; &gt; que;\n\n其中greater&lt;T&gt;的定义如下：\n// TEMPLATE STRUCT greatertemplate&lt;class _Ty&gt;struct greater : public binary_function&lt;_Ty, _Ty, bool&gt;&#123;\t// functor for operator&gt;\tbool operator()(const _Ty&amp; _Left, const _Ty&amp; _Right) const\t&#123;\t// apply operator&gt; to operands\t\treturn (_Left &gt; _Right);\t&#125;&#125;;\n\n可以看到相较于less&lt;T&gt;，greater&lt;T&gt;的比较规则是基于 &gt;（大于号）的，所以如果要在基于greater&lt;T&gt;的比较规则下实现自定义类型变量的比较，需要重载 &gt;（大于号）。\n自定义类型——大顶堆STL中的仿函数less&lt;T&gt;和greater&lt;T&gt;的使用范围仅限于基本类型，当使用我们自定义的数据类型时，我们需要自定义比较规则。\n\n**重载运算符 &lt; **\n\n为什么要重载 &lt;（小于号）而不是 &gt;（大于号），原因在于此时我们的声明形式通常是将后面两个参数缺省的，也就是此时会默认使用仿函数less&lt;T&gt;，而less中的比较使用的是 &lt;（小于号）。如果想要重载 &gt;（大于号），还需要在声明priority_queue时注明剩下的两个参数，并将第三个参数设置为greater&lt;T&gt;，所以完全不必如此自找麻烦，直接重载 &lt;（小于号）即可。\n// 重载 &lt; 运算符，实现大顶堆//（堆顶元素：先根据x，选择x最大的元素；若两个元素的x值相同，再根据y，选择两者中y较大的元素） bool operator&lt;(My_Type a,My_Type b)&#123;    // 定义排序规则     if(a.x==b.x) return a.y&lt;b.y;    return a.x&lt;b.x; &#125;// 定义优先队列priority_queue&lt;My_Type&gt; que;//缺省声明，默认使用less&lt;T&gt; \n\n\n自定义仿函数\n\n从priority_queue的定义中已经知道，它进行排序需要依靠其第三个参数定义的比较规则，而这些比较规则用的是仿函数，所以除了重载仿函数使用的比较运算符，我们可以直接自己写一套比较规则，也就是自定义一个仿函数，来实现我们需要的自定义类型变量的比较\n// 仿函数，实现大顶堆 struct cmp&#123;    // 定义排序规则     bool operator() (My_Type a,My_Type b )    &#123;         if(a.x==b.x)return a.y&lt;b.y;        return a.x&lt;b.x;     &#125;&#125;; // 定义优先队列priority_queue&lt;My_Type,vector&lt;My_Type&gt;,cmp&gt;que;\n\n\n\n自定义类型——小顶堆跟自定义类型的大顶堆同理，只需要改变部分细节即可\n\n**重载运算符 &lt; **\n\n// 重载 &lt; 运算符，实现小顶堆 bool operator&lt;(My_Type a,My_Type b)&#123;    // 定义排序规则     if(a.x==b.x) return a.y&gt;b.y;    return a.x&gt;b.x; &#125;\n\n\n自定义仿函数\n\n// 仿函数，实现小顶堆 struct cmp&#123;    // 定义排序规则     bool operator() (My_Type a,My_Type b )    &#123;         if(a.x==b.x)return a.y&gt;b.y;        return a.x&gt;b.x;     &#125;&#125;; \n\n\n\n关联容器pair#include&lt;utility&gt;\n\n类模板：template&lt;class T1,class T2&gt; struct pair\n参数：T1表示第一个值得数值类型，T2是第二个值得参数类型\n功能： pair将一对值（t1，t2）组合成一个值，这一对值可以具有不同数据类型，分别通过pair的成员函数first和second访问\n构造函数pair&lt;T1,T2&gt; p1;//创建一个空pair对象pair&lt;T1,T2&gt; p2(v1,v2);//创建一个pair对象,p2.first=v1,p2.second=v2\n\n常用操作\nmake_pair(v1,v2)：以v1和v2的值创建一个新pair对象，元素类型分别为v1和v2的变量类型\n\nauto p=make_pair(v1,v2);\n\n\np.first：返回p中第一个元素\np.second：返回p中第二个元素（注意这两个是pair的成员，使用时不要加括号）\np1 &lt; p2：两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true\np1==p2：如果两个对象的first和second依次相等，则这两个对象相等\n\nmap/multimap#include&lt;map&gt;\n\nmap定义template&lt; \tclass Key,                                     // 指定键（key）的类型    class T,                                       // 指定值（value）的类型    class Compare = less&lt;Key&gt;,                     // 指定排序规则    class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;    // 指定分配器对象的类型&gt; class map;\n\n\n\n\n参数\n描述\n默认值\n\n\n\nkey\n指定键（key）的类型\n\n\n\nT\n指定值（value）的类型\n\n\n\nCompare\n指定排序规则\nless&lt;key&gt;\n\n\nAlloc\n指定分配器对象的类型\npair&lt;key,T&gt;\n\n\n\n通常情况在声明map类型变量是只设定前两个参数的值\n第三个参数默认使用less&lt;key&gt;规则排序，即会按照key值的大小进行升序排序，可根据自身需要改变该参数（自定义仿函数）或者重载 &lt;（小于号）\n第四个参数基本不会用到，其默认为pair&lt;key,T&gt;，即map中每个元素是一个pair对象\n\nmap和multimap的区别map中的一个关键字key只能出现一次，而multimap中的，一个关键字key可以出现多次\n构造函数map&lt;int,int&gt; m;//简单举个例子\n\n\n\n常用函数\nsize()\nempty()\nclear()\nbegin()/end()\n++/--：支持迭代器的++或--操作\ninsert()：向map中插入键值对，元素类型应为pair类型\n\nmap&lt;string,int&gt; m;pair&lt;string,int&gt; p;//有现成pair类型m.insert(p);//没有现成pair类型，可以在insert参数列表中创建一个pairm.insert(&#123;&quot;word&quot;,1&#125;);m.insert(make_pair(&quot;word&quot;,1));m.insert(pair&lt;string,int&gt;(&quot;word&quot;,1));m.insert(map&lt;string,int&gt;::value_type(&quot;word&quot;,1));//value_type是map中的类型别名，在这里相当于pair&lt;string,int&gt;，一般谁这么写啊...\n\n\n erase()：删除元素\n\n\n\n\n具体操作\n描述\n\n\n\nc.erase(k)\n从c中删除每个关键字为k的元素，返回一个size_type值，指出删除的元素的个数\n\n\nc.erase(p)\n从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能使c.end()。返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end()\n\n\nc.erase(b,e)\n删除迭代器对b和e所表示的范围中的元素。返回e\n\n\n\noperator[]：map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。\n注意multimap并不支持下标操作，毕竟multimap中相同关键字可以出现多次\n\nc[k];//返回关键字为k的元素(返回的是key对应的value)，如果k不在c中，添加一个关键字为k的元素，对其进行值初始化c.at(k);//访问关键字为k的元素(也能返回key对应的value)，带参数检查；若k不在c中，抛出一个out_of_range异常\n\n\nfind(k)：在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。\n\n//比较find()和下标操作可以看出，下标操作在没有找到指定key值得元素的时，会自动添加一个键值为key，value默认为0的元素;find()则不会改变map//所以在不想改变map的情况下，想判断一个元素是否存在应使用find()而不是下标寻找//当然如果肯定key值对应的元素存在，就是要用下标来找当然没问题\n\n\ncount(k)：返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1\nlower_bound(k)：返回一个迭代器，指向第一个关键字不小于k的元素\nupper_bound(k)：返回一个迭代器，指向第一个关键字大于k的元素\n\nset/multiset#include&lt;set&gt;\n\nset模板定义template &lt; \tclass T,                        // 键 key 和值 value 的类型    class Compare = less&lt;T&gt;,        // 指定 set 容器内部的排序规则    class Alloc = allocator&lt;T&gt;      // 指定分配器对象的类型&gt; class set;\n\n\nset和map相似，里面存储的也是键值对，但是set中键key和值value的数值要是相等的，因此在声明时只需指定一个变量类型，作为key和value共同的类型\nset也默认使用less&lt;T&gt;的排序规则\n参数三默认的分配器类型是？\n\nset和multiset的区别multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。\n常用操作与map/multimap基本一致，参考map/multimap部分即可\nunordered_set, unordered_map, unordered_multiset, unordered_multimap\n上述容器的无序版本，不会对存储的元素进行排序\n相关的操作也和上述关联容器形似\n会有一些特定的函数使用不了，比如lower_bound(k)/upper_bound(k)这类牵扯到比较大小的函数\n注意这些容器使用的存储逻辑是哈希表，不支持迭代器的++或--操作\n\n待总结bitset, 圧位​    bitset&lt;10000&gt; s;​    ~, &amp;, |, ^​    &gt;&gt;, &lt;&lt;​    ==, !=​    []\ncount()  返回有多少个1\n\nany()  判断是否至少有一个1\nnone()  判断是否全为0\n\nset()  把所有位置成1\nset(k, v)  将第k位变成v\nreset()  把所有位变成0\nflip()  等价于~\nflip(k) 把第k位取反\n\n","categories":["笔记"],"tags":["C","C++"]},{"title":"大家一起学英语","url":"/2023/03/07/English-Word/","content":"引言在学习OCC、PCL等C++库，或是其他一些技术时，通常需要阅读官方提供的技术手册，而这些手册大多是英文编写，虽然可以直接使用翻译软件进行翻译，但毕竟翻译软件有时翻译的也是词不达意，加之它可能把人家定义的类名之类的东西也翻译成中文，还不如直接看英文。综上，长远来看，提升自己的英文水平总没错，本文用来收集阅读英文手册或教程时遇到的各种不认识的单词，也不指望能将这些单词全部融汇贯通，但希望下次见到时最起码能认得它是个什么意思。\nOCC\ngeometry：几何学\nparametric：参数\ndimension：纬度\ninfinity：无限大\nsecond order：二阶\ncriteria：标准\nscaled ellipse：缩放的椭圆\ncylinder：圆筒\nconjugate：共轭的\nprojection：投影\nintersection：交叉点\ntopology：拓扑学\n\nPCL\ncomplicate：复杂化\ntrim：修剪\noutliers：离群值、异常值\ndeviation：偏差\n\nCloudCompare Wiki\nmesh：网格\nportable：便携式（可移植）\ntrade-off：权衡利弊\nentity：实体\nproperty：属性（财产）\nscalar：标量\nscale：规模、刻度\nalign：对齐\nalignment：对齐\nregistration：配准（注册）\nfine registration：精确配准\nprimitive：原始的、基础的\nprimitive factory：基体工厂（创建基础模型）\ncloud/primitive Dist：点云/基体距离\nmerge：合并\nsubsample：子样本\nOctree：八叉树\nhistogram：直方图\nprojection：预测\nSF（scalar field）：标量字段\nrasterize：栅格化\nvolume：体积\nstatistic：统计数据\nALS：机载激光雷达扫描\nTLS：地面激光雷达扫描\n\nOctree Wikipediahttps://en.wikipedia.org/wiki/Octree\n\nOctree：八叉树，用来将3维空间递归地细分为8个卦限，它相当于三维空间的四叉树\nQuadtree：四叉树，用来将2维空间递归的分为4个象限。\noctant：卦限，类似于于二维空间的象限，一维空间的ray\nquadrant：象限\nray：射线（？）\nrecursively：递归的\nsubdivide：细分\nanalog：模拟、类似\ndimension：纬度\n\nImplementation for point decompositionThe example recursive algorithm outline below (MATLAB syntax) decomposes an array of 3-dimensional points into octree style  bins. The implementation begins with a single bin surrounding all given  points, which then recursively subdivides into its 8 octree regions.  Recursion is stopped when a given exit condition is met. Examples of  such exit conditions (shown in code below) are:\n\nWhen a bin contains fewer than a given number of points\nWhen a bin reaches a minimum size or volume based on the length of its edges\nWhen recursion has reached a maximum number of subdivisions\n\nfunction [binDepths, binParents ,binCorners, pointBins] = OcTree(points)binDepths = [0]     % Initialize an array of bin depths with this single base-level binbinParents = [0]    % This base level bin is not a child of other binsbinCorners = [min(points) max(points)] % It surrounds all points in XYZ spacepointBins(:) = 1    % Initially, all points are assigned to this first bindivide(1)           % Begin dividing this first binfunction divide(binNo)% If this bin meets any exit conditions, do not divide it any further.binPointCount = nnz(pointBins == binNo)binEdgeLengths = binCorners(binNo, 1:3) - binCorners(binNo, 4:6)binDepth = binDepths(binNo)exitConditionsMet = binPointCount&lt;value || min(binEdgeLengths) &lt; value || binDepth &gt; valueif exitConditionsMet    return; % Exit recursive functionend% Otherwise, split this bin into 8 new sub-bins with a new division pointnewDiv = (binCorners(binNo, 1:3) + binCorners(binNo, 4:6)) / 2for i = 1:8    newBinNo = length(binDepths) + 1    binDepths(newBinNo) = binDepths(binNo) + 1    binParents(newBinNo) = binNo    binCorners(newBinNo) = [one of the 8 pairs of the newDiv with minCorner or maxCorner]    oldBinMask = pointBins == binNo    % Calculate which points in pointBins == binNo now belong in newBinNo    pointBins(newBinMask) = newBinNo    % Recursively divide this newly created bin    divide(newBinNo)end\n\n\n\n\n\n\n\n\n\n不定期更新中。。。\n","categories":["英文学习"],"tags":["English Word"]},{"title":"编译CloudCompare","url":"/2023/04/06/CloudCompare-Cmake/","content":"CloudCompare，后续简称CC\n依赖Qt5CC是基于Qt5开发的，所以编译前需要安装Qt5，具体的Qt5版本根据CC源码的版本可能也有不同，需要自己去看源码中build.md文件说明。我要编译的CC版本是2.12.4，该版本的build.md文件提到2.11+版本之后的Qt版本要求为：5.9 &lt;= Qt &lt; 6.0. 所以我直接安装了Qt5的最新版本Qt5.15.2，就用的官网提供的在线安装包，具体的安装教程见“Qt在线安装包配置国内镜像源”。\nOpenGLOpenGL其实电脑有自带的，但我看Cmake找到的那个自带的好像是win8版本的，不知道好用不好用，我就给他重新配了之前VS安装的win11版本的。这个OpenGL不用特意装，安装Windows SDK就会带着，通过VS installer就可以安。\n\n\n源码下载上面两个依赖配置好之后去官方Github下载需要编译的源码，前面也提到过，我选了v2.12.4版本\n\n\n下下来之后要注意这个其实是不完整的，作者把核心算法库单独拿了出来，放在CCCoreLib项目里。\n我们直接打开下载下来的文件，找到”CloudCompare/libs/qCC_db/extern/“ 目录，会发现里面是空的，但是用Cmake编译的时候他又会报错，告诉你需要这个文件夹中的文件，那如何找到这个项目的位置，只需要在GitHub中找到这个目录的位置，会发现官方在这里给出了超链接，跟着超链接就能找到需要的内容。\n\n\n点击这个超链接就会跳转到CCCoreLib库的所在，这里直接下载这个默认的即可\n\n\n之后将下载下来的文件解压到之前空文件夹的位置即可，后面再细说。\n然后这个其实也不是完整的，它里面也有需要去其他地方下载的文件，找到”CCCoreLib/extern/“ 目录，发现里面也有个超链接\n\n\n这个下载默认的即可，下载下来解压到对应的目录。\n\n\n\n\n组合下载下来一共3个项目\n\n\n将nanoflann中的内容，全部放到”CCCoreLib-master/extern/nanoflann“目录中\n\n\n然后再把上面这个组合好的CCCoreLib-master中的内容全部放到”CloudCompare-2.12.4/libs/qCC_db/extern/CCCoreLib“目录里\n\n\n这样才算是得到完整的能够编译的CC文件，后面就用这个CloudCompare-2.12.4文件夹里的内容做Source，用Cmake编译即可。\n编译老三样，三个文件夹source、build、install\nCmake编译，记得把install路径改过来\n配置Qt5路径主要是配Qt5_DIR的路径，根据自己的Qt5安装路径来配，我的是\nE:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5\n\n配完这个之后其他的Qt5路径它就自动识别了\n\n\nQt5LinguistTools路径有一个除外，每错，就是这个Qt5LinguistTools的路径，明明安装了，而且也跟它识别到的其他的Qt5组件在一个路径里，不知道它为什么自己找不到，需要我们自己再告诉它一下，路径为\nE:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5LinguistTools\n\n\n\n配置OpenGL路径他其实自己找到了一个路径\nC:&#x2F;Program Files (x86)&#x2F;Windows Kits&#x2F;8.0&#x2F;Lib&#x2F;win8&#x2F;um&#x2F;x64\n\n\n\n但我看他这个路径名，好像是win8的版本吧。。。我不太放心，就用了前面提到的用VS安装的win11版本的，具体路径为：\nE:&#x2F;Windows Kits&#x2F;10&#x2F;Lib&#x2F;10.0.22000.0&#x2F;um&#x2F;x64\n\n\n\n至于具体怎么找到这个路径的，还是用到之前其它教程提到的”everything“，搜索”OpenGL32.lib“，这个文件所在路径即为所求\n\n\n之后就是一路configure、generate、Open Project老三样\n然后在VS里”ALL_BUILD“右键生成、”INSTALL“右键生成即可\n\n\n\n\n编译文件说明编译前的源代码中有xxx.ui文件，可以通过该文件学习其中的界面布局\n\n\n可以通过文本编辑器来打开xxx.ui文件，里面是用xml语言写的布局。\n\n\n也可以通过Qt Designer打开该xxx.ui文件，直接来看它的布局\n\n\n不过上述两种都只能是辅助，比较好的还是要看与xxx.ui文件所对应的ui_xxx.h文件，直接看代码来学，再结合Qt Designer里的布局来学比较好，xml语言还是不太熟，而且一般也不会自己写xml来设计布局吧。。。\n而对应的ui_xxx.h文件的生成是靠编译xxx.ui文件产生的，之前我们编译整个项目的时候，它也跟着生成了，编译生成的文件位置就在build文件夹当中\n以Source源码中ccViewer子项目中的ccviewer.ui文件为例，其生成的对应的ui_ccviewer.h文件具体位置为build/ccViewer\n\n\n不过根据具体项目的不同，可能具体位置也有点出入，不过都是编译生成再build文件中\n具体的可以通过everything来搜索ui_xxx.h来确定具体的位置\n\n\n\n\n补充测试了一下编译生成的cloudcompare和ccviewer，发现不能读取pcd文件，而且图标也比安装版的糊，不知道为什么。。。\n网上查了下，可能是cmake的时候，有些plug选项没选导致的，我当时编译就按它默认的选项，没多选也没取消选择，下面记录下网上找到的plug选项试一下\n\n\n相比之前默认的选项，多选了上面这两项，再编译的时候提示我要配置\n更正，除了上面两项还选了PCL，我这次先试试只配置PCL看看能不能读取pcd文件\n\n\n配置pcl位置\n\n\n报错力\n\n\n可能是我自己重新编译的问题？我重安一遍官方提供的试试\n还真是，我重新配了一下官方安装版就编译通过了\n但之后发现还是没法读取pcd文件，于是这次打算再把PLUGIN_IO_QPDAL选上试试\n结果被QPDAL的安装难倒了，不想搞这个了\n我又查了查好像不需要，还是只用PCL就行，不过可能需要把PCL重新编译一下，然后选个IO之类的东西给激活。\n看了看官方回复，应该不用重新编译PCL，项目里有PCL_IO_PLUGIN，不知道为什么还是不行\n\n\n通过师兄的指引，点开具体的项目文件来查看，发现QPCL_IO_PLUGIN中的文件有报错，而输出又没显示，所以一直都被我忽略了。\n\n\n错误提示为”C++ 命令行错误: 宏定义无效: BOOST_ALL_NO_LIB-DBOOST_ALL_NO_LIB“\n去查了一下这个问题，通过修改PCL安装目录下cmake目录，里面有个PCLConfig.cmake文件，定位到该文件的第130行。将**if(WIN32 AND NOT MINGW)替换成if(WIN32 AND NOT MINGW AND NOT “${BOOST_DEFINITIONS}” MATCHES “BOOST_ALL_NO_LIB”)**。这样就不会报上述错误了。\n\n\n但是编译之后还是不行，仍然没法读PCD格式的文件。\n不过插件的位置倒是出现PCL的部分了，也算是一点进步，但还是识别不到PCD格式真不知道是哪里的问题。。。\n\n\n又注意到cmake编译时第一句”Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.“ \n\n\n我去看了一下确实没安Windows 10.0.22621版本的SDK，然后我又去重新安了一下这个版本的SDK\n\n\n安完这个SDK之后，再来编译发现确实不太一样\n\n\n但最后结果一样的，还是不行，pcd格式识别 不了。\n","categories":["教程"],"tags":["CloudCompare"]},{"title":"OCC7.6+VS2022配置","url":"/2023/03/08/OCC7.6-VS2022-config/","content":"OCC安装与编译安装OCC安装很简单，就是去官网https://dev.opencascade.org/ 下载安装包安装即可。\n这里用的是OCC7.6版本。\n\n\n注意：安装的时候路径不要有空格和汉字。\nVS2022编译v142的OCC安装之后得到的是OCC的编译前的资源文件，而想要使用OCC提供的方法还需要将这些文件进行编译。即编译后得到的文件才是我们使用OCC所必须的。\n这里我安装的VS版本为2022，其默认的生成工具是v143，而OCC7.6最新支持的生成工具是v142，所以需要稍微操作一下，使VS2022能编译OCC。\n需要注意的是，因为要用到v142生成工具，肯定要保证VS安装了v142的生成工具，没安的话打开Visual Studio Installer安一下即可。\n\n\n下面是OCC部分编译前的一些操作：打开安装目录下 \\opencascade-7.6.0 目录下的custom.bat，将其中要求的vcvarsall.bat文件所在路径填写完整，该路径跟VS安装的位置有关，下图我的路径配置。题外话，推荐安装一个”notepad++“，轻量级代码编辑器，很好用。\n\n\n如果实在不知道在哪，可以安装一个软件”everything“，用它来查找vcvarsall.bat的位置即可\n\n\n之后，还是在 \\opencascade-7.6.0 目录下，打开env.bat，在图示位置添加：set “VCVER=vc143”\n\n\n再打开 \\opencascade-7.6.0\\adm\\msvc目录下，复制一份vc142并重命名为vc143，这就是前面提到的，OCC7.6还没有对应的2022版本（vc143）\n\n\n补充：最近在win11新电脑上配的时候发现只配上面几步，在执行后面双击目录 \\opencascade-7.6.0下的msvc.bat文件时，没有打开对应的sln文件。所以在这里再加一步，在安装目录下的 \\opencascade-7.6.0文件夹，找到msvc.bat，编辑该文件，将第5行的”%1”和”%2”两个参数分别改为”vc143”和”win64”，如下图。改完保存退出。\n\n\n至此准备工作结束，可以用VS2022编译OCC7.6了\n双击刚才编辑完的msvc.bat，它会根据前面的配置打开对应版本的OCCT.sln，打开后会需要确认是否升级平台工具集，记得选择”无升级“。\n\n\n之后找到“解决方案资源管理器”，右键“解决方案”，选择“生成解决方案”即可\n\n\n等待VS编译完成\n\n\n编译完成后生成的文件在 \\opencascade-7.6.0\\win64\\vc14 目录下\n\n\n其中的bind文件夹、libd文件夹中的文件是我们使用OCC所必需的的文件。一般是bin文件夹和lib文件夹，不过在OCC这里是bind和libd，应该是分别表示bin和lib的debug版本。因为我一直用的debug版本调试，找的教程也都是说配bind和libd的，不太清楚这个bin和lib是不是在release版本下用的，等之后如果用到release调试的时候试一下看看，等试过之后再来补充。\nlibd文件夹，存放程序运行时所需要的lib文件，lib文件是指程序库（library）文件，也称为静态链接库（static library），它包含了一组可在程序中共享的函数和资源的代码。\nbind文件夹，存放运行lib时所必需的的dll文件，DLL（Dynamic Link Library）是一种可执行文件格式，它包含一组可在多个程序中共享的函数和资源。它通常被用于在 Windows 操作系统中实现共享库和插件的功能。一个 DLL 文件可以包含多个函数和资源，其他程序可以通过动态链接库（Dynamic Link Library）的方式调用 DLL 文件中的函数。\nVS中配置OCC环境前面也提到，我们所需的bind文件夹和libd文件夹生成好了之后，就可以配置在VS中使用OCC所需的一些属性，像OCC、PCL、VTK这种C++的库，其项目属性配置基本都是一致的，基本就是三步走。\n第一步，将dll文件所在路径，在OCC这里即是上述提到的bind文件夹路径，添加到系统环境变量Path中\n有时候更改完环境变量之后可能需要重启一下电脑才能生效。\n\n\n再补充一点，上面加的这个环境变量只是最基本的，有时候程序调的OCC函数可能用到它自带的其他第三方库函数，这时可能会报缺少xxx.dll文件的错误，这时候就用”everything“查找该文件名，然后把该文件所在路径加到上面的环境变量里就行。比如这里程序运行时提示我缺少”tbb_debug.dll”，我就去搜这个文件，发现有很多该文件，选一个觉得最靠谱的文件路径添加到上面环境变量Path里就行。我这里看这个文件夹路径是vc14，感觉应该是适配vc14x版本的dll文件，我就选了这个。\n\n\n之后在我们所建的项目中，在解决方案栏中，右键点击项目，选择属性一栏\n\n\n在属性页找到 调试—&gt;环境，输入 PATH=%PATH% ，使调试时能找到环境变量中bind所在路径，进一步能找到dll文件\n\n\n第二步，在属性页中找到 链接器—&gt;常规—&gt;附加库目录，将libd所在路径添加进去，方便编译器编译时能找到lib文件\n\n\n再找到 链接器—&gt;输入—&gt;附加依赖项，将libd文件夹下所有的lib文件添加进去\n\n\n至于如何快速取得文件夹下所有lib文件列表，找到目标文件夹libd，在该文件夹下“shift+右键”，选择 Powershell打开\n\n\n在该命令窗口输入 ls *.lib -n，即可得到该文件夹下所有lib结尾的文件列表，其中-n是指定列出来的信息只包含文件名和后缀，可以自己试试不带-n的结果\n\n\n第三步，在属性页找到 C/C++—&gt;常规—&gt;附加库包含目录，将OCC的头文件路径添加进去，该路径为安装目录下 \\opencascade-7.6.0\\inc ，其中存放的是在使用OCC时所需的所有头文件\n\n\n上面三步无关顺序，能配完就行。\n至此，就可以在C++程序中使用OCC提供的各种功能啦，开始愉快编程啦~\nVS属性表的使用新建属性表上面配置的VS属性页只针对当前项目有效，如果要新建项目并使用OCC，需要将上面的三个步骤再配置一遍，很不方便。而使用VS属性表就可以实现只用配置一次，下次直接拿来用即可的效果\n在VS窗口上边菜单栏找到 视图—&gt;其他窗口—&gt;属性管理器\n\n\n选择之后，属性管理器就会出现在解决方案管理器旁边的位置\n\n\n找到自己需要的版本，比如我一般使用Debug|x64版本，我就在对应项旁边右键，选择 添加新项目属性表\n\n\n因为是给OCC配置的属性表，就叫OCC.props吧，至于这个位置，它默认是建在当前项目所在的文件夹中，可以自定义一个文件夹位置，就光用来存这种属性表，当时候项目中需要哪个属性表，就直接去那个文件夹中好就行。\n\n\n在建好的属性表里，把前面第二步、第三步里，关于“C/C++”和“链接器”选项中的部分复现一下即可，简单概括就是“C/C++”的附加包含目录里添加头文件目录，”链接器“的附加库目录里添加lib库路径、附加依赖项里把lib库中的所有lib添加进去。\n\n\n可以看到这个属性表里没有第一步中“调试”选项，所以在 调试—&gt;环境，输入 PATH=%PATH% 这一步还是需要在具体的新建项目中配置一下，步骤参考前面第一步。\n使用已有属性表上面属性表建好之后，下次新的项目要是用OCC的时候，直接把这个属性表引入即可\n在属性管理器，要是用的对应版本处右键点击，选择 添加现有属性页\n\n\n找到之前建好的属性表，添加即可\n\n\n需要注意的是，通过这种添加现有项方式加入的属性表并不是把之前建的表复制了一个放在新项目里，新项目中是找不到这个属性表文件的，它实际还是之前建的那个属性表，只是编译器把它链接了过来，使我们可以使用该表的配置。这也意味着你如果在对这个属性表进行改动，会影响到所有使用该属性表的项目，一定要注意。\n\n\n当然，其实也可以将之前建的属性表复制一个到新建项目的文件夹里，然后在添加现有项时添加当前这一个，这样就可以随便改了，也不会对别的项目有什么影响。\n以上。\n","categories":["教程"],"tags":["OCC"]},{"title":"PCL1.12.1+VS2022+Qt6.4 配置","url":"/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/","content":"本教程分为两部分，第一部分为PCL+VS的配置，第二部分为PCL+VS+QT的配置。\n如果只是要在VS用用PCL，学习一下PCL点云库，只看第一部分PCL+VS的配置即可。\n而如果还需要配合QT做界面，相关的配置会在第二部分PCL+VS+QT的配置中介绍。\nPCL+VS 配置PCL安装前言PCL（Point Cloud Library）官方网站 https://pointclouds.org/\n官方github网站 https://github.com/PointCloudLibrary/pcl\nPCL官方的github提供了各种版本的PCL源码，同时还提供了已经编译好的PCL供使用。\n解释一下，PCL正常来配置的话，是需要自己安装PCL依赖的第三方库，一般有Boost、Eigen、FLANN、OpenNI2、Qhull、VTK，我们需要将这些第三方库从各自官网下载下来，分别用Cmake编译好，然后再编译PCL的源码，因为PCL编译时要依赖上述第三库编译出的文件，包括库文件（library）等二进制文件。这样的优势在于编译PCL的时候可以自选PCL的一些组件，比如可以指定PCL的GPU加速模块（默认是不带的），还可以指定要与Qt6配合使用，它应该就会在编译时往与Qt6适配这方面有进一步的优化。但缺点就是麻烦，要把上面每一个第三方库都安装编译一遍可不是一般的麻烦，而且各个第三方库版本之间的兼容性、适配度也需要自己摸索。\n所以官方也提供了已经完全编译好的PCL安装包供我们使用，该安装包包含上述的所有第三方库编译好的文件，以及依赖它们所编译好的PCL文件。当然，官方提供的这种安装包得到的PCL只提供了最基本的功能，不含GPU模块等扩展。而且其中所带的第三库也都是最基本的配置，就比如其中自带的VTK，就没有针对Qt6做额外的配置，缺少与Qt6配合所需的文件。\n因此，个人认为，最佳的PCL配置安装路线是，1、先使用官方提供的AllInOn安装包，就是之前提过的官方提供的自带编译好的第三方库及编译好的PCL的安装包。补充一下，这个安装包自带的第三方库安好后，从各自的文件夹名字基本能得知每个第三库的版本，即我们可以从中得知当前PCL版本要与第三方库的哪些版本配合兼容性好。2、根据自己的需求，自己安装编译对应版本的第三方库，并用它替换掉PCL自带的对应部分的第三方库。就比如，我要使用VTK配合Qt的组件，而PCL自带的VTK显然不带与Qt配合的部分。因此我去VTK官网自己下一个VTK源码，并自己编译，编译时配置与Qt配合，那我得到的编译后的文件就带有我所需的与Qt配合的部分。之后我用我自己编译好的VTK文件（包括bin、lib、include等），把PCL自带的VTK的这些文件都替换掉。当然，如果没有这类需求，只是想自己编译一下PCL，比如自己编译PCL增加一个GPU模块，那这第2步就没有必要。3、前面是编译PCL的准备步骤，准备好PCL编译所依赖的第三方库文件（编译好的），下面就是编译PCL，去官网下载对应版本的PCL源码，使用CMake编译即可，编译的时候绑定好这些第三方库的位置、选好要用的PCL模块。具体操作见本教程第二部分“PCL+VS+QT 配置” 。\n官方编译版安装下面开始官方编译版PCL的安装教程，因为如果只是配合VS来学习PCL库，安这个也就够用了，有进一步的自定义需求的可以接着看第二部分。\n在官方github网站（PCL项目）的右侧找到Releases部分\n\n\n\n\n他这里把最新的版本放在前面，可以看到是PCL1.13.0版本，如果想安装其他版本就点“+30 releases”去找自己想安的版本，因为我之前安装的是PCL1.12.1，所以我还是以该版本为例来写。\n\n\n点开相应版本下的“Assets”，就能看到具体提供的安装资源，其中的AllInOne安装包就是官方提供的编译好的第三方库及PCL文件。\n\n\n之后点击安装即可，这里提点安装时的个人小建议，一是选择添加环境变量到PATH，能为后面配环境变量省一点事儿\n\n\n然后是选择安装路径的时候，官方自动给的路径中“PCL 1.12.1”里面有个空格，为了方便后续编译PCL时的方便，建议把这个空格去掉，或是换成下划线之类的，总之路径里最后不要有空格，中文最好也别有（这个没试过，可能没事）\n\n\n重要！！！后来我发现相比下划线”PCL_1.12.1”，用横杠更好看”PCL-1.12.1”，仅供参考。等之后找个空把我要把这些路径名都改过来。\n然后在安装过程中如果之前没有安装过OpenNI2，会弹出窗口问是否安装OpenNI2，点击安装即可。\n\n\n 比较坑的是，这个OpenNI2一般不会老老实实按照我们PCL安装路径安装，而是安装在C盘。不过也不用在意，等PCL安装程序全部安装完成后，找到安装目录\\PCL_1.12.1\\3rdParty，该目录下就是PCL官方为我们打包好的，编译好的第三方库\n\n\n打开其中的OpenNI2目录，如果里面是空的，只有一个OpenNI-Windows-x64-2.2.msi文件，那恭喜，这东西成功安到C盘去了。。。\n\n\n但不用担心，这个msi文件就是OpenNI2的安装文件，我们可以通过它，把安在C盘的OpenNI2卸载\n\n\n然后再通过这个msi把它安装回来，主要是因为通过这个msi文件来安装的时候，它会让你选安装路径，我们就把安到\\PCL_1.12.1\\3rdParty\\OpenNI2路径，这样就让PCL的第三库整整齐齐在一起了。\n\n\n现在再看OpenNI2的文件夹，这就正常了。\n\n\n当然，不介意OpenNI2安在C盘，与其他第三方库天各一方的话，就不用把它卸了又装。\n现在打开系统环境变量来看一下，因为我们之前选择了添加PCL环境变量到PATH，所以这里已经自动帮我们配好了一部分。\n在系统变量里帮我们配好了OPENNI2的三个相关变量（外：PCL_ROOT,OpenNI2三项；Path内：PCL/bin，VTK/bin）\n\n\n在Path里帮我们配好了最基本的PCL和VTK的bin路径\n\n\n除了他帮我们配好的这一部分，我们还需要把其他第三方库跟dll有关的路径添加上\n%PCL_ROOT%\\3rdParty\\FLANN\\bin%PCL_ROOT%\\3rdParty\\Qhull\\bin%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n另外因为他给我们配好PCL_ROOT了，可以直接拿来用\n\n\n一开始我以为我没用到上面的模块，这些环境变量没必要加，结果不加它们在运行的时候报了缺少OpenNI2.dll的错误，所以我估计虽然没有直接使用这些第三方库，但PCL毕竟是依赖它们编译出来的，在运行时估计还是需要用到这些东西，所以还是把上面这些都加到环境变量里吧。\n对了，既然说到这了，提供一种程序运行时出现缺少xxx.dll文件时的解决思路\n\n\n这种一般就是程序调试的时候找不到相关的dll导致的（废话。。。），所以我们首先要找到这个dll的位置，还是通过之前的软件“everything”，查找到这个dll所在位置\n\n\n之后有两种办法 ，一是直接将这个dll文件复制到程序运行目录下，二是将这个dll文件所在的路径添加到环境变量Path中，然后在VS的调试属性中告诉它去哪里找这些dll文件。上面这么多路径，选一个加到环境变量里即可。\n\n\n在这个例子里，通过网上的参考，只要把下面两个路径加到环境变量里，应该就包含OpenNI2所需的所有dll文件了。\n%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n而在不知道哪个路径里包含程序运行所需的所有dll文件的情况下，就只能是缺一个，找个一路径加一下这样。。。当然，因为你加的路径里包含多个dll文件，在有多个dll路径可选的时候，是有可能你选的那个路径，就是包含你当前程序运行所需的所有dll文件的路径。提这个就是想说，选哪个路径加到环境变量里的时候，还是可以稍微思考一下的，哎嘿。\n题外话，不过让我纳闷的是，上面配置的所有PCL相关环境时，里面没有Boost相关的环境变量，甚至我程序中都显式地使用了Boost相关的代码，它也没报过缺少dll文件的错。而且其实在第三方库Boost的安装路径\\PCL_1.12.1\\3rdParty\\Boost里，可以看到是没有bin文件夹的，找了找也没有像OpenNI2那样把dll分散到别的文件夹里，Boost好像就是没有dll文件。看样Boost在使用时跟别人都不一样，不需要这个dll文件就能用。这一段是见识短的我的一点小感慨，等我见识长了，看看能不能有什么新的认识补充。\nVS配置跟之前OCC在VS中的配置类似，主要三个部分。让程序能找到bin里的dll文件，找到inc里的.h头文件，找到lib里的lib库函数。\n如何让程序能找到bin里的dll文件在上面已经给出了，就是在属性页的 “调试–&gt;环境” 里添加PATH=%PATH%，不过感觉不加好像也行，一般程序创建的时候都带着。\n让程序能找到头文件，添加PCL所有关联的头文件目录。找到 属性页 -&gt; “C/C++” -&gt; “常规”-&gt;”附加包含目录”，把这些头文件路径添加进去即可。\n\n\nE:\\PCL_1.12.1\\include\\pcl-1.12E:\\PCL_1.12.1\\3rdParty\\Boost\\include\\boost-1_78E:\\PCL_1.12.1\\3rdParty\\Eigen\\eigen3E:\\PCL_1.12.1\\3rdParty\\FLANN\\includeE:\\PCL_1.12.1\\3rdParty\\OpenNI2\\IncludeE:\\PCL_1.12.1\\3rdParty\\Qhull\\includeE:\\PCL_1.12.1\\3rdParty\\VTK\\include\\vtk-9.1\n\n让程序能找到lib文件，找到属性页-&gt;”链接器”-&gt;”常规”-&gt;”附加库目录”，添加lib库位置。\n\n\nE:\\PCL_1.12.1\\libE:\\PCL_1.12.1\\3rdParty\\Boost\\libE:\\PCL_1.12.1\\3rdParty\\FLANN\\libE:\\PCL_1.12.1\\3rdParty\\OpenNI2\\LibE:\\PCL_1.12.1\\3rdParty\\Qhull\\libE:\\PCL_1.12.1\\3rdParty\\VTK\\lib\n\n然后还是在链接器部分，找到“输入”-&gt;”附加依赖项”，把上面所有lib库路径下的lib文件名引入到附加依赖项里\n\n\n之前配OCC的时候提过了，在每个lib文件夹下，shift+右键，选择打开Powershell窗口，然后通过命令行ls *.lib -n来获取各个文件夹下的所有lib文件名即可。这里直接给出该PCL版本下所以的lib文件\npcl_commond.libpcl_featuresd.libpcl_filtersd.libpcl_iod.libpcl_io_plyd.libpcl_kdtreed.libpcl_keypointsd.libpcl_mld.libpcl_octreed.libpcl_outofcored.libpcl_peopled.libpcl_recognitiond.libpcl_registrationd.libpcl_sample_consensusd.libpcl_searchd.libpcl_segmentationd.libpcl_stereod.libpcl_surfaced.libpcl_trackingd.libpcl_visualizationd.liblibboost_atomic-vc142-mt-gd-x64-1_78.liblibboost_bzip2-vc142-mt-gd-x64-1_78.liblibboost_chrono-vc142-mt-gd-x64-1_78.liblibboost_container-vc142-mt-gd-x64-1_78.liblibboost_context-vc142-mt-gd-x64-1_78.liblibboost_contract-vc142-mt-gd-x64-1_78.liblibboost_coroutine-vc142-mt-gd-x64-1_78.liblibboost_date_time-vc142-mt-gd-x64-1_78.liblibboost_exception-vc142-mt-gd-x64-1_78.liblibboost_filesystem-vc142-mt-gd-x64-1_78.liblibboost_graph-vc142-mt-gd-x64-1_78.liblibboost_graph_parallel-vc142-mt-gd-x64-1_78.liblibboost_iostreams-vc142-mt-gd-x64-1_78.liblibboost_json-vc142-mt-gd-x64-1_78.liblibboost_locale-vc142-mt-gd-x64-1_78.liblibboost_log-vc142-mt-gd-x64-1_78.liblibboost_log_setup-vc142-mt-gd-x64-1_78.liblibboost_math_c99-vc142-mt-gd-x64-1_78.liblibboost_math_c99f-vc142-mt-gd-x64-1_78.liblibboost_math_c99l-vc142-mt-gd-x64-1_78.liblibboost_math_tr1-vc142-mt-gd-x64-1_78.liblibboost_math_tr1f-vc142-mt-gd-x64-1_78.liblibboost_math_tr1l-vc142-mt-gd-x64-1_78.liblibboost_mpi-vc142-mt-gd-x64-1_78.liblibboost_nowide-vc142-mt-gd-x64-1_78.liblibboost_numpy38-vc142-mt-gd-x64-1_78.liblibboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_program_options-vc142-mt-gd-x64-1_78.liblibboost_python38-vc142-mt-gd-x64-1_78.liblibboost_random-vc142-mt-gd-x64-1_78.liblibboost_regex-vc142-mt-gd-x64-1_78.liblibboost_serialization-vc142-mt-gd-x64-1_78.liblibboost_system-vc142-mt-gd-x64-1_78.liblibboost_test_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_thread-vc142-mt-gd-x64-1_78.liblibboost_timer-vc142-mt-gd-x64-1_78.liblibboost_type_erasure-vc142-mt-gd-x64-1_78.liblibboost_unit_test_framework-vc142-mt-gd-x64-1_78.liblibboost_wave-vc142-mt-gd-x64-1_78.liblibboost_wserialization-vc142-mt-gd-x64-1_78.liblibboost_zlib-vc142-mt-gd-x64-1_78.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.libOpenNI2.libqhullcpp_d.libqhullstatic_d.libqhullstatic_rd.libqhull_rd.libvtkcgns-9.1.libvtkcgns-9.1d.libvtkChartsCore-9.1.libvtkChartsCore-9.1d.libvtkCommonColor-9.1.libvtkCommonColor-9.1d.libvtkCommonComputationalGeometry-9.1.libvtkCommonComputationalGeometry-9.1d.libvtkCommonCore-9.1.libvtkCommonCore-9.1d.libvtkCommonDataModel-9.1.libvtkCommonDataModel-9.1d.libvtkCommonExecutionModel-9.1.libvtkCommonExecutionModel-9.1d.libvtkCommonMath-9.1.libvtkCommonMath-9.1d.libvtkCommonMisc-9.1.libvtkCommonMisc-9.1d.libvtkCommonSystem-9.1.libvtkCommonSystem-9.1d.libvtkCommonTransforms-9.1.libvtkCommonTransforms-9.1d.libvtkDICOMParser-9.1.libvtkDICOMParser-9.1d.libvtkDomainsChemistry-9.1.libvtkDomainsChemistry-9.1d.libvtkDomainsChemistryOpenGL2-9.1.libvtkDomainsChemistryOpenGL2-9.1d.libvtkdoubleconversion-9.1.libvtkdoubleconversion-9.1d.libvtkexodusII-9.1.libvtkexodusII-9.1d.libvtkexpat-9.1.libvtkexpat-9.1d.libvtkFiltersAMR-9.1.libvtkFiltersAMR-9.1d.libvtkFiltersCore-9.1.libvtkFiltersCore-9.1d.libvtkFiltersExtraction-9.1.libvtkFiltersExtraction-9.1d.libvtkFiltersFlowPaths-9.1.libvtkFiltersFlowPaths-9.1d.libvtkFiltersGeneral-9.1.libvtkFiltersGeneral-9.1d.libvtkFiltersGeneric-9.1.libvtkFiltersGeneric-9.1d.libvtkFiltersGeometry-9.1.libvtkFiltersGeometry-9.1d.libvtkFiltersHybrid-9.1.libvtkFiltersHybrid-9.1d.libvtkFiltersHyperTree-9.1.libvtkFiltersHyperTree-9.1d.libvtkFiltersImaging-9.1.libvtkFiltersImaging-9.1d.libvtkFiltersModeling-9.1.libvtkFiltersModeling-9.1d.libvtkFiltersParallel-9.1.libvtkFiltersParallel-9.1d.libvtkFiltersParallelImaging-9.1.libvtkFiltersParallelImaging-9.1d.libvtkFiltersPoints-9.1.libvtkFiltersPoints-9.1d.libvtkFiltersProgrammable-9.1.libvtkFiltersProgrammable-9.1d.libvtkFiltersSelection-9.1.libvtkFiltersSelection-9.1d.libvtkFiltersSMP-9.1.libvtkFiltersSMP-9.1d.libvtkFiltersSources-9.1.libvtkFiltersSources-9.1d.libvtkFiltersStatistics-9.1.libvtkFiltersStatistics-9.1d.libvtkFiltersTexture-9.1.libvtkFiltersTexture-9.1d.libvtkFiltersTopology-9.1.libvtkFiltersTopology-9.1d.libvtkFiltersVerdict-9.1.libvtkFiltersVerdict-9.1d.libvtkfmt-9.1.libvtkfmt-9.1d.libvtkfreetype-9.1.libvtkfreetype-9.1d.libvtkGeovisCore-9.1.libvtkGeovisCore-9.1d.libvtkgl2ps-9.1.libvtkgl2ps-9.1d.libvtkglew-9.1.libvtkglew-9.1d.libvtkhdf5-9.1.libvtkhdf5-9.1d.libvtkhdf5_hl-9.1.libvtkhdf5_hl-9.1d.libvtkImagingColor-9.1.libvtkImagingColor-9.1d.libvtkImagingCore-9.1.libvtkImagingCore-9.1d.libvtkImagingFourier-9.1.libvtkImagingFourier-9.1d.libvtkImagingGeneral-9.1.libvtkImagingGeneral-9.1d.libvtkImagingHybrid-9.1.libvtkImagingHybrid-9.1d.libvtkImagingMath-9.1.libvtkImagingMath-9.1d.libvtkImagingMorphological-9.1.libvtkImagingMorphological-9.1d.libvtkImagingSources-9.1.libvtkImagingSources-9.1d.libvtkImagingStatistics-9.1.libvtkImagingStatistics-9.1d.libvtkImagingStencil-9.1.libvtkImagingStencil-9.1d.libvtkInfovisCore-9.1.libvtkInfovisCore-9.1d.libvtkInfovisLayout-9.1.libvtkInfovisLayout-9.1d.libvtkInteractionImage-9.1.libvtkInteractionImage-9.1d.libvtkInteractionStyle-9.1.libvtkInteractionStyle-9.1d.libvtkInteractionWidgets-9.1.libvtkInteractionWidgets-9.1d.libvtkIOAMR-9.1.libvtkIOAMR-9.1d.libvtkIOAsynchronous-9.1.libvtkIOAsynchronous-9.1d.libvtkIOCGNSReader-9.1.libvtkIOCGNSReader-9.1d.libvtkIOChemistry-9.1.libvtkIOChemistry-9.1d.libvtkIOCityGML-9.1.libvtkIOCityGML-9.1d.libvtkIOCONVERGECFD-9.1.libvtkIOCONVERGECFD-9.1d.libvtkIOCore-9.1.libvtkIOCore-9.1d.libvtkIOEnSight-9.1.libvtkIOEnSight-9.1d.libvtkIOExodus-9.1.libvtkIOExodus-9.1d.libvtkIOExport-9.1.libvtkIOExport-9.1d.libvtkIOExportGL2PS-9.1.libvtkIOExportGL2PS-9.1d.libvtkIOExportPDF-9.1.libvtkIOExportPDF-9.1d.libvtkIOGeometry-9.1.libvtkIOGeometry-9.1d.libvtkIOHDF-9.1.libvtkIOHDF-9.1d.libvtkIOImage-9.1.libvtkIOImage-9.1d.libvtkIOImport-9.1.libvtkIOImport-9.1d.libvtkIOInfovis-9.1.libvtkIOInfovis-9.1d.libvtkIOIOSS-9.1.libvtkIOIOSS-9.1d.libvtkIOLegacy-9.1.libvtkIOLegacy-9.1d.libvtkIOLSDyna-9.1.libvtkIOLSDyna-9.1d.libvtkIOMINC-9.1.libvtkIOMINC-9.1d.libvtkIOMotionFX-9.1.libvtkIOMotionFX-9.1d.libvtkIOMovie-9.1.libvtkIOMovie-9.1d.libvtkIONetCDF-9.1.libvtkIONetCDF-9.1d.libvtkIOOggTheora-9.1.libvtkIOOggTheora-9.1d.libvtkIOParallel-9.1.libvtkIOParallel-9.1d.libvtkIOParallelXML-9.1.libvtkIOParallelXML-9.1d.libvtkIOPLY-9.1.libvtkIOPLY-9.1d.libvtkIOSegY-9.1.libvtkIOSegY-9.1d.libvtkIOSQL-9.1.libvtkIOSQL-9.1d.libvtkioss-9.1.libvtkioss-9.1d.libvtkIOTecplotTable-9.1.libvtkIOTecplotTable-9.1d.libvtkIOVeraOut-9.1.libvtkIOVeraOut-9.1d.libvtkIOVideo-9.1.libvtkIOVideo-9.1d.libvtkIOXML-9.1.libvtkIOXML-9.1d.libvtkIOXMLParser-9.1.libvtkIOXMLParser-9.1d.libvtkjpeg-9.1.libvtkjpeg-9.1d.libvtkjsoncpp-9.1.libvtkjsoncpp-9.1d.libvtkkissfft-9.1.libvtkkissfft-9.1d.libvtklibharu-9.1.libvtklibharu-9.1d.libvtklibproj-9.1.libvtklibproj-9.1d.libvtklibxml2-9.1.libvtklibxml2-9.1d.libvtkloguru-9.1.libvtkloguru-9.1d.libvtklz4-9.1.libvtklz4-9.1d.libvtklzma-9.1.libvtklzma-9.1d.libvtkmetaio-9.1.libvtkmetaio-9.1d.libvtknetcdf-9.1.libvtknetcdf-9.1d.libvtkogg-9.1.libvtkogg-9.1d.libvtkParallelCore-9.1.libvtkParallelCore-9.1d.libvtkParallelDIY-9.1.libvtkParallelDIY-9.1d.libvtkpng-9.1.libvtkpng-9.1d.libvtkpugixml-9.1.libvtkpugixml-9.1d.libvtkRenderingAnnotation-9.1.libvtkRenderingAnnotation-9.1d.libvtkRenderingContext2D-9.1.libvtkRenderingContext2D-9.1d.libvtkRenderingContextOpenGL2-9.1.libvtkRenderingContextOpenGL2-9.1d.libvtkRenderingCore-9.1.libvtkRenderingCore-9.1d.libvtkRenderingFreeType-9.1.libvtkRenderingFreeType-9.1d.libvtkRenderingGL2PSOpenGL2-9.1.libvtkRenderingGL2PSOpenGL2-9.1d.libvtkRenderingImage-9.1.libvtkRenderingImage-9.1d.libvtkRenderingLabel-9.1.libvtkRenderingLabel-9.1d.libvtkRenderingLOD-9.1.libvtkRenderingLOD-9.1d.libvtkRenderingOpenGL2-9.1.libvtkRenderingOpenGL2-9.1d.libvtkRenderingSceneGraph-9.1.libvtkRenderingSceneGraph-9.1d.libvtkRenderingUI-9.1.libvtkRenderingUI-9.1d.libvtkRenderingVolume-9.1.libvtkRenderingVolume-9.1d.libvtkRenderingVolumeOpenGL2-9.1.libvtkRenderingVolumeOpenGL2-9.1d.libvtkRenderingVtkJS-9.1.libvtkRenderingVtkJS-9.1d.libvtksqlite-9.1.libvtksqlite-9.1d.libvtksys-9.1.libvtksys-9.1d.libvtkTestingRendering-9.1.libvtkTestingRendering-9.1d.libvtktheora-9.1.libvtktheora-9.1d.libvtktiff-9.1.libvtktiff-9.1d.libvtkverdict-9.1.libvtkverdict-9.1d.libvtkViewsContext2D-9.1.libvtkViewsContext2D-9.1d.libvtkViewsCore-9.1.libvtkViewsCore-9.1d.libvtkViewsInfovis-9.1.libvtkViewsInfovis-9.1d.libvtkWrappingTools-9.1.libvtkWrappingTools-9.1d.libvtkzlib-9.1.libvtkzlib-9.1d.lib\n\n至此，就可以在VS里使用PCL愉快开发了。\nPCL+VS+QT 配置之前VS+PCL显示时用的是boost，但要配合Qt的ui界面来显示的话，需要用到VTK的一个组件QVTKOpenGLNativeWidget。使用这个组件需要重新编译VTK，让它生成配合Qt的相关文件。之后用我们新编译出的VTK文件替换PCL自带的VTK文件，再重新编译一下PCL，让PCL生成的文件好和现在的VTK配合起来。\nVTK编译源码下载去VTK的官网 https://vtk.org/ 下载VTK的源文件。我们注意到PCL自带的VTK版本是9.1的，而官网只提供VTK9.2.6版本的源码了。无需担心，只要VTK的这个大版本一样就行，即都是VTK9的版本即可，别下成下面8.2.0或是7.1.1的版本就行。而且是在要找还是能在GitHub上找到VTK9.1版本的源码的。\n\n\nCMake编译这里正好简单介绍一下使用CMake编译的流程，我们一般会用到3个文件夹，source文件夹用来放之前下载下来的源代码，build文件夹用来放CMake生成的文件，install文件夹用来放最后编译生成的文件。\n这里我创建了一个VTK9.2.6文件夹，并在里面创建了上述三个文件夹，source、build、install\n\n\n之后把之前下载的源代码解压到了source文件夹下\n\n\n打开CMake的GUI界面，给出源文件路径和build路径，之后点configure\n\n\n编译器就用他检测到的我们现在的编译器版本VS2022，下面平台版本选一下x64\n\n\n第一次configure之后可以看到界面是红色的，表示这些选项我们还未确认过，这里有几项我们需要进行修改\n\n\n修改后结果如下。这个install的路径改成我们之前建的install文件夹，不然一会编译的时候生成的源码都跑到上面C盘的路径下了。然后就是把VTK配合Qt和Views的选项改为yes，之后编译才会生成与Qt配合相关的文件。确认好了之后再点一下Configure\n\n\n再次Configure会根据之前的选择而产生新的选项让我们确认，而之前的选项在我们点Configure的时候他就当我们确认好了，就变成白色了，当然变成白色的这些选项还是可以改的。在新出现的这些选项中，我们需要给他选定需要配合的Qt版本，以及对应的Qt文件夹路径。\n\n\n其中Qt的版本根据自己要用的Qt版本来选，我用Qt6所以版本这里自然选6，然后再告诉它Qt6文件夹的路径。Qt5我不用所以不用管，如果用Qt5的话，照着这个Qt6的路径去找就行。\nE:\\QT6\\6.4.3\\msvc2019_64\\lib\\cmake\\Qt6\n\n\n\n之后再点Configure，他就会根据之前提供的Qt6文件所在路径把Qt6一系列组件之类的文件路径自动填好了，大体看看，没事直接再点Configure就行\n\n\n这次Configure完之后所有的选项都是白色，代表没有新增选项需要确认了，也就是Configure部分结束了，现在可以点Generate了\n\n\nGenerate完之后直接点旁边的Open Project打开VS编译器\n\n\n在VS编译器解决方案处，找到ALL_BUILD，右键生成。\n\n\n等ALL_BUILD都生成完之后，往下找到INSTALL，右键生成。\n\n\n生成完之后，就能在install文件夹找到我们需要的编译后的文件\n\n\nPCL源码编译VTK编译好后就可以开始PCL源码的编译，我们用上面编译好的VTK文件替换掉PCL自带的VTK文件\n\n\n至于其他的第三方库文件，我们就用它自带的就行\nPCL原来自带的编译后的文件可以直接删掉就行\n\n\n然后就在这新建source、build、install三个文件夹，开始CMake。当然这只是我个人的喜好，完全可以在别的地方编译生成PCL源码，到时候把前面配的环境变量根据自己编译生成的代码的位置改好对应起来就行。\n\n\n跟之前一样，先去下载PCL源码解压到source中\n找到之前PCL官方的GitHub https://github.com/PointCloudLibrary/pcl ，找到master-&gt;Tags-&gt;pcl1.12.1，这里的pcl版本对应你要编译的pcl版本。\n\n\n选择之后界面提供的就是对应版本的pcl源码，点击下载即可。\n\n\n源码解压好之后先别急，先在解压后的文件的cmake目录里找到“pcl_find_boost.cmake”这个文件。\n\n\n编辑该文件，给出Boost的lib和include文件夹所在位置\n\n\n#增加下面两行代码set(Boost_LIBRARY_DIR E:/PCL_1.12.1/3rdParty/Boost/lib)set(Boost_INCLUDE_DIR E:/PCL_1.12.1/3rdParty/Boost/include/boost-1_78)\n\n之后就跟之前VTK的编译过程一样了，打开CMake的GUI界面，配置好source和build位置，然后Configure\n第一次编译还是先改install的位置，然后发现说EIGEN的路径没找到，所以我们也给它配置一下，再点Configure\n\n\n配置FLANN文件位置\n\n\nOPENNI2的路径他自己找到了给我省事了，Qt6文件夹路径还是没找到，我就自己给他配一下\n\n\n再确认一下VTK的路径，WITH_QT的版本\n\n\n然后选择PCL要生成的模块，这个新电脑没有GPU我就先没选GPU模块，选择all_in_one_installer就会生成一个官方那种的安装包，会根据我们的配置进行打包，之后还要在其他地方用这套配置直接用我们自己生成的all_in_one_installer安装即可。有些模块没选，到时候有需要的话可以再CMake，然后把需要的模块选上，然后在VS生成就行，不需要再配之前的路径了，因为上面那些选择已经记录在build文件中的cmake文件里了。\n\n\n之后就是一路Configure，直到所有选项全白了，之后再Generate，然后Open Project打开VS，找到解决方案中的CMakePredefinedTargets，右键ALL_BUILD生成。\n\n\n生成完再右键INSTALL生成。\n\n\n搞定后就可以看到install中已经得到我们所需的编译好的文件。\n\n\n这里要反思一下，之前CMake编译的时候，之所以找不到Eigen、FLANN，需要我手动添加，原因在于我在新电脑上配置的时候没有把这两个的路径加到环境变量里，你像OPENNI2因为它安装的时候自动配好了环境变量，所以CMake能直接找到，Qt6也是因为没有在环境变量里配置所以总是找不到，需要我手动配置。\n然后因为我编译好的PCL源码路径发生了改变，所以环境变量的路径，在VS中配置的路径，也要稍微改一下。当然，你可以直接把这些新编译好的文件就放在之前VS配置的那个路径里，这样就不用变了。不过还有VTK的路径，之前自带的VTK文件夹名字里是9.1，现在变成9.2了也要改一下。\n环境变量\n\n\n头文件位置\n\n\n\n\nlib库位置\n\n\n还有新编译生成的lib文件名也都是从之前的9.1变成9.2了，也要重新导入一下，把vtk9.1的lib都换成vtk9.2的lib。\n\n\npcl_commond.libpcl_featuresd.libpcl_filtersd.libpcl_iod.libpcl_io_plyd.libpcl_kdtreed.libpcl_keypointsd.libpcl_mld.libpcl_octreed.libpcl_outofcored.libpcl_peopled.libpcl_recognitiond.libpcl_registrationd.libpcl_sample_consensusd.libpcl_searchd.libpcl_segmentationd.libpcl_stereod.libpcl_surfaced.libpcl_trackingd.libpcl_visualizationd.liblibboost_atomic-vc142-mt-gd-x64-1_78.liblibboost_bzip2-vc142-mt-gd-x64-1_78.liblibboost_chrono-vc142-mt-gd-x64-1_78.liblibboost_container-vc142-mt-gd-x64-1_78.liblibboost_context-vc142-mt-gd-x64-1_78.liblibboost_contract-vc142-mt-gd-x64-1_78.liblibboost_coroutine-vc142-mt-gd-x64-1_78.liblibboost_date_time-vc142-mt-gd-x64-1_78.liblibboost_exception-vc142-mt-gd-x64-1_78.liblibboost_filesystem-vc142-mt-gd-x64-1_78.liblibboost_graph-vc142-mt-gd-x64-1_78.liblibboost_graph_parallel-vc142-mt-gd-x64-1_78.liblibboost_iostreams-vc142-mt-gd-x64-1_78.liblibboost_json-vc142-mt-gd-x64-1_78.liblibboost_locale-vc142-mt-gd-x64-1_78.liblibboost_log-vc142-mt-gd-x64-1_78.liblibboost_log_setup-vc142-mt-gd-x64-1_78.liblibboost_math_c99-vc142-mt-gd-x64-1_78.liblibboost_math_c99f-vc142-mt-gd-x64-1_78.liblibboost_math_c99l-vc142-mt-gd-x64-1_78.liblibboost_math_tr1-vc142-mt-gd-x64-1_78.liblibboost_math_tr1f-vc142-mt-gd-x64-1_78.liblibboost_math_tr1l-vc142-mt-gd-x64-1_78.liblibboost_mpi-vc142-mt-gd-x64-1_78.liblibboost_nowide-vc142-mt-gd-x64-1_78.liblibboost_numpy38-vc142-mt-gd-x64-1_78.liblibboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_program_options-vc142-mt-gd-x64-1_78.liblibboost_python38-vc142-mt-gd-x64-1_78.liblibboost_random-vc142-mt-gd-x64-1_78.liblibboost_regex-vc142-mt-gd-x64-1_78.liblibboost_serialization-vc142-mt-gd-x64-1_78.liblibboost_system-vc142-mt-gd-x64-1_78.liblibboost_test_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_thread-vc142-mt-gd-x64-1_78.liblibboost_timer-vc142-mt-gd-x64-1_78.liblibboost_type_erasure-vc142-mt-gd-x64-1_78.liblibboost_unit_test_framework-vc142-mt-gd-x64-1_78.liblibboost_wave-vc142-mt-gd-x64-1_78.liblibboost_wserialization-vc142-mt-gd-x64-1_78.liblibboost_zlib-vc142-mt-gd-x64-1_78.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.libOpenNI2.libqhullcpp_d.libqhullstatic_d.libqhullstatic_rd.libqhull_rd.libvtkcgns-9.2d.libvtkChartsCore-9.2d.libvtkCommonColor-9.2d.libvtkCommonComputationalGeometry-9.2d.libvtkCommonCore-9.2d.libvtkCommonDataModel-9.2d.libvtkCommonExecutionModel-9.2d.libvtkCommonMath-9.2d.libvtkCommonMisc-9.2d.libvtkCommonSystem-9.2d.libvtkCommonTransforms-9.2d.libvtkDICOMParser-9.2d.libvtkDomainsChemistry-9.2d.libvtkDomainsChemistryOpenGL2-9.2d.libvtkdoubleconversion-9.2d.libvtkexodusII-9.2d.libvtkexpat-9.2d.libvtkFiltersAMR-9.2d.libvtkFiltersCore-9.2d.libvtkFiltersExtraction-9.2d.libvtkFiltersFlowPaths-9.2d.libvtkFiltersGeneral-9.2d.libvtkFiltersGeneric-9.2d.libvtkFiltersGeometry-9.2d.libvtkFiltersHybrid-9.2d.libvtkFiltersHyperTree-9.2d.libvtkFiltersImaging-9.2d.libvtkFiltersModeling-9.2d.libvtkFiltersParallel-9.2d.libvtkFiltersParallelImaging-9.2d.libvtkFiltersPoints-9.2d.libvtkFiltersProgrammable-9.2d.libvtkFiltersSelection-9.2d.libvtkFiltersSMP-9.2d.libvtkFiltersSources-9.2d.libvtkFiltersStatistics-9.2d.libvtkFiltersTexture-9.2d.libvtkFiltersTopology-9.2d.libvtkFiltersVerdict-9.2d.libvtkfmt-9.2d.libvtkfreetype-9.2d.libvtkGeovisCore-9.2d.libvtkgl2ps-9.2d.libvtkglew-9.2d.libvtkGUISupportQt-9.2d.libvtkGUISupportQtQuick-9.2d.libvtkGUISupportQtSQL-9.2d.libvtkhdf5-9.2d.libvtkhdf5_hl-9.2d.libvtkImagingColor-9.2d.libvtkImagingCore-9.2d.libvtkImagingFourier-9.2d.libvtkImagingGeneral-9.2d.libvtkImagingHybrid-9.2d.libvtkImagingMath-9.2d.libvtkImagingMorphological-9.2d.libvtkImagingSources-9.2d.libvtkImagingStatistics-9.2d.libvtkImagingStencil-9.2d.libvtkInfovisCore-9.2d.libvtkInfovisLayout-9.2d.libvtkInteractionImage-9.2d.libvtkInteractionStyle-9.2d.libvtkInteractionWidgets-9.2d.libvtkIOAMR-9.2d.libvtkIOAsynchronous-9.2d.libvtkIOCesium3DTiles-9.2d.libvtkIOCGNSReader-9.2d.libvtkIOChemistry-9.2d.libvtkIOCityGML-9.2d.libvtkIOCONVERGECFD-9.2d.libvtkIOCore-9.2d.libvtkIOEnSight-9.2d.libvtkIOExodus-9.2d.libvtkIOExport-9.2d.libvtkIOExportGL2PS-9.2d.libvtkIOExportPDF-9.2d.libvtkIOGeometry-9.2d.libvtkIOHDF-9.2d.libvtkIOImage-9.2d.libvtkIOImport-9.2d.libvtkIOInfovis-9.2d.libvtkIOIOSS-9.2d.libvtkIOLegacy-9.2d.libvtkIOLSDyna-9.2d.libvtkIOMINC-9.2d.libvtkIOMotionFX-9.2d.libvtkIOMovie-9.2d.libvtkIONetCDF-9.2d.libvtkIOOggTheora-9.2d.libvtkIOParallel-9.2d.libvtkIOParallelXML-9.2d.libvtkIOPLY-9.2d.libvtkIOSegY-9.2d.libvtkIOSQL-9.2d.libvtkioss-9.2d.libvtkIOTecplotTable-9.2d.libvtkIOVeraOut-9.2d.libvtkIOVideo-9.2d.libvtkIOXML-9.2d.libvtkIOXMLParser-9.2d.libvtkjpeg-9.2d.libvtkjsoncpp-9.2d.libvtkkissfft-9.2d.libvtklibharu-9.2d.libvtklibproj-9.2d.libvtklibxml2-9.2d.libvtkloguru-9.2d.libvtklz4-9.2d.libvtklzma-9.2d.libvtkmetaio-9.2d.libvtknetcdf-9.2d.libvtkogg-9.2d.libvtkParallelCore-9.2d.libvtkParallelDIY-9.2d.libvtkpng-9.2d.libvtkpugixml-9.2d.libvtkRenderingAnnotation-9.2d.libvtkRenderingContext2D-9.2d.libvtkRenderingContextOpenGL2-9.2d.libvtkRenderingCore-9.2d.libvtkRenderingFreeType-9.2d.libvtkRenderingGL2PSOpenGL2-9.2d.libvtkRenderingHyperTreeGrid-9.2d.libvtkRenderingImage-9.2d.libvtkRenderingLabel-9.2d.libvtkRenderingLICOpenGL2-9.2d.libvtkRenderingLOD-9.2d.libvtkRenderingOpenGL2-9.2d.libvtkRenderingQt-9.2d.libvtkRenderingSceneGraph-9.2d.libvtkRenderingUI-9.2d.libvtkRenderingVolume-9.2d.libvtkRenderingVolumeOpenGL2-9.2d.libvtkRenderingVtkJS-9.2d.libvtksqlite-9.2d.libvtksys-9.2d.libvtkTestingRendering-9.2d.libvtktheora-9.2d.libvtktiff-9.2d.libvtkverdict-9.2d.libvtkViewsContext2D-9.2d.libvtkViewsCore-9.2d.libvtkViewsInfovis-9.2d.libvtkViewsQt-9.2d.libvtkWrappingTools-9.2d.libvtkzlib-9.2d.lib\n\n至此，PCL+VS+QT的配置告一段落，可以通过VTK在QT的ui界面显示PCL点云数据了\n多提一嘴，QVTKOpenGLNativeWidget继承自Qt的QOpenGLWidget，所以用的时候记得Qt组件里选上Qt OpenGLWidget\n\n\n后记这些编译好的文件可以直接拿去用，换电脑的时候也不用重新编译一遍，只需要从旧电脑把这些编译好的文件拷过去，配好路径就行了。这样搞害怕路径什么的有问题的话，最保险的办法就是之前说的，编译PCL的时候选上all_in_one_installer，然后用这个生成的安装器，去新电脑上安一下就行。\n","categories":["教程"],"tags":["PCL"]},{"title":"更改PyCharm缓存路径","url":"/2023/03/15/PyCharm-Cache/","content":"越来越小的C盘最近C盘的空间越来越小了，于是便又开始找找有没有什么能删的垃圾文件。\n推荐一个软件“SpaceSniffer”，它可以扫描分析每个盘里面各个文件所占的大小，我用他扫描了一下我的C盘结果看到用户目录下的PyCharm文件夹里有个文件“content.dat.storage.data”有4.4个G的大小。\n\n\n网上一查是PyCharm的缓存文件，补充一下，该文件存放在Caches文件夹里，Cache一般就是指缓存文件夹，用来存缓存文件的，当时没反应过来，不过就算直到Cache放缓存文件可能也还是查一查确认一下放心。\n这个缓存文件可以直接删除。但删除并不能从根源解决问题，因为下次使用PyCharm还是会生成缓存文件，早晚还是会一点一点挤占C盘的位置，所以最好的办法就是给PyCharm换一个缓存路径。\n更换PyCharm缓存路径找到PyCharm的安装目录下的bin文件夹，如E:\\PyCharm Community Edition 2022.3.2\\bin，找到其中的idea.properties文件\n\n\n打开该文件，修改其中的四处位置，推荐用“NotePad++”打开。当然，记事本，VS Code之类的都可以。\n\n\n上面红框就是我们要修改的部分，它注释掉的语句应该是它本来默认的存放路径，不过可能因为注释掉了，所以其实并没有存在这个路径中，但还是在C盘建了别的文件夹来放这些文件。我们将这些路径改为我们想让它存放的路径。我在PyCharm的安装目录下新建了一个”.PyCharmCE2022.3”文件夹，并将这个路径改到了该文件夹下。\n\n修改config路径\n\n# idea.config.path=$&#123;user.home&#125;/.PyCharmCE/configidea.config.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/config\n\n\n修改system路径\n\n# idea.system.path=$&#123;user.home&#125;/.PyCharmCE/systemidea.system.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/system\n\n\n修改plugins路径\n\n# idea.plugins.path=$&#123;idea.config.path&#125;/pluginsidea.plugins.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/plugins\n\n\n修改log路径\n\n# idea.log.path=$&#123;idea.system.path&#125;/logidea.log.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/log\n\n之后重启PyCharm，它会自动检测之前的配置所在位置，并提示导入之前的配置\n\n\n点击ok就行了，然后就可以把之前C盘里的都删掉了。\n不过因为前面提到的，它配置文件里那四个部分都默认是注释掉的，所以它实际存放的位置是在C盘别的位置，我的位置是在：\nC:\\Users\\REINHARDT\\AppData\\Local\\JetBrains\\PyCharmCE2022.3C:\\Users\\REINHARDT\\AppData\\Roaming\\JetBrains\\PyCharmCE2022.3\n\n不过删完那个4.4G的缓存文件之后我看这两占内存也不是很大我就没删，以防之后发现上面的配置方法有问题，我好回来找。不过一般也没问题，咬咬牙删了也没事。\n","categories":["C盘减负"],"tags":["PyCharm"]},{"title":"Qt项目的文件结构","url":"/2023/03/16/Qt-Project-Structure/","content":"之前新建Qt项目看它那个代码，总是感觉怪怪的，直到今天在问ChatGPT关于Qt6和OCC7.6的配合时，它给出了一个Qt+OCC的显示模型的例程，看了这个之后我感觉对Qt程序的创建执行才算理解了一点。\n#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QVBoxLayout&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsView&gt;#include &lt;OpenGl_GraphicDriver.hxx&gt;#include &lt;V3d_View.hxx&gt;#include &lt;AIS_InteractiveContext.hxx&gt;#include &lt;BRepPrimAPI_MakeSphere.hxx&gt;int main(int argc, char *argv[])&#123;    // 初始化 Qt 应用程序    QApplication app(argc, argv);    // 创建主窗口    QWidget window;    window.setWindowTitle(&quot;OCC and Qt Integration&quot;);    window.resize(640, 480);    // 创建图形场景和视图    QGraphicsScene scene;    QGraphicsView view(&amp;scene);    view.setViewport(new QOpenGLWidget());  // 使用 OpenGL 视口    // 创建 OCC 视图    Handle(OpenGl_GraphicDriver) aDriver = new OpenGl_GraphicDriver();    Handle(V3d_View) aView = new V3d_View(aDriver);    Handle(AIS_InteractiveContext) aContext = new AIS_InteractiveContext(aView);    aView-&gt;SetContext(aContext);    // 创建 OCC 对象并将其添加到场景中    BRepPrimAPI_MakeSphere aSphere(50);    TopoDS_Shape aShape = aSphere.Shape();    Handle(AIS_Shape) anAisShape = new AIS_Shape(aShape);    aContext-&gt;Display(anAisShape, Standard_True);    aContext-&gt;UpdateCurrentViewer();    // 将 OCC 视图绑定到 Qt 视图中    aView-&gt;SetWindow(view.winId());    aView-&gt;MustBeResized();    view.show();    // 将 Qt 视图添加到主窗口中    QVBoxLayout layout;    layout.addWidget(&amp;view);    window.setLayout(&amp;layout);    window.show();    // 运行 Qt 应用程序    return app.exec();&#125;\n\n重点不在如何显示OCC模型，而在于该程序是标准的从int main（）主函数来构建程序的写法。从中我们可以加深对Qt代码的真实执行过程的理解。\n将上面的代码与下面新建的Qt项目所给出的int main（）比较，可以看到只有寥寥几行代码，当初被下面这几行代码整蒙了，寻思这是干嘛呢，但其实对照上面的代码来分析就比较好读懂了。上面把定义窗口组件的代码直接写在主函数main中，而下面这种其实就是把窗口定义之类的代码写到了类里，这里这个类是OCC_QT，然后OCC_QT w;这句其实是调用了该类的默认构造函数，通过构造函数的执行，来实现了窗口的创建等功能。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n下面来看OCC_QT这个类，先看头文件OCC_QT.h，这里就是类的声明，其中构造函数OCC_QT(QWidget *parent = nullptr);\n#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include &quot;ui_OCC_QT.h&quot;class OCC_QT : public QMainWindow&#123;    Q_OBJECTpublic:    OCC_QT(QWidget *parent = nullptr);    ~OCC_QT();private:    Ui::OCC_QTClass ui;&#125;;\n\n我们可以看到它引入了一个头文件“ui_OCC_QT.h”，这里面就是窗口组件相关的代码\n具体来看“ui_OCC_QT.h”，这里面定义了各种窗口组件的代码，包括页面组件的声明、布局的位置等。\n/********************************************************************************** Form generated from reading UI file &#x27;OCC_QT.ui&#x27;**** Created by: Qt User Interface Compiler version 6.4.0**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_OCC_QT_H#define UI_OCC_QT_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QMainWindow&gt;#include &lt;QtWidgets/QMenuBar&gt;#include &lt;QtWidgets/QStatusBar&gt;#include &lt;QtWidgets/QToolBar&gt;#include &lt;QtWidgets/QWidget&gt;QT_BEGIN_NAMESPACEclass Ui_OCC_QTClass&#123;public:    QMenuBar *menuBar;    QToolBar *mainToolBar;    QWidget *centralWidget;    QStatusBar *statusBar;    void setupUi(QMainWindow *OCC_QTClass)    &#123;        if (OCC_QTClass-&gt;objectName().isEmpty())            OCC_QTClass-&gt;setObjectName(&quot;OCC_QTClass&quot;);        OCC_QTClass-&gt;resize(600, 400);        menuBar = new QMenuBar(OCC_QTClass);        menuBar-&gt;setObjectName(&quot;menuBar&quot;);        OCC_QTClass-&gt;setMenuBar(menuBar);        mainToolBar = new QToolBar(OCC_QTClass);        mainToolBar-&gt;setObjectName(&quot;mainToolBar&quot;);        OCC_QTClass-&gt;addToolBar(mainToolBar);        centralWidget = new QWidget(OCC_QTClass);        centralWidget-&gt;setObjectName(&quot;centralWidget&quot;);        OCC_QTClass-&gt;setCentralWidget(centralWidget);        statusBar = new QStatusBar(OCC_QTClass);        statusBar-&gt;setObjectName(&quot;statusBar&quot;);        OCC_QTClass-&gt;setStatusBar(statusBar);        retranslateUi(OCC_QTClass);        QMetaObject::connectSlotsByName(OCC_QTClass);    &#125; // setupUi    void retranslateUi(QMainWindow *OCC_QTClass)    &#123;        OCC_QTClass-&gt;setWindowTitle(QCoreApplication::translate(&quot;OCC_QTClass&quot;, &quot;OCC_QT&quot;, nullptr));    &#125; // retranslateUi&#125;;namespace Ui &#123;    class OCC_QTClass: public Ui_OCC_QTClass &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_OCC_QT_H\n\n补充一点关于上面部分代码的理解：\nnamespace Ui &#123;    class OCC_QTClass: public Ui_OCC_QTClass &#123;&#125;;&#125; // namespace Ui\n\n这段代码声明了一个命名空间Ui，并在里面定义了一个新的类OCC_QTClass来继承上面具体实现功能的类Ui_OCC_QTClass，然后OCC_QT.h中，声明窗口类的时候：Ui::OCC_QTClass ui;，用的也是这个新建的OCC_QTClass类，至于为什么要这么干，我猜可能是进一步提高代码的封装性，提高项目的安全性。\n最后再来看OCC_QT.cpp，这里面就是OCC_QT类的各种函数功能的具体实现。这里别看这个构造函数就一句话，当时我也懵了一下，寻思这怎么就能把窗口之类的东西都弄出来了？现在懂了，就像上面说的，窗口之类的代码实现实际上都在上面ui_OCC_QT.h里，所以cpp这里的构造函数只需要调用一下setupUi（）函数，把窗口布局的代码运行一下即可。\n#include &quot;OCC_QT.h&quot;OCC_QT::OCC_QT(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);&#125;OCC_QT::~OCC_QT()&#123;&#125;\n\n分析完这个OCC_QT类，再来看主函数的代码就很好理解了，调用OCC_QT的构造函数将窗口组件都定义好了，之后再使用w.show()函数显示在w这个类中声明与定义的窗口即可。其中这个show()函数我们注意到并没有定义在OCC_QT类中，它应该是继承自QMainWindow的方法。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n最后大致总结一下新建的这个Qt项目，它在执行时所做的一些工作：\n定义了UI界面类Ui_OCC_QTClass，写在“ui_OCC_QT.h”中，其中有窗口各种组件的声明和布局定义，与槽函数的连接也默认写在这里面，又定义了一个新的类OCC_QTCLass继承Ui_OCC_QTClass作为访问接口。定义了窗口类OCC_QT，声明部分写在“OCC_QT.h”里，声明了OCC_QTClass类的对象ui，之后的槽函数声明也写在该文件里；定义部分写在“OCC_QT.cpp”里，构造函数调用ui.setup（）函数对窗口组件进行实现，之后的槽函数定义也写在该文件里。\n有了上述这些类的定义，之后就是在主函数中使用，主函数main声明了OCC_QT类的对象w，并调用其构造函数，该构造函数调用OCC_QTClass的实例ui的setup函数，对窗口组件进行声明和定义，即对窗口各组件进行实现。之后再调用OCC_QT的父类QMainWindow继承来的show（）函数将窗口显示出来。\n了解了Qt项目的这些结构之后，我们对Qt项目代码的执行过程就有了基本的了解，就可以更好地编写自己的Qt项目。\n可以就依赖它给出的这种结构来写，也可以按自己想法来写不按它上面的这种结构，步骤对了就行。\n后记：槽函数的声明、定义、与信号的连接等基本步骤见后续的Qt学习笔记，想记录一下两种方式，一种是配合Qt Designer的可视化编程，一种就是纯代码开发的方式。在第一种方式里，想着用上上面说的Qt项目自带的这种文件结果，把OCC_QT.h，OCC_QT.cpp，ui_OCC_QT.h三个文件都用上。在第二中纯代码的方式里，就不要这个ui_OCC_QT.h文件了，毕竟这个文件其实是为了配合Qt Designer可视化编程而存在的，把里面的组件声明、定义等代码都放到外面来。\n","categories":["Qt学习"],"tags":["Qt"]},{"title":"Qt6学习笔记","url":"/2023/04/17/Qt6.4-Note/","content":"随笔clicked()、triggered()、toggled()三个信号的区别toggled()toggle 类似开关。 具有2个状态，打开/关闭。  使用这个信号，是在这2个状态之间切换。checkable按纽或是图标的槽函数应该用toggled()事件来激活\ntriggered()trigger是一次性的。 点击后，无法改变状态。 要么是打开，要么是关闭。一般的按纽（uncheckable）的激活方式即是triggered()。更有触发的意思。这个单词还有另一个意思就是板机\nclicked()和triggered()用法一样，使用场景不同，triggered() 正常情况下应该广泛地多，比如快捷键等\n信号与槽信号 signals信号的创建规则：\n\n信号使用 signals 关键字声明，在其后面有一个冒号“:”，在其前面不能有 public、private、protected 访问控制符，信号默认是 public 的。\n\n\n信号只需像函数那样声明即可，其中可以有参数，参数的主要作用是用于和槽的通信，这就像普通函数的参数传递规则一样。信号虽然像函数，但是对他的调用方式不一样，信号需要使用 emit 关键字发射。\n\n\n信号只需声明，不能对其进行定义，信号是由 moc 自动生成的。\n\n\n信号的返回值只能是 void 类型的。\n\n槽 slots槽的创建规则：\n\n声明槽需要使用 slots 关键字，在其后面有一个冒号“:”，且槽需使用 public、private、protected 访问控制符之一。\n槽就是一个普通的函数，可以像使用普通函数一样进行使用，槽与普通函数的主要区别是，槽可以与信号关联。\n\n发射信号 emit注意这里的”发射信号”指的是一个动作\n发射信号的创建规则：\n\n发射信号需要使用 emit 关键字，注意，在 emit 后面不需要冒号。\n\nemit 发射的信号使用的语法与调用普通函数相同，比如有一个信号为 void f(int)，则发送的语法为：emit f(3); \n\n当信号被发射时，与其相关联的槽函数会被调用(注意：信号和槽需要使用\n\nQObject::connect 函数进行关联之后，发射信号后才会调用相关联的槽函数。\n\n因为信号位于类之中，因此发射信号的位置需要位于该类的成员函数中或该\n\n类能见到信号的标识符的位置。\n\n\n代码示例：//头文件 m.h 的内容class A : public QObject&#123; //信号和槽必须继承自 QObject 类  Q_OBJECT                    //必须添加该宏    //public signals:void s1(int);  //错误 signals 前不能有访问控制符。    signals:void s();//使用 signals 关键字声明信号，信号的语法与声明函数相同。  signals:void s(int,int);//正确，信号可以有参数，也可以重载。    //void s2()&#123;&#125; //错误，信号只需声明，不能定义。    void s3(); //注意：这仍是声明的一个信号public://信号声明结束后，重新使用访问控制符，表示以下声明的是成员函数。  void g()&#123;    emit s3(); //发射信号  &#125;&#125;;class B:public QObject&#123;  Q_OBJECTpublic slots:               //使用 slots 关键字声明槽  void x()&#123;    cout&lt;&lt;&quot;X&quot;&lt;&lt;endl;  &#125;  //slots: void x()&#123;&#125;     //错误，声明槽时需要指定访问控制符。  public:  void g()&#123;     // emit s3();       //错误，在类 B 中对于标识符 s3 是不可见的  &#125;&#125;;//源文件的内容int main(int argc, char *argv[])&#123;  A ma;   B mb;  QObject::connect(&amp;ma,&amp;A::s3,&amp;mb,&amp;B::x); //关联信号和槽  ma.g(); //调用g发送信号  return 0;&#125;\n\n\n\nQt Designer使用菜单栏、工具栏的创建创建新项目时，其实已经帮我们默认创建好菜单栏、工具栏和状态栏了。菜单栏在窗口顶部，可以看到“在这里输入”的提示，那一栏就是菜单栏的位置，其对象名为menuBar，可以在右侧对象检查器中看到，菜单栏只能有一个。工具栏在菜单栏下面紧挨着，初始也帮我们建了一个，对象名为mainToolBar，工具栏可以有多个，想创建的话，在主对象上右键-&gt;创建工具栏即可。状态栏我不知道在哪，不过这东西也只能有一个，且初始帮我们创建了，对象名为statusBar。\n\n\n在主对象上右键-&gt;添加工具栏以添加新的工具栏，状态栏因为已经有了所以这里显示”移除状态栏”，菜单栏也因为已经有了直接不显示，若初始没有菜单栏，这里右键就能看到“创建菜单栏”的选项。\n\n\n在菜单栏的“在这里输入”中输入具体的内容，如option。这时右侧menuBar下会多一栏menuoption，而且点击菜单栏的option，该栏会展开，一开始也是只有“在这里输入”和“添加分隔符”两项内容，在里面输入具体内容之后就相当于给它们创建了实体，如这里我输入了option1和option2，这种就算是具体的动作了，创建这两个的同时，不光右侧对象检查器的menuoption栏下会多两个QAction：actionoption1和actionoption2，动作编辑器中也会多出两项：actionoption1和actionoption2。另外，option1右侧可以看到蓝色的小加号，点击之后可以将option1再展开，通过“在这里输入”输入具体的名称，继续添加具体的项。\n之后将具体的对象与槽函数连接来实现具体功能即可。\n\n","categories":["笔记"],"tags":["Qt"]},{"title":"Qt6.4.2-PCL1.12.1-VTK9.2.6-error","url":"/2023/03/09/Qt6.4-PCL1.12.1-VTK9.2.6-error/","content":"问题描述一开始因为PCL自带一个VTK9.1环境，因为要VTK和Qt配合，去官网下了完整VTK9.2自己编译了一下，然后又在Qt项目里配了一下VTK的环境，估计是他先找到了PCL自带的VTK9.1环境，就没管我自己配的VTK9.2，导致报了个“未定义标识符VTK_UNICODE_STRING”的错\n考虑到两个VTK环境冲突的问题，就把PCL自带的那个VTK9.2的环境配置都删了一遍，结果又出现了下面的问题\n\n\n看到这个dll想到可能是因为环境变量里PCL自带的VTK9,1和自己编译的VTK9.2冲突了，忘记改了，因为程序寻找dll文件是从环境变量PATH中从头到尾在找，当找到一个对应的目录的时候它就认定在这个目录里寻找dll文件了，而不会再往下找了，应该就是因为我把PCL自带的VTK9.1的bin路径放在了自己编译的VTK9.2的bin路径之前导致的问题\n结果一看不对啊，自己编译的VTK9.2的bin路径是在上面的呀，惊了。。。\n然后我又试了试直接把PCL自带的VTK9.1的bin路径删掉，结果程序报错找不到vtk9.1d的dll了，说明程序哪里还用着pcl自带的vtk9.1 。。。\n话说pcl自带的vtk9.1有QVTKOpenGLNativeWidget吗，有的话我直接用PCL自带vtk9.1算了。。。\n去看了一下没有，然后想起来了，这个模块是要编译VTK的时候选一下配合Qt才会生成，乐，还是要用自己配的。。。\n可能是PCL一些东西配合自带的VTK才能实现，明天试试把自己编译的VTK覆盖PCL自带的VTK试一下。。。记得做好备份\n实在不行就得把PCL编译需要的东西都下一遍，然后用CMake从头编译一下来弄了。。。\n第二天继续试，把VTK覆盖试了试好像不行\n然后开始调试，看看是哪个语句的问题，发现是初始化语句的问题，因为初始化用的是qvtkwidget版本时的代码，所以可能有些问题，于是就去找了QVTKOpenGLNativeWidget版本显示点云数据的代码\n结果照着别人的代码敲还是有问题\n\n\n找了找资料发现出现这种问题一般是因为这个类没有定义，其实就是vtkGenericOpenGLRenderWindow这个类的头文件没有引入，这里不得不吐槽一下，既然头文件没引入，你上面的的没啥不报错啊。。。\n引入头文件：\n#include &lt;vtkGenericOpenGLRenderWindow.h&gt;\n\n之后该语句就不会报错了\n\n\n以为终于没问题的时候，在执行到语句\nviewer.reset(new pcl::visualization::PCLVisualizer(renderer,renderWindow,&quot;viewer&quot;, false));\n\n的时候还是报错了。\n\n\n估计还是因为弄了两个vtk导致的，可能pcl1.12和自己配的这个vtk9.2不太搭，网上查了查资料，也都是自己下一个vtk9.1自己编译一下，然后覆盖原来的pcl自带的vtkk，然后再编译PCL。\n这次就老实照这个来一遍https://blog.csdn.net/qq_40732350/article/details/125394920，他跟我想的一样，除了vtk自己编译，其他直接用pcl自带的编译好的就行，省事。\n等开完会试一下。。。\n解决经过一番尝试，我已经完全理解了。\n正确的做法就是用自己编译的vtk替代pcl自带的vtk，然后从官网下载pcl源码，然后重新编译pcl，让它和自己编译的vtk配合起来。这样既有了自己编译的vtk的Qt相关插件，又可以让pcl跟自己配的vtk适配，正常用pcl库。\n具体的步骤见“PCL编译（暂定）”\n分析复盘要使用Qt+PCL显示点云，需要用到VTK来控制Qt窗口组件来显示。而PCL自带的vtk是不含与Qt配合相关的文件的。于是，我就想着去vtk官网下一个vtk自己用cmake编译一下，选上qt6组件。也成功编译了，问题就在，我以为就是用一下这个组件，就给项目既配了PCL（自带vtk9.1）环境，又配了自己编译的vtk9.2环境，而这两个都有的情况下，编译器编译的时候会有各种冲突，除非你能精准挑出来pcl用的vtk9.1的哪部分，Qt用的vtk9.2的哪部分，然后只把这些用到的引入，其他无关的全部不要引到环境里，其实就算这样pcl和qt用的vtk的部分也可能重合，比如pcl要用9.1的vtkcommon.dll而qt要用9.2的vtkcommon.dll，所以还是不行，这样肯定冲突。\n然后你又不能直接把pcl中vtk9.1的部分直接删掉或者替换成vtk9.2的，因为这个pcl是官网提供的编译好的，它是按照vtk9.1来编译的，对这个vtk9.1肯定又依赖。\n所以，只有按上面解决办法来才是正解。而且顺便还可以配一下GPU模块。\n","categories":["问题记录"],"tags":["PCL","Qt","VTK"]},{"title":"Qt在线安装包配置国内镜像源","url":"/2023/03/20/Qt6.4-mirror-download/","content":"最近在新电脑上重新装Qt6.4，学校的网不太行，安装时总是报错，干脆找了找教程，使用Qt官方的在线安装包配合国内镜像源来安装，这里记录一下。\nQt在线安装包下载他官网的安装包找起来绕过来绕过去，这里正好记录一下。\n打开Qt官网 https://www.qt.io/ ，找到右上角的 ”Download.Try.“ 点击进入\n\n\n进入的新页面拉到最底，找到”Download Qt for open source use”部分，点击”Go open source”进入下一个界面\n\n\n在进入的新页面再往下滑，也是快划到底的地方有个”Download the Qt Online Installer” ，点击这个按钮\n\n\n本来以为这就开始下载在线安装包了，结果还是进入新页面，点击新页面的这个”Download”，就真的开始下载在线安装包了\n\n\n服了，下个在线安装包点了4个download，还都不重样，牛。\n配置国内镜像源直接使用这个在线安装包的话，因为资源服务器在国外，难免网不行导致安装时出错，干脆直接配置国内镜像源来安装。\n找到Qt在线安装的存放路径，在空白处“shift+右键”，选择“打开Powershell窗口”\n\n\n输入命令.\\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt，注意该命令前半部分，是自己下载的qt在线安装包的名字，可能不一样，根据自己的情况改一改。\n\n\n输完之后回车，会不带任何提示地打开该安装包\n\n\n之后就是正常的qt安装过程了，根据自己的需求选就行\n\n\n之后就看各自的网速了\n\n\n资源下载完之后就开始解压缩，等进度条100%，qt就算是安好了\n","categories":["教程"],"tags":["Qt"]},{"title":"SpringBoot学习心得","url":"/2023/03/16/SpringBoot/","content":"前言前面写了个Vue的学习心得，马上就想起来跟Vue前端技术配合的后端技术SpringBoot好像好久没用了，感觉也需要写个Blog总结一下，不然以后真忘了无从下手就乐了。不过也不至于，当时就是照着YouTube一个教程学得，那教程还不错，大不了再看看那个视频，就是时间可能有点长。还是找时间写一写，加深一下印象吧。\n就以之前写的仓库管理系统为例，大概介绍一下项目结构，每个文件干什么的，再写写经常配合使用，操作数据的MyBatis-Plus的使用，包括自定义功能之类的。\n干脆也可以把Thymeleaf也介绍一下。\n感觉叫学习心得也不大对，我是学完了（也不对，学了一点吧），在用的时候得出的一些心得。那叫使用心得吧，也不大对，你那才用了多点功能啊。。。就当是在使用中深入学习的意思吧，就叫学习心得算了。\n","categories":["后端技术学习"],"tags":["SpringBoot","MyBatis-Plus"]},{"title":"Vue互动教程学习","url":"/2023/03/16/Vue-Interactive-Tutorial/","content":"前言Vue，易学易用，性能出色，适用场景丰富的 Web 前端框架。 \n以上为官网给出的精炼概括，之前本科实习期间的项目是用Vue+SpringBoot来前后端分离地开发一个项目，就是那会儿接触到原来还有这么个东西。但是那会儿在忙考研，对搞前端又没有兴趣，所以当时分工的时候选择了后端开发，稍微学了学SpringBoot。而对前端开发技术Vue便是毫不关心，一点没学，现在想想也有点可惜，毕竟当时实习期间那个教程我感觉挺好的，应该是有很多干货的。\n现在之所以想学Vue了，是发现想自己搞点Web项目的时候，只会后端技术完全不够，前端没有人给你写，只能去找别人的模板，然后用Thymeleaf来前后端交互，感觉不够自由，不够灵活。前端嘛，感觉还是根据自己的需求来设计比较好，到时候跟自己写的后端搭配应该也更方便些。\n当然，以上还是我的幻想，Vue还没开始学，不知道到时候设计前端的这个难度具体到底如何。美好的幻想：想要个什么样的前端界面，都能给他弄出来，不求那种花里胡哨的，就基本功能能实现，界面设计得能好看点也就心满意足了。\n下面开始Vue的学习，主要是看Vue的官网 https://cn.vuejs.org/\n里面有比较详细的介绍了Vue的基本组件等。。。应该是吧，我也还没仔细看\n这里主要是想介绍一下官网提供的一个互动教程https://cn.vuejs.org/tutorial/#step-1\n该教材支持边教边实践，左边教着内容，右边给你地方写代码让你试。下面的内容主要围绕跟着这个互动教程学习过程的心得。\n互动教程声明式渲染Attribute绑定Attribute绑定，v-bind指令，拿div举例&lt;div v-bind:id=&quot;dynamicID&quot;&gt;&lt;/div&gt;，其中的v-bind一简写，就变成了&lt;div :id=&quot;dynamicID&quot;&gt;&lt;/div&gt;，就剩个冒号了，这一般还真不知道是个什么意思，也没法查起。\n事件监听事件监听，v-on指令，拿button举例&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;，可以简写为&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;，这种@的写法我感觉还真见过不少，当时没学不知道是什么意思，原来是事件监听v-on的缩写。\nVue脚手架写这个blog另一个很大的原因是，就是想找个地方感慨一下这个事儿。\n当时本科实习期间老师还是教着我们用Vue Cli这个脚手架，到现在我再回头想学Vue想着看看Cli脚手架的时候发现它已经进入维护状态，官方不再推荐了。现在官方推荐了新的Vue脚手架Vite，该脚手架也是Vue的作者写的。\n就是想感慨一下这技术发展是真快啊感觉，不过前面也说了，实习那会儿Vue我就基本没学，更不用说这个Vue Cli脚手架了，直接转去学新的脚手架Vite毫无负担，血赚，哎嘿。但没仔细学当时的Vue教程，血亏，嘤。\n话说这样我之前搭的Vue Cli脚手架就白搭了，等着看看Vite脚手架的搭建有没有什么主意的地方，有的好也可以写个Blog，写写使用心得之类的，到时候就把这部分内容移过去。\n","categories":["前端技术学习"],"tags":["Vue"]},{"title":"Wamp安装","url":"/2023/03/21/WampServer-download/","content":"写这个也是想吐槽一下他这个网站的下载设计\n下面这个是他官方网站的主页，可以看到下面，下面那么大一个黄色按钮，还写着wamp对应的版本号，一眼看上去就是以为点这个下载\n\n\n然后点击之后就会发现没什么反应，当时还以为是要挂梯子之类的原因，结果检查这个按钮超链接的路径，发现这个按钮链接的是当前页面，也就是说点这个按钮只是不停的跳转到当前页面而已。。。\n\n\n那么真正的下载按钮在哪里呢？在黄色按钮上面的“DOWNLOADS”部分，点击“SourceForge”，就会前往真正的下载页面。而且其实读一读“DOWNLOADS”部分里的英文也确实说了让我们去”SourceForge“下载。但是吧。。。就挺搞的。。。\n\n\n下面就是真正的下载页面了，可以直接点击绿色按钮下载最新安装包即可。有其他需求的也可以去下面各个文件夹看一看，看看有没有自己需要的东西。\n\n\n补充：后面发现点击黄色按钮右下角的”changelog“也可以，会自动跳转到对应版本的下载页面，等待5s后会自动开始下载\n\n\n题外话，上面说的对应版本指的是64位、32位这个，不是指wamp版本号。因为可以看到黄色按钮明明写着3.2.6，下面小字说的却是3.3.0，然后实际安装时，安装包的版本也是3.3.0的。当然这也没什么所谓，就是吐槽一下。\n","categories":["教程"],"tags":["Wamp"]},{"title":"ccviewer学习笔记","url":"/2023/04/19/ccViewer-Note/","content":"代码解析ccViewer::ccViewer(QWidget *parent, Qt::WindowFlags flags)\t: QMainWindow(parent, flags)\t, m_glWindow(nullptr)\t, m_selectedObject(nullptr)\t, m_3dMouseInput(nullptr)\n\n这段代码是一个类 ccViewer 的构造函数的实现，该类是继承自 QMainWindow 类的。\n构造函数的参数 parent 是一个指向父窗口的指针，参数 flags 是窗口的标志。\n下面是成员变量的初始化：\n\nm_glWindow 是一个指向 QOpenGLWidget 对象的指针，初始化为 nullptr。\nm_selectedObject 是一个指向选中的对象的指针，初始化为 nullptr。\nm_3dMouseInput 是一个指向 Q3DMouseInput 对象的指针，初始化为 nullptr。\n\n在这个构造函数中，这些成员变量都被初始化为默认值。这些成员变量可以在类的其他成员函数中使用，以实现类的功能。\n","categories":["笔记"],"tags":["Qt","cloudcompare"]},{"title":"Hello World","url":"/2021/03/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n\n\n\n\n\n\n37bc485ba4a3b31d02a3ba25267af1715187b72c\n\n\n\n\n\n\n\n"}]
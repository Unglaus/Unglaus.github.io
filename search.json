[{"title":"大家一起学英语","url":"/2023/03/07/English-Word/","content":"引言在学习OCC、PCL等C++库，或是其他一些技术时，通常需要阅读官方提供的技术手册，而这些手册大多是英文编写，虽然可以直接使用翻译软件进行翻译，但毕竟翻译软件有时翻译的也是词不达意，加之它可能把人家定义的类名之类的东西也翻译成中文，还不如直接看英文。综上，长远来看，提升自己的英文水平总没错，本文用来收集阅读英文手册或教程时遇到的各种不认识的单词，也不指望能将这些单词全部融汇贯通，但希望下次见到时最起码能认得它是个什么意思。\nOCC\ngeometry：几何学\nparametric：参数\ndimension：纬度\ninfinity：无限大\nsecond order：二阶\ncriteria：标准\nscaled ellipse：缩放的椭圆\ncylinder：圆筒\nconjugate：共轭的\nprojection：投影\nintersection：交叉点\ntopology：拓扑学\n\nPCL\ncomplicate：复杂化\ntrim：修剪\noutliers：离群值、异常值\ndeviation：偏差\n\nCloudCompare Wiki\nmesh：网格\nportable：便携式（可移植）\ntrade-off：权衡利弊\nentity：实体\nproperty：属性（财产）\nscalar：标量\nscale：规模、刻度\nalign：对齐\nalignment：对齐\nregistration：配准（注册）\nfine registration：精确配准\nprimitive：原始的、基础的\nprimitive factory：基体工厂（创建基础模型）\ncloud/primitive Dist：点云/基体距离\nmerge：合并\nsubsample：子样本\nOctree：八叉树\nhistogram：直方图\nprojection：预测\nSF（scalar field）：标量字段\nrasterize：栅格化\nvolume：体积\nstatistic：统计数据\nALS：机载激光雷达扫描\nTLS：地面激光雷达扫描\n\nOctree Wikipediahttps://en.wikipedia.org/wiki/Octree\n\nOctree：八叉树，用来将3维空间递归地细分为8个卦限，它相当于三维空间的四叉树\nQuadtree：四叉树，用来将2维空间递归的分为4个象限。\noctant：卦限，类似于于二维空间的象限，一维空间的ray\nquadrant：象限\nray：射线（？）\nrecursively：递归的\nsubdivide：细分\nanalog：模拟、类似\ndimension：纬度\n\nImplementation for point decompositionThe example recursive algorithm outline below (MATLAB syntax) decomposes an array of 3-dimensional points into octree style  bins. The implementation begins with a single bin surrounding all given  points, which then recursively subdivides into its 8 octree regions.  Recursion is stopped when a given exit condition is met. Examples of  such exit conditions (shown in code below) are:\n\nWhen a bin contains fewer than a given number of points\nWhen a bin reaches a minimum size or volume based on the length of its edges\nWhen recursion has reached a maximum number of subdivisions\n\nfunction [binDepths, binParents ,binCorners, pointBins] = OcTree(points)binDepths = [0]     % Initialize an array of bin depths with this single base-level binbinParents = [0]    % This base level bin is not a child of other binsbinCorners = [min(points) max(points)] % It surrounds all points in XYZ spacepointBins(:) = 1    % Initially, all points are assigned to this first bindivide(1)           % Begin dividing this first binfunction divide(binNo)% If this bin meets any exit conditions, do not divide it any further.binPointCount = nnz(pointBins == binNo)binEdgeLengths = binCorners(binNo, 1:3) - binCorners(binNo, 4:6)binDepth = binDepths(binNo)exitConditionsMet = binPointCount&lt;value || min(binEdgeLengths) &lt; value || binDepth &gt; valueif exitConditionsMet    return; % Exit recursive functionend% Otherwise, split this bin into 8 new sub-bins with a new division pointnewDiv = (binCorners(binNo, 1:3) + binCorners(binNo, 4:6)) / 2for i = 1:8    newBinNo = length(binDepths) + 1    binDepths(newBinNo) = binDepths(binNo) + 1    binParents(newBinNo) = binNo    binCorners(newBinNo) = [one of the 8 pairs of the newDiv with minCorner or maxCorner]    oldBinMask = pointBins == binNo    % Calculate which points in pointBins == binNo now belong in newBinNo    pointBins(newBinMask) = newBinNo    % Recursively divide this newly created bin    divide(newBinNo)end\n\n\n\n\n\n\n\n\n\n不定期更新中。。。\n","categories":["英文学习"],"tags":["English Word"]},{"title":"CloudCompare-Cmake","url":"/2023/04/06/CloudCompare-Cmake/","content":"CloudCompare，后续简称CC\n依赖Qt5CC是基于Qt5开发的，所以编译前需要安装Qt5，具体的Qt5版本根据CC源码的版本可能也有不同，需要自己去看源码中build.md文件说明。我要编译的CC版本是2.12.4，该版本的build.md文件提到2.11+版本之后的Qt版本要求为：5.9 &lt;= Qt &lt; 6.0. 所以我直接安装了Qt5的最新版本Qt5.15.2，就用的官网提供的在线安装包，具体的安装教程见“Qt在线安装包配置国内镜像源”\nOpenGLOpenGL其实电脑有自带的，但我看Cmake找到的那个自带的好像是win8版本的，不知道好用不好用，我就给他重新配了之前VS安装的win11版本的。这个OpenGL不用特意装，安装Windows SDK就会带着，通过VS installer就可以安。\n\n\n源码下载上面两个依赖配置好之后去官方Github下载需要编译的源码，前面也提到过，我选了v2.12.4版本\n\n\n下下来之后要注意这个其实是不完整的，作者把核心算法库单独拿了出来，放在CCCoreLib项目里。\n我们直接打开下载下来的文件，找到”CloudCompare/libs/qCC_db/extern/“ 目录，会发现里面是空的，但是用Cmake编译的时候他又会报错，告诉你需要这个文件夹中的文件，那如何找到这个项目的位置，只需要在GitHub中找到这个目录的位置，会发现官方在这里给出了超链接，跟着超链接就能找到需要的内容。\n\n\n点击这个超链接就会跳转到CCCoreLib库的所在，这里直接下载这个默认的即可\n\n\n之后将下载下来的文件解压到之前空文件夹的位置即可，后面再细说。\n然后这个其实也不是完整的，它里面也有需要去其他地方下载的文件，找到”CCCoreLib/extern/“ 目录，发现里面也有个超链接\n\n\n这个下载默认的即可，下载下来解压到对应的目录。\n\n\n\n\n组合下载下来一共3个项目\n\n\n将nanoflann中的内容，全部放到”CCCoreLib-master/extern/nanoflann“目录中\n\n\n然后再把上面这个组合好的CCCoreLib-master中的内容全部放到”CloudCompare-2.12.4/libs/qCC_db/extern/CCCoreLib“目录里\n\n\n这样才算是得到完整的能够编译的CC文件，后面就用这个CloudCompare-2.12.4文件夹里的内容做Source，用Cmake编译即可。\n编译老三样，三个文件夹source、build、install\nCmake编译，记得把install路径改过来\n配置Qt5路径主要是配Qt5_DIR的路径，根据自己的Qt5安装路径来配，我的是\nE:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5\n\n配完这个之后其他的Qt5路径它就自动识别了\n\n\nQt5LinguistTools路径有一个除外，每错，就是这个Qt5LinguistTools的路径，明明安装了，而且也跟它识别到的其他的Qt5组件在一个路径里，不知道它为什么自己找不到，需要我们自己再告诉它一下，路径为\nE:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5LinguistTools\n\n\n\n配置OpenGL路径他其实自己找到了一个路径\nC:&#x2F;Program Files (x86)&#x2F;Windows Kits&#x2F;8.0&#x2F;Lib&#x2F;win8&#x2F;um&#x2F;x64\n\n\n\n但我看他这个路径名，好像是win8的版本吧。。。我不太放心，就用了前面提到的用VS安装的win11版本的，具体路径为：\nE:&#x2F;Windows Kits&#x2F;10&#x2F;Lib&#x2F;10.0.22000.0&#x2F;um&#x2F;x64\n\n\n\n至于具体怎么找到这个路径的，还是用到之前其它教程提到的”everything“，搜索”OpenGL32.lib“，这个文件所在路径即为所求\n\n\n之后就是一路configure、generate、Open Project老三样\n然后在VS里”ALL_BUILD“右键生成、”INSTALL“右键生成即可\n\n","categories":["教程"],"tags":["CloudCompare"]},{"title":"PCL1.12.1+VS2022+Qt6.4 配置","url":"/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/","content":"本教程分为两部分，第一部分为PCL+VS的配置，第二部分为PCL+VS+QT的配置。\n如果只是要在VS用用PCL，学习一下PCL点云库，只看第一部分PCL+VS的配置即可。\n而如果还需要配合QT做界面，相关的配置会在第二部分PCL+VS+QT的配置中介绍。\nPCL+VS 配置PCL安装前言PCL（Point Cloud Library）官方网站 https://pointclouds.org/\n官方github网站 https://github.com/PointCloudLibrary/pcl\nPCL官方的github提供了各种版本的PCL源码，同时还提供了已经编译好的PCL供使用。\n解释一下，PCL正常来配置的话，是需要自己安装PCL依赖的第三方库，一般有Boost、Eigen、FLANN、OpenNI2、Qhull、VTK，我们需要将这些第三方库从各自官网下载下来，分别用Cmake编译好，然后再编译PCL的源码，因为PCL编译时要依赖上述第三库编译出的文件，包括库文件（library）等二进制文件。这样的优势在于编译PCL的时候可以自选PCL的一些组件，比如可以指定PCL的GPU加速模块（默认是不带的），还可以指定要与Qt6配合使用，它应该就会在编译时往与Qt6适配这方面有进一步的优化。但缺点就是麻烦，要把上面每一个第三方库都安装编译一遍可不是一般的麻烦，而且各个第三方库版本之间的兼容性、适配度也需要自己摸索。\n所以官方也提供了已经完全编译好的PCL安装包供我们使用，该安装包包含上述的所有第三方库编译好的文件，以及依赖它们所编译好的PCL文件。当然，官方提供的这种安装包得到的PCL只提供了最基本的功能，不含GPU模块等扩展。而且其中所带的第三库也都是最基本的配置，就比如其中自带的VTK，就没有针对Qt6做额外的配置，缺少与Qt6配合所需的文件。\n因此，个人认为，最佳的PCL配置安装路线是，1、先使用官方提供的AllInOn安装包，就是之前提过的官方提供的自带编译好的第三方库及编译好的PCL的安装包。补充一下，这个安装包自带的第三方库安好后，从各自的文件夹名字基本能得知每个第三库的版本，即我们可以从中得知当前PCL版本要与第三方库的哪些版本配合兼容性好。2、根据自己的需求，自己安装编译对应版本的第三方库，并用它替换掉PCL自带的对应部分的第三方库。就比如，我要使用VTK配合Qt的组件，而PCL自带的VTK显然不带与Qt配合的部分。因此我去VTK官网自己下一个VTK源码，并自己编译，编译时配置与Qt配合，那我得到的编译后的文件就带有我所需的与Qt配合的部分。之后我用我自己编译好的VTK文件（包括bin、lib、include等），把PCL自带的VTK的这些文件都替换掉。当然，如果没有这类需求，只是想自己编译一下PCL，比如自己编译PCL增加一个GPU模块，那这第2步就没有必要。3、前面是编译PCL的准备步骤，准备好PCL编译所依赖的第三方库文件（编译好的），下面就是编译PCL，去官网下载对应版本的PCL源码，使用CMake编译即可，编译的时候绑定好这些第三方库的位置、选好要用的PCL模块。具体操作见本教程第二部分“PCL+VS+QT 配置” 。\n官方编译版安装下面开始官方编译版PCL的安装教程，因为如果只是配合VS来学习PCL库，安这个也就够用了，有进一步的自定义需求的可以接着看第二部分。\n在官方github网站（PCL项目）的右侧找到Releases部分\n\n\n\n\n他这里把最新的版本放在前面，可以看到是PCL1.13.0版本，如果想安装其他版本就点“+30 releases”去找自己想安的版本，因为我之前安装的是PCL1.12.1，所以我还是以该版本为例来写。\n\n\n点开相应版本下的“Assets”，就能看到具体提供的安装资源，其中的AllInOne安装包就是官方提供的编译好的第三方库及PCL文件。\n\n\n之后点击安装即可，这里提点安装时的个人小建议，一是选择添加环境变量到PATH，能为后面配环境变量省一点事儿\n\n\n然后是选择安装路径的时候，官方自动给的路径中“PCL 1.12.1”里面有个空格，为了方便后续编译PCL时的方便，建议把这个空格去掉，或是换成下划线之类的，总之路径里最后不要有空格，中文最好也别有（这个没试过，可能没事）\n\n\n重要！！！后来我发现相比下划线”PCL_1.12.1”，用横杠更好看”PCL-1.12.1”，仅供参考。等之后找个空把我要把这些路径名都改过来。\n然后在安装过程中如果之前没有安装过OpenNI2，会弹出窗口问是否安装OpenNI2，点击安装即可。\n\n\n 比较坑的是，这个OpenNI2一般不会老老实实按照我们PCL安装路径安装，而是安装在C盘。不过也不用在意，等PCL安装程序全部安装完成后，找到安装目录\\PCL_1.12.1\\3rdParty，该目录下就是PCL官方为我们打包好的，编译好的第三方库\n\n\n打开其中的OpenNI2目录，如果里面是空的，只有一个OpenNI-Windows-x64-2.2.msi文件，那恭喜，这东西成功安到C盘去了。。。\n\n\n但不用担心，这个msi文件就是OpenNI2的安装文件，我们可以通过它，把安在C盘的OpenNI2卸载\n\n\n然后再通过这个msi把它安装回来，主要是因为通过这个msi文件来安装的时候，它会让你选安装路径，我们就把安到\\PCL_1.12.1\\3rdParty\\OpenNI2路径，这样就让PCL的第三库整整齐齐在一起了。\n\n\n现在再看OpenNI2的文件夹，这就正常了。\n\n\n当然，不介意OpenNI2安在C盘，与其他第三方库天各一方的话，就不用把它卸了又装。\n现在打开系统环境变量来看一下，因为我们之前选择了添加PCL环境变量到PATH，所以这里已经自动帮我们配好了一部分。\n在系统变量里帮我们配好了OPENNI2的三个相关变量（外：PCL_ROOT,OpenNI2三项；Path内：PCL/bin，VTK/bin）\n\n\n在Path里帮我们配好了最基本的PCL和VTK的bin路径\n\n\n除了他帮我们配好的这一部分，我们还需要把其他第三方库跟dll有关的路径添加上\n%PCL_ROOT%\\3rdParty\\FLANN\\bin%PCL_ROOT%\\3rdParty\\Qhull\\bin%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n另外因为他给我们配好PCL_ROOT了，可以直接拿来用\n\n\n一开始我以为我没用到上面的模块，这些环境变量没必要加，结果不加它们在运行的时候报了缺少OpenNI2.dll的错误，所以我估计虽然没有直接使用这些第三方库，但PCL毕竟是依赖它们编译出来的，在运行时估计还是需要用到这些东西，所以还是把上面这些都加到环境变量里吧。\n对了，既然说到这了，提供一种程序运行时出现缺少xxx.dll文件时的解决思路\n\n\n这种一般就是程序调试的时候找不到相关的dll导致的（废话。。。），所以我们首先要找到这个dll的位置，还是通过之前的软件“everything”，查找到这个dll所在位置\n\n\n之后有两种办法 ，一是直接将这个dll文件复制到程序运行目录下，二是将这个dll文件所在的路径添加到环境变量Path中，然后在VS的调试属性中告诉它去哪里找这些dll文件。上面这么多路径，选一个加到环境变量里即可。\n\n\n在这个例子里，通过网上的参考，只要把下面两个路径加到环境变量里，应该就包含OpenNI2所需的所有dll文件了。\n%PCL_ROOT%\\3rdParty\\OpenNI2\\Tools%PCL_ROOT%\\3rdParty\\OpenNI2\\Redist\n\n而在不知道哪个路径里包含程序运行所需的所有dll文件的情况下，就只能是缺一个，找个一路径加一下这样。。。当然，因为你加的路径里包含多个dll文件，在有多个dll路径可选的时候，是有可能你选的那个路径，就是包含你当前程序运行所需的所有dll文件的路径。提这个就是想说，选哪个路径加到环境变量里的时候，还是可以稍微思考一下的，哎嘿。\n题外话，不过让我纳闷的是，上面配置的所有PCL相关环境时，里面没有Boost相关的环境变量，甚至我程序中都显式地使用了Boost相关的代码，它也没报过缺少dll文件的错。而且其实在第三方库Boost的安装路径\\PCL_1.12.1\\3rdParty\\Boost里，可以看到是没有bin文件夹的，找了找也没有像OpenNI2那样把dll分散到别的文件夹里，Boost好像就是没有dll文件。看样Boost在使用时跟别人都不一样，不需要这个dll文件就能用。这一段是见识短的我的一点小感慨，等我见识长了，看看能不能有什么新的认识补充。\nVS配置跟之前OCC在VS中的配置类似，主要三个部分。让程序能找到bin里的dll文件，找到inc里的.h头文件，找到lib里的lib库函数。\n如何让程序能找到bin里的dll文件在上面已经给出了，就是在属性页的 “调试–&gt;环境” 里添加PATH=%PATH%，不过感觉不加好像也行，一般程序创建的时候都带着。\n让程序能找到头文件，添加PCL所有关联的头文件目录。找到 属性页 -&gt; “C/C++” -&gt; “常规”-&gt;”附加包含目录”，把这些头文件路径添加进去即可。\n\n\nE:\\PCL_1.12.1\\include\\pcl-1.12E:\\PCL_1.12.1\\3rdParty\\Boost\\include\\boost-1_78E:\\PCL_1.12.1\\3rdParty\\Eigen\\eigen3E:\\PCL_1.12.1\\3rdParty\\FLANN\\includeE:\\PCL_1.12.1\\3rdParty\\OpenNI2\\IncludeE:\\PCL_1.12.1\\3rdParty\\Qhull\\includeE:\\PCL_1.12.1\\3rdParty\\VTK\\include\\vtk-9.1\n\n让程序能找到lib文件，找到属性页-&gt;”链接器”-&gt;”常规”-&gt;”附加库目录”，添加lib库位置。\n\n\nE:\\PCL_1.12.1\\libE:\\PCL_1.12.1\\3rdParty\\Boost\\libE:\\PCL_1.12.1\\3rdParty\\FLANN\\libE:\\PCL_1.12.1\\3rdParty\\OpenNI2\\LibE:\\PCL_1.12.1\\3rdParty\\Qhull\\libE:\\PCL_1.12.1\\3rdParty\\VTK\\lib\n\n然后还是在链接器部分，找到“输入”-&gt;”附加依赖项”，把上面所有lib库路径下的lib文件名引入到附加依赖项里\n\n\n之前配OCC的时候提过了，在每个lib文件夹下，shift+右键，选择打开Powershell窗口，然后通过命令行ls *.lib -n来获取各个文件夹下的所有lib文件名即可。这里直接给出该PCL版本下所以的lib文件\npcl_commond.libpcl_featuresd.libpcl_filtersd.libpcl_iod.libpcl_io_plyd.libpcl_kdtreed.libpcl_keypointsd.libpcl_mld.libpcl_octreed.libpcl_outofcored.libpcl_peopled.libpcl_recognitiond.libpcl_registrationd.libpcl_sample_consensusd.libpcl_searchd.libpcl_segmentationd.libpcl_stereod.libpcl_surfaced.libpcl_trackingd.libpcl_visualizationd.liblibboost_atomic-vc142-mt-gd-x64-1_78.liblibboost_bzip2-vc142-mt-gd-x64-1_78.liblibboost_chrono-vc142-mt-gd-x64-1_78.liblibboost_container-vc142-mt-gd-x64-1_78.liblibboost_context-vc142-mt-gd-x64-1_78.liblibboost_contract-vc142-mt-gd-x64-1_78.liblibboost_coroutine-vc142-mt-gd-x64-1_78.liblibboost_date_time-vc142-mt-gd-x64-1_78.liblibboost_exception-vc142-mt-gd-x64-1_78.liblibboost_filesystem-vc142-mt-gd-x64-1_78.liblibboost_graph-vc142-mt-gd-x64-1_78.liblibboost_graph_parallel-vc142-mt-gd-x64-1_78.liblibboost_iostreams-vc142-mt-gd-x64-1_78.liblibboost_json-vc142-mt-gd-x64-1_78.liblibboost_locale-vc142-mt-gd-x64-1_78.liblibboost_log-vc142-mt-gd-x64-1_78.liblibboost_log_setup-vc142-mt-gd-x64-1_78.liblibboost_math_c99-vc142-mt-gd-x64-1_78.liblibboost_math_c99f-vc142-mt-gd-x64-1_78.liblibboost_math_c99l-vc142-mt-gd-x64-1_78.liblibboost_math_tr1-vc142-mt-gd-x64-1_78.liblibboost_math_tr1f-vc142-mt-gd-x64-1_78.liblibboost_math_tr1l-vc142-mt-gd-x64-1_78.liblibboost_mpi-vc142-mt-gd-x64-1_78.liblibboost_nowide-vc142-mt-gd-x64-1_78.liblibboost_numpy38-vc142-mt-gd-x64-1_78.liblibboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_program_options-vc142-mt-gd-x64-1_78.liblibboost_python38-vc142-mt-gd-x64-1_78.liblibboost_random-vc142-mt-gd-x64-1_78.liblibboost_regex-vc142-mt-gd-x64-1_78.liblibboost_serialization-vc142-mt-gd-x64-1_78.liblibboost_system-vc142-mt-gd-x64-1_78.liblibboost_test_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_thread-vc142-mt-gd-x64-1_78.liblibboost_timer-vc142-mt-gd-x64-1_78.liblibboost_type_erasure-vc142-mt-gd-x64-1_78.liblibboost_unit_test_framework-vc142-mt-gd-x64-1_78.liblibboost_wave-vc142-mt-gd-x64-1_78.liblibboost_wserialization-vc142-mt-gd-x64-1_78.liblibboost_zlib-vc142-mt-gd-x64-1_78.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.libOpenNI2.libqhullcpp_d.libqhullstatic_d.libqhullstatic_rd.libqhull_rd.libvtkcgns-9.1.libvtkcgns-9.1d.libvtkChartsCore-9.1.libvtkChartsCore-9.1d.libvtkCommonColor-9.1.libvtkCommonColor-9.1d.libvtkCommonComputationalGeometry-9.1.libvtkCommonComputationalGeometry-9.1d.libvtkCommonCore-9.1.libvtkCommonCore-9.1d.libvtkCommonDataModel-9.1.libvtkCommonDataModel-9.1d.libvtkCommonExecutionModel-9.1.libvtkCommonExecutionModel-9.1d.libvtkCommonMath-9.1.libvtkCommonMath-9.1d.libvtkCommonMisc-9.1.libvtkCommonMisc-9.1d.libvtkCommonSystem-9.1.libvtkCommonSystem-9.1d.libvtkCommonTransforms-9.1.libvtkCommonTransforms-9.1d.libvtkDICOMParser-9.1.libvtkDICOMParser-9.1d.libvtkDomainsChemistry-9.1.libvtkDomainsChemistry-9.1d.libvtkDomainsChemistryOpenGL2-9.1.libvtkDomainsChemistryOpenGL2-9.1d.libvtkdoubleconversion-9.1.libvtkdoubleconversion-9.1d.libvtkexodusII-9.1.libvtkexodusII-9.1d.libvtkexpat-9.1.libvtkexpat-9.1d.libvtkFiltersAMR-9.1.libvtkFiltersAMR-9.1d.libvtkFiltersCore-9.1.libvtkFiltersCore-9.1d.libvtkFiltersExtraction-9.1.libvtkFiltersExtraction-9.1d.libvtkFiltersFlowPaths-9.1.libvtkFiltersFlowPaths-9.1d.libvtkFiltersGeneral-9.1.libvtkFiltersGeneral-9.1d.libvtkFiltersGeneric-9.1.libvtkFiltersGeneric-9.1d.libvtkFiltersGeometry-9.1.libvtkFiltersGeometry-9.1d.libvtkFiltersHybrid-9.1.libvtkFiltersHybrid-9.1d.libvtkFiltersHyperTree-9.1.libvtkFiltersHyperTree-9.1d.libvtkFiltersImaging-9.1.libvtkFiltersImaging-9.1d.libvtkFiltersModeling-9.1.libvtkFiltersModeling-9.1d.libvtkFiltersParallel-9.1.libvtkFiltersParallel-9.1d.libvtkFiltersParallelImaging-9.1.libvtkFiltersParallelImaging-9.1d.libvtkFiltersPoints-9.1.libvtkFiltersPoints-9.1d.libvtkFiltersProgrammable-9.1.libvtkFiltersProgrammable-9.1d.libvtkFiltersSelection-9.1.libvtkFiltersSelection-9.1d.libvtkFiltersSMP-9.1.libvtkFiltersSMP-9.1d.libvtkFiltersSources-9.1.libvtkFiltersSources-9.1d.libvtkFiltersStatistics-9.1.libvtkFiltersStatistics-9.1d.libvtkFiltersTexture-9.1.libvtkFiltersTexture-9.1d.libvtkFiltersTopology-9.1.libvtkFiltersTopology-9.1d.libvtkFiltersVerdict-9.1.libvtkFiltersVerdict-9.1d.libvtkfmt-9.1.libvtkfmt-9.1d.libvtkfreetype-9.1.libvtkfreetype-9.1d.libvtkGeovisCore-9.1.libvtkGeovisCore-9.1d.libvtkgl2ps-9.1.libvtkgl2ps-9.1d.libvtkglew-9.1.libvtkglew-9.1d.libvtkhdf5-9.1.libvtkhdf5-9.1d.libvtkhdf5_hl-9.1.libvtkhdf5_hl-9.1d.libvtkImagingColor-9.1.libvtkImagingColor-9.1d.libvtkImagingCore-9.1.libvtkImagingCore-9.1d.libvtkImagingFourier-9.1.libvtkImagingFourier-9.1d.libvtkImagingGeneral-9.1.libvtkImagingGeneral-9.1d.libvtkImagingHybrid-9.1.libvtkImagingHybrid-9.1d.libvtkImagingMath-9.1.libvtkImagingMath-9.1d.libvtkImagingMorphological-9.1.libvtkImagingMorphological-9.1d.libvtkImagingSources-9.1.libvtkImagingSources-9.1d.libvtkImagingStatistics-9.1.libvtkImagingStatistics-9.1d.libvtkImagingStencil-9.1.libvtkImagingStencil-9.1d.libvtkInfovisCore-9.1.libvtkInfovisCore-9.1d.libvtkInfovisLayout-9.1.libvtkInfovisLayout-9.1d.libvtkInteractionImage-9.1.libvtkInteractionImage-9.1d.libvtkInteractionStyle-9.1.libvtkInteractionStyle-9.1d.libvtkInteractionWidgets-9.1.libvtkInteractionWidgets-9.1d.libvtkIOAMR-9.1.libvtkIOAMR-9.1d.libvtkIOAsynchronous-9.1.libvtkIOAsynchronous-9.1d.libvtkIOCGNSReader-9.1.libvtkIOCGNSReader-9.1d.libvtkIOChemistry-9.1.libvtkIOChemistry-9.1d.libvtkIOCityGML-9.1.libvtkIOCityGML-9.1d.libvtkIOCONVERGECFD-9.1.libvtkIOCONVERGECFD-9.1d.libvtkIOCore-9.1.libvtkIOCore-9.1d.libvtkIOEnSight-9.1.libvtkIOEnSight-9.1d.libvtkIOExodus-9.1.libvtkIOExodus-9.1d.libvtkIOExport-9.1.libvtkIOExport-9.1d.libvtkIOExportGL2PS-9.1.libvtkIOExportGL2PS-9.1d.libvtkIOExportPDF-9.1.libvtkIOExportPDF-9.1d.libvtkIOGeometry-9.1.libvtkIOGeometry-9.1d.libvtkIOHDF-9.1.libvtkIOHDF-9.1d.libvtkIOImage-9.1.libvtkIOImage-9.1d.libvtkIOImport-9.1.libvtkIOImport-9.1d.libvtkIOInfovis-9.1.libvtkIOInfovis-9.1d.libvtkIOIOSS-9.1.libvtkIOIOSS-9.1d.libvtkIOLegacy-9.1.libvtkIOLegacy-9.1d.libvtkIOLSDyna-9.1.libvtkIOLSDyna-9.1d.libvtkIOMINC-9.1.libvtkIOMINC-9.1d.libvtkIOMotionFX-9.1.libvtkIOMotionFX-9.1d.libvtkIOMovie-9.1.libvtkIOMovie-9.1d.libvtkIONetCDF-9.1.libvtkIONetCDF-9.1d.libvtkIOOggTheora-9.1.libvtkIOOggTheora-9.1d.libvtkIOParallel-9.1.libvtkIOParallel-9.1d.libvtkIOParallelXML-9.1.libvtkIOParallelXML-9.1d.libvtkIOPLY-9.1.libvtkIOPLY-9.1d.libvtkIOSegY-9.1.libvtkIOSegY-9.1d.libvtkIOSQL-9.1.libvtkIOSQL-9.1d.libvtkioss-9.1.libvtkioss-9.1d.libvtkIOTecplotTable-9.1.libvtkIOTecplotTable-9.1d.libvtkIOVeraOut-9.1.libvtkIOVeraOut-9.1d.libvtkIOVideo-9.1.libvtkIOVideo-9.1d.libvtkIOXML-9.1.libvtkIOXML-9.1d.libvtkIOXMLParser-9.1.libvtkIOXMLParser-9.1d.libvtkjpeg-9.1.libvtkjpeg-9.1d.libvtkjsoncpp-9.1.libvtkjsoncpp-9.1d.libvtkkissfft-9.1.libvtkkissfft-9.1d.libvtklibharu-9.1.libvtklibharu-9.1d.libvtklibproj-9.1.libvtklibproj-9.1d.libvtklibxml2-9.1.libvtklibxml2-9.1d.libvtkloguru-9.1.libvtkloguru-9.1d.libvtklz4-9.1.libvtklz4-9.1d.libvtklzma-9.1.libvtklzma-9.1d.libvtkmetaio-9.1.libvtkmetaio-9.1d.libvtknetcdf-9.1.libvtknetcdf-9.1d.libvtkogg-9.1.libvtkogg-9.1d.libvtkParallelCore-9.1.libvtkParallelCore-9.1d.libvtkParallelDIY-9.1.libvtkParallelDIY-9.1d.libvtkpng-9.1.libvtkpng-9.1d.libvtkpugixml-9.1.libvtkpugixml-9.1d.libvtkRenderingAnnotation-9.1.libvtkRenderingAnnotation-9.1d.libvtkRenderingContext2D-9.1.libvtkRenderingContext2D-9.1d.libvtkRenderingContextOpenGL2-9.1.libvtkRenderingContextOpenGL2-9.1d.libvtkRenderingCore-9.1.libvtkRenderingCore-9.1d.libvtkRenderingFreeType-9.1.libvtkRenderingFreeType-9.1d.libvtkRenderingGL2PSOpenGL2-9.1.libvtkRenderingGL2PSOpenGL2-9.1d.libvtkRenderingImage-9.1.libvtkRenderingImage-9.1d.libvtkRenderingLabel-9.1.libvtkRenderingLabel-9.1d.libvtkRenderingLOD-9.1.libvtkRenderingLOD-9.1d.libvtkRenderingOpenGL2-9.1.libvtkRenderingOpenGL2-9.1d.libvtkRenderingSceneGraph-9.1.libvtkRenderingSceneGraph-9.1d.libvtkRenderingUI-9.1.libvtkRenderingUI-9.1d.libvtkRenderingVolume-9.1.libvtkRenderingVolume-9.1d.libvtkRenderingVolumeOpenGL2-9.1.libvtkRenderingVolumeOpenGL2-9.1d.libvtkRenderingVtkJS-9.1.libvtkRenderingVtkJS-9.1d.libvtksqlite-9.1.libvtksqlite-9.1d.libvtksys-9.1.libvtksys-9.1d.libvtkTestingRendering-9.1.libvtkTestingRendering-9.1d.libvtktheora-9.1.libvtktheora-9.1d.libvtktiff-9.1.libvtktiff-9.1d.libvtkverdict-9.1.libvtkverdict-9.1d.libvtkViewsContext2D-9.1.libvtkViewsContext2D-9.1d.libvtkViewsCore-9.1.libvtkViewsCore-9.1d.libvtkViewsInfovis-9.1.libvtkViewsInfovis-9.1d.libvtkWrappingTools-9.1.libvtkWrappingTools-9.1d.libvtkzlib-9.1.libvtkzlib-9.1d.lib\n\n至此，就可以在VS里使用PCL愉快开发了。\nPCL+VS+QT 配置之前VS+PCL显示时用的是boost，但要配合Qt的ui界面来显示的话，需要用到VTK的一个组件QVTKOpenGLNativeWidget。使用这个组件需要重新编译VTK，让它生成配合Qt的相关文件。之后用我们新编译出的VTK文件替换PCL自带的VTK文件，再重新编译一下PCL，让PCL生成的文件好和现在的VTK配合起来。\nVTK编译源码下载去VTK的官网 https://vtk.org/ 下载VTK的源文件。我们注意到PCL自带的VTK版本是9.1的，而官网只提供VTK9.2.6版本的源码了。无需担心，只要VTK的这个大版本一样就行，即都是VTK9的版本即可，别下成下面8.2.0或是7.1.1的版本就行。而且是在要找还是能在GitHub上找到VTK9.1版本的源码的。\n\n\nCMake编译这里正好简单介绍一下使用CMake编译的流程，我们一般会用到3个文件夹，source文件夹用来放之前下载下来的源代码，build文件夹用来放CMake生成的文件，install文件夹用来放最后编译生成的文件。\n这里我创建了一个VTK9.2.6文件夹，并在里面创建了上述三个文件夹，source、build、install\n\n\n之后把之前下载的源代码解压到了source文件夹下\n\n\n打开CMake的GUI界面，给出源文件路径和build路径，之后点configure\n\n\n编译器就用他检测到的我们现在的编译器版本VS2022，下面平台版本选一下x64\n\n\n第一次configure之后可以看到界面是红色的，表示这些选项我们还未确认过，这里有几项我们需要进行修改\n\n\n修改后结果如下。这个install的路径改成我们之前建的install文件夹，不然一会编译的时候生成的源码都跑到上面C盘的路径下了。然后就是把VTK配合Qt和Views的选项改为yes，之后编译才会生成与Qt配合相关的文件。确认好了之后再点一下Configure\n\n\n再次Configure会根据之前的选择而产生新的选项让我们确认，而之前的选项在我们点Configure的时候他就当我们确认好了，就变成白色了，当然变成白色的这些选项还是可以改的。在新出现的这些选项中，我们需要给他选定需要配合的Qt版本，以及对应的Qt文件夹路径。\n\n\n其中Qt的版本根据自己要用的Qt版本来选，我用Qt6所以版本这里自然选6，然后再告诉它Qt6文件夹的路径。Qt5我不用所以不用管，如果用Qt5的话，照着这个Qt6的路径去找就行。\nE:\\QT6\\6.4.3\\msvc2019_64\\lib\\cmake\\Qt6\n\n\n\n之后再点Configure，他就会根据之前提供的Qt6文件所在路径把Qt6一系列组件之类的文件路径自动填好了，大体看看，没事直接再点Configure就行\n\n\n这次Configure完之后所有的选项都是白色，代表没有新增选项需要确认了，也就是Configure部分结束了，现在可以点Generate了\n\n\nGenerate完之后直接点旁边的Open Project打开VS编译器\n\n\n在VS编译器解决方案处，找到ALL_BUILD，右键生成。\n\n\n等ALL_BUILD都生成完之后，往下找到INSTALL，右键生成。\n\n\n生成完之后，就能在install文件夹找到我们需要的编译后的文件\n\n\nPCL源码编译VTK编译好后就可以开始PCL源码的编译，我们用上面编译好的VTK文件替换掉PCL自带的VTK文件\n\n\n至于其他的第三方库文件，我们就用它自带的就行\nPCL原来自带的编译后的文件可以直接删掉就行\n\n\n然后就在这新建source、build、install三个文件夹，开始CMake。当然这只是我个人的喜好，完全可以在别的地方编译生成PCL源码，到时候把前面配的环境变量根据自己编译生成的代码的位置改好对应起来就行。\n\n\n跟之前一样，先去下载PCL源码解压到source中\n找到之前PCL官方的GitHub https://github.com/PointCloudLibrary/pcl ，找到master-&gt;Tags-&gt;pcl1.12.1，这里的pcl版本对应你要编译的pcl版本。\n\n\n选择之后界面提供的就是对应版本的pcl源码，点击下载即可。\n\n\n源码解压好之后先别急，先在解压后的文件的cmake目录里找到“pcl_find_boost.cmake”这个文件。\n\n\n编辑该文件，给出Boost的lib和include文件夹所在位置\n\n\n#增加下面两行代码set(Boost_LIBRARY_DIR E:/PCL_1.12.1/3rdParty/Boost/lib)set(Boost_INCLUDE_DIR E:/PCL_1.12.1/3rdParty/Boost/include/boost-1_78)\n\n之后就跟之前VTK的编译过程一样了，打开CMake的GUI界面，配置好source和build位置，然后Configure\n第一次编译还是先改install的位置，然后发现说EIGEN的路径没找到，所以我们也给它配置一下，再点Configure\n\n\n配置FLANN文件位置\n\n\nOPENNI2的路径他自己找到了给我省事了，Qt6文件夹路径还是没找到，我就自己给他配一下\n\n\n再确认一下VTK的路径，WITH_QT的版本\n\n\n然后选择PCL要生成的模块，这个新电脑没有GPU我就先没选GPU模块，选择all_in_one_installer就会生成一个官方那种的安装包，会根据我们的配置进行打包，之后还要在其他地方用这套配置直接用我们自己生成的all_in_one_installer安装即可。有些模块没选，到时候有需要的话可以再CMake，然后把需要的模块选上，然后在VS生成就行，不需要再配之前的路径了，因为上面那些选择已经记录在build文件中的cmake文件里了。\n\n\n之后就是一路Configure，直到所有选项全白了，之后再Generate，然后Open Project打开VS，找到解决方案中的CMakePredefinedTargets，右键ALL_BUILD生成。\n\n\n生成完再右键INSTALL生成。\n\n\n搞定后就可以看到install中已经得到我们所需的编译好的文件。\n\n\n这里要反思一下，之前CMake编译的时候，之所以找不到Eigen、FLANN，需要我手动添加，原因在于我在新电脑上配置的时候没有把这两个的路径加到环境变量里，你像OPENNI2因为它安装的时候自动配好了环境变量，所以CMake能直接找到，Qt6也是因为没有在环境变量里配置所以总是找不到，需要我手动配置。\n然后因为我编译好的PCL源码路径发生了改变，所以环境变量的路径，在VS中配置的路径，也要稍微改一下。当然，你可以直接把这些新编译好的文件就放在之前VS配置的那个路径里，这样就不用变了。不过还有VTK的路径，之前自带的VTK文件夹名字里是9.1，现在变成9.2了也要改一下。\n环境变量\n\n\n头文件位置\n\n\n\n\nlib库位置\n\n\n还有新编译生成的lib文件名也都是从之前的9.1变成9.2了，也要重新导入一下，把vtk9.1的lib都换成vtk9.2的lib。\n\n\npcl_commond.libpcl_featuresd.libpcl_filtersd.libpcl_iod.libpcl_io_plyd.libpcl_kdtreed.libpcl_keypointsd.libpcl_mld.libpcl_octreed.libpcl_outofcored.libpcl_peopled.libpcl_recognitiond.libpcl_registrationd.libpcl_sample_consensusd.libpcl_searchd.libpcl_segmentationd.libpcl_stereod.libpcl_surfaced.libpcl_trackingd.libpcl_visualizationd.liblibboost_atomic-vc142-mt-gd-x64-1_78.liblibboost_bzip2-vc142-mt-gd-x64-1_78.liblibboost_chrono-vc142-mt-gd-x64-1_78.liblibboost_container-vc142-mt-gd-x64-1_78.liblibboost_context-vc142-mt-gd-x64-1_78.liblibboost_contract-vc142-mt-gd-x64-1_78.liblibboost_coroutine-vc142-mt-gd-x64-1_78.liblibboost_date_time-vc142-mt-gd-x64-1_78.liblibboost_exception-vc142-mt-gd-x64-1_78.liblibboost_filesystem-vc142-mt-gd-x64-1_78.liblibboost_graph-vc142-mt-gd-x64-1_78.liblibboost_graph_parallel-vc142-mt-gd-x64-1_78.liblibboost_iostreams-vc142-mt-gd-x64-1_78.liblibboost_json-vc142-mt-gd-x64-1_78.liblibboost_locale-vc142-mt-gd-x64-1_78.liblibboost_log-vc142-mt-gd-x64-1_78.liblibboost_log_setup-vc142-mt-gd-x64-1_78.liblibboost_math_c99-vc142-mt-gd-x64-1_78.liblibboost_math_c99f-vc142-mt-gd-x64-1_78.liblibboost_math_c99l-vc142-mt-gd-x64-1_78.liblibboost_math_tr1-vc142-mt-gd-x64-1_78.liblibboost_math_tr1f-vc142-mt-gd-x64-1_78.liblibboost_math_tr1l-vc142-mt-gd-x64-1_78.liblibboost_mpi-vc142-mt-gd-x64-1_78.liblibboost_nowide-vc142-mt-gd-x64-1_78.liblibboost_numpy38-vc142-mt-gd-x64-1_78.liblibboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_program_options-vc142-mt-gd-x64-1_78.liblibboost_python38-vc142-mt-gd-x64-1_78.liblibboost_random-vc142-mt-gd-x64-1_78.liblibboost_regex-vc142-mt-gd-x64-1_78.liblibboost_serialization-vc142-mt-gd-x64-1_78.liblibboost_system-vc142-mt-gd-x64-1_78.liblibboost_test_exec_monitor-vc142-mt-gd-x64-1_78.liblibboost_thread-vc142-mt-gd-x64-1_78.liblibboost_timer-vc142-mt-gd-x64-1_78.liblibboost_type_erasure-vc142-mt-gd-x64-1_78.liblibboost_unit_test_framework-vc142-mt-gd-x64-1_78.liblibboost_wave-vc142-mt-gd-x64-1_78.liblibboost_wserialization-vc142-mt-gd-x64-1_78.liblibboost_zlib-vc142-mt-gd-x64-1_78.libflann-gd.libflann_cpp-gd.libflann_cpp_s-gd.libflann_s-gd.libOpenNI2.libqhullcpp_d.libqhullstatic_d.libqhullstatic_rd.libqhull_rd.libvtkcgns-9.2d.libvtkChartsCore-9.2d.libvtkCommonColor-9.2d.libvtkCommonComputationalGeometry-9.2d.libvtkCommonCore-9.2d.libvtkCommonDataModel-9.2d.libvtkCommonExecutionModel-9.2d.libvtkCommonMath-9.2d.libvtkCommonMisc-9.2d.libvtkCommonSystem-9.2d.libvtkCommonTransforms-9.2d.libvtkDICOMParser-9.2d.libvtkDomainsChemistry-9.2d.libvtkDomainsChemistryOpenGL2-9.2d.libvtkdoubleconversion-9.2d.libvtkexodusII-9.2d.libvtkexpat-9.2d.libvtkFiltersAMR-9.2d.libvtkFiltersCore-9.2d.libvtkFiltersExtraction-9.2d.libvtkFiltersFlowPaths-9.2d.libvtkFiltersGeneral-9.2d.libvtkFiltersGeneric-9.2d.libvtkFiltersGeometry-9.2d.libvtkFiltersHybrid-9.2d.libvtkFiltersHyperTree-9.2d.libvtkFiltersImaging-9.2d.libvtkFiltersModeling-9.2d.libvtkFiltersParallel-9.2d.libvtkFiltersParallelImaging-9.2d.libvtkFiltersPoints-9.2d.libvtkFiltersProgrammable-9.2d.libvtkFiltersSelection-9.2d.libvtkFiltersSMP-9.2d.libvtkFiltersSources-9.2d.libvtkFiltersStatistics-9.2d.libvtkFiltersTexture-9.2d.libvtkFiltersTopology-9.2d.libvtkFiltersVerdict-9.2d.libvtkfmt-9.2d.libvtkfreetype-9.2d.libvtkGeovisCore-9.2d.libvtkgl2ps-9.2d.libvtkglew-9.2d.libvtkGUISupportQt-9.2d.libvtkGUISupportQtQuick-9.2d.libvtkGUISupportQtSQL-9.2d.libvtkhdf5-9.2d.libvtkhdf5_hl-9.2d.libvtkImagingColor-9.2d.libvtkImagingCore-9.2d.libvtkImagingFourier-9.2d.libvtkImagingGeneral-9.2d.libvtkImagingHybrid-9.2d.libvtkImagingMath-9.2d.libvtkImagingMorphological-9.2d.libvtkImagingSources-9.2d.libvtkImagingStatistics-9.2d.libvtkImagingStencil-9.2d.libvtkInfovisCore-9.2d.libvtkInfovisLayout-9.2d.libvtkInteractionImage-9.2d.libvtkInteractionStyle-9.2d.libvtkInteractionWidgets-9.2d.libvtkIOAMR-9.2d.libvtkIOAsynchronous-9.2d.libvtkIOCesium3DTiles-9.2d.libvtkIOCGNSReader-9.2d.libvtkIOChemistry-9.2d.libvtkIOCityGML-9.2d.libvtkIOCONVERGECFD-9.2d.libvtkIOCore-9.2d.libvtkIOEnSight-9.2d.libvtkIOExodus-9.2d.libvtkIOExport-9.2d.libvtkIOExportGL2PS-9.2d.libvtkIOExportPDF-9.2d.libvtkIOGeometry-9.2d.libvtkIOHDF-9.2d.libvtkIOImage-9.2d.libvtkIOImport-9.2d.libvtkIOInfovis-9.2d.libvtkIOIOSS-9.2d.libvtkIOLegacy-9.2d.libvtkIOLSDyna-9.2d.libvtkIOMINC-9.2d.libvtkIOMotionFX-9.2d.libvtkIOMovie-9.2d.libvtkIONetCDF-9.2d.libvtkIOOggTheora-9.2d.libvtkIOParallel-9.2d.libvtkIOParallelXML-9.2d.libvtkIOPLY-9.2d.libvtkIOSegY-9.2d.libvtkIOSQL-9.2d.libvtkioss-9.2d.libvtkIOTecplotTable-9.2d.libvtkIOVeraOut-9.2d.libvtkIOVideo-9.2d.libvtkIOXML-9.2d.libvtkIOXMLParser-9.2d.libvtkjpeg-9.2d.libvtkjsoncpp-9.2d.libvtkkissfft-9.2d.libvtklibharu-9.2d.libvtklibproj-9.2d.libvtklibxml2-9.2d.libvtkloguru-9.2d.libvtklz4-9.2d.libvtklzma-9.2d.libvtkmetaio-9.2d.libvtknetcdf-9.2d.libvtkogg-9.2d.libvtkParallelCore-9.2d.libvtkParallelDIY-9.2d.libvtkpng-9.2d.libvtkpugixml-9.2d.libvtkRenderingAnnotation-9.2d.libvtkRenderingContext2D-9.2d.libvtkRenderingContextOpenGL2-9.2d.libvtkRenderingCore-9.2d.libvtkRenderingFreeType-9.2d.libvtkRenderingGL2PSOpenGL2-9.2d.libvtkRenderingHyperTreeGrid-9.2d.libvtkRenderingImage-9.2d.libvtkRenderingLabel-9.2d.libvtkRenderingLICOpenGL2-9.2d.libvtkRenderingLOD-9.2d.libvtkRenderingOpenGL2-9.2d.libvtkRenderingQt-9.2d.libvtkRenderingSceneGraph-9.2d.libvtkRenderingUI-9.2d.libvtkRenderingVolume-9.2d.libvtkRenderingVolumeOpenGL2-9.2d.libvtkRenderingVtkJS-9.2d.libvtksqlite-9.2d.libvtksys-9.2d.libvtkTestingRendering-9.2d.libvtktheora-9.2d.libvtktiff-9.2d.libvtkverdict-9.2d.libvtkViewsContext2D-9.2d.libvtkViewsCore-9.2d.libvtkViewsInfovis-9.2d.libvtkViewsQt-9.2d.libvtkWrappingTools-9.2d.libvtkzlib-9.2d.lib\n\n至此，PCL+VS+QT的配置告一段落，可以通过VTK在QT的ui界面显示PCL点云数据了\n多提一嘴，QVTKOpenGLNativeWidget继承自Qt的QOpenGLWidget，所以用的时候记得Qt组件里选上Qt OpenGLWidget\n\n\n后记这些编译好的文件可以直接拿去用，换电脑的时候也不用重新编译一遍，只需要从旧电脑把这些编译好的文件拷过去，配好路径就行了。这样搞害怕路径什么的有问题的话，最保险的办法就是之前说的，编译PCL的时候选上all_in_one_installer，然后用这个生成的安装器，去新电脑上安一下就行。\n","categories":["教程"],"tags":["PCL"]},{"title":"OCC7.6+VS2022配置","url":"/2023/03/08/OCC7.6-VS2022-config/","content":"OCC安装与编译安装OCC安装很简单，就是去官网https://dev.opencascade.org/ 下载安装包安装即可。\n这里用的是OCC7.6版本。\n\n\n注意：安装的时候路径不要有空格和汉字。\nVS2022编译v142的OCC安装之后得到的是OCC的编译前的资源文件，而想要使用OCC提供的方法还需要将这些文件进行编译。即编译后得到的文件才是我们使用OCC所必须的。\n这里我安装的VS版本为2022，其默认的生成工具是v143，而OCC7.6最新支持的生成工具是v142，所以需要稍微操作一下，使VS2022能编译OCC。\n需要注意的是，因为要用到v142生成工具，肯定要保证VS安装了v142的生成工具，没安的话打开Visual Studio Installer安一下即可。\n\n\n下面是OCC部分编译前的一些操作：打开安装目录下 \\opencascade-7.6.0 目录下的custom.bat，将其中要求的vcvarsall.bat文件所在路径填写完整，该路径跟VS安装的位置有关，下图我的路径配置。题外话，推荐安装一个”notepad++“，轻量级代码编辑器，很好用。\n\n\n如果实在不知道在哪，可以安装一个软件”everything“，用它来查找vcvarsall.bat的位置即可\n\n\n之后，还是在 \\opencascade-7.6.0 目录下，打开env.bat，在图示位置添加：set “VCVER=vc143”\n\n\n再打开 \\opencascade-7.6.0\\adm\\msvc目录下，复制一份vc142并重命名为vc143，这就是前面提到的，OCC7.6还没有对应的2022版本（vc143）\n\n\n补充：最近在win11新电脑上配的时候发现只配上面几步，在执行后面双击目录 \\opencascade-7.6.0下的msvc.bat文件时，没有打开对应的sln文件。所以在这里再加一步，在安装目录下的 \\opencascade-7.6.0文件夹，找到msvc.bat，编辑该文件，将第5行的”%1”和”%2”两个参数分别改为”vc143”和”win64”，如下图。改完保存退出。\n\n\n至此准备工作结束，可以用VS2022编译OCC7.6了\n双击刚才编辑完的msvc.bat，它会根据前面的配置打开对应版本的OCCT.sln，打开后会需要确认是否升级平台工具集，记得选择”无升级“。\n\n\n之后找到“解决方案资源管理器”，右键“解决方案”，选择“生成解决方案”即可\n\n\n等待VS编译完成\n\n\n编译完成后生成的文件在 \\opencascade-7.6.0\\win64\\vc14 目录下\n\n\n其中的bind文件夹、libd文件夹中的文件是我们使用OCC所必需的的文件。一般是bin文件夹和lib文件夹，不过在OCC这里是bind和libd，应该是分别表示bin和lib的debug版本。因为我一直用的debug版本调试，找的教程也都是说配bind和libd的，不太清楚这个bin和lib是不是在release版本下用的，等之后如果用到release调试的时候试一下看看，等试过之后再来补充。\nlibd文件夹，存放程序运行时所需要的lib文件，lib文件是指程序库（library）文件，也称为静态链接库（static library），它包含了一组可在程序中共享的函数和资源的代码。\nbind文件夹，存放运行lib时所必需的的dll文件，DLL（Dynamic Link Library）是一种可执行文件格式，它包含一组可在多个程序中共享的函数和资源。它通常被用于在 Windows 操作系统中实现共享库和插件的功能。一个 DLL 文件可以包含多个函数和资源，其他程序可以通过动态链接库（Dynamic Link Library）的方式调用 DLL 文件中的函数。\nVS中配置OCC环境前面也提到，我们所需的bind文件夹和libd文件夹生成好了之后，就可以配置在VS中使用OCC所需的一些属性，像OCC、PCL、VTK这种C++的库，其项目属性配置基本都是一致的，基本就是三步走。\n第一步，将dll文件所在路径，在OCC这里即是上述提到的bind文件夹路径，添加到系统环境变量Path中\n有时候更改完环境变量之后可能需要重启一下电脑才能生效。\n\n\n再补充一点，上面加的这个环境变量只是最基本的，有时候程序调的OCC函数可能用到它自带的其他第三方库函数，这时可能会报缺少xxx.dll文件的错误，这时候就用”everything“查找该文件名，然后把该文件所在路径加到上面的环境变量里就行。比如这里程序运行时提示我缺少”tbb_debug.dll”，我就去搜这个文件，发现有很多该文件，选一个觉得最靠谱的文件路径添加到上面环境变量Path里就行。我这里看这个文件夹路径是vc14，感觉应该是适配vc14x版本的dll文件，我就选了这个。\n\n\n之后在我们所建的项目中，在解决方案栏中，右键点击项目，选择属性一栏\n\n\n在属性页找到 调试—&gt;环境，输入 PATH=%PATH% ，使调试时能找到环境变量中bind所在路径，进一步能找到dll文件\n\n\n第二步，在属性页中找到 链接器—&gt;常规—&gt;附加库目录，将libd所在路径添加进去，方便编译器编译时能找到lib文件\n\n\n再找到 链接器—&gt;输入—&gt;附加依赖项，将libd文件夹下所有的lib文件添加进去\n\n\n至于如何快速取得文件夹下所有lib文件列表，找到目标文件夹libd，在该文件夹下“shift+右键”，选择 Powershell打开\n\n\n在该命令窗口输入 ls *.lib -n，即可得到该文件夹下所有lib结尾的文件列表，其中-n是指定列出来的信息只包含文件名和后缀，可以自己试试不带-n的结果\n\n\n第三步，在属性页找到 C/C++—&gt;常规—&gt;附加库包含目录，将OCC的头文件路径添加进去，该路径为安装目录下 \\opencascade-7.6.0\\inc ，其中存放的是在使用OCC时所需的所有头文件\n\n\n上面三步无关顺序，能配完就行。\n至此，就可以在C++程序中使用OCC提供的各种功能啦，开始愉快编程啦~\nVS属性表的使用新建属性表上面配置的VS属性页只针对当前项目有效，如果要新建项目并使用OCC，需要将上面的三个步骤再配置一遍，很不方便。而使用VS属性表就可以实现只用配置一次，下次直接拿来用即可的效果\n在VS窗口上边菜单栏找到 视图—&gt;其他窗口—&gt;属性管理器\n\n\n选择之后，属性管理器就会出现在解决方案管理器旁边的位置\n\n\n找到自己需要的版本，比如我一般使用Debug|x64版本，我就在对应项旁边右键，选择 添加新项目属性表\n\n\n因为是给OCC配置的属性表，就叫OCC.props吧，至于这个位置，它默认是建在当前项目所在的文件夹中，可以自定义一个文件夹位置，就光用来存这种属性表，当时候项目中需要哪个属性表，就直接去那个文件夹中好就行。\n\n\n在建好的属性表里，把前面第二步、第三步里，关于“C/C++”和“链接器”选项中的部分复现一下即可，简单概括就是“C/C++”的附加包含目录里添加头文件目录，”链接器“的附加库目录里添加lib库路径、附加依赖项里把lib库中的所有lib添加进去。\n\n\n可以看到这个属性表里没有第一步中“调试”选项，所以在 调试—&gt;环境，输入 PATH=%PATH% 这一步还是需要在具体的新建项目中配置一下，步骤参考前面第一步。\n使用已有属性表上面属性表建好之后，下次新的项目要是用OCC的时候，直接把这个属性表引入即可\n在属性管理器，要是用的对应版本处右键点击，选择 添加现有属性页\n\n\n找到之前建好的属性表，添加即可\n\n\n需要注意的是，通过这种添加现有项方式加入的属性表并不是把之前建的表复制了一个放在新项目里，新项目中是找不到这个属性表文件的，它实际还是之前建的那个属性表，只是编译器把它链接了过来，使我们可以使用该表的配置。这也意味着你如果在对这个属性表进行改动，会影响到所有使用该属性表的项目，一定要注意。\n\n\n当然，其实也可以将之前建的属性表复制一个到新建项目的文件夹里，然后在添加现有项时添加当前这一个，这样就可以随便改了，也不会对别的项目有什么影响。\n以上。\n","categories":["教程"],"tags":["OCC"]},{"title":"Qt项目的文件结构","url":"/2023/03/16/Qt-Project-Structure/","content":"之前新建Qt项目看它那个代码，总是感觉怪怪的，直到今天在问ChatGPT关于Qt6和OCC7.6的配合时，它给出了一个Qt+OCC的显示模型的例程，看了这个之后我感觉对Qt程序的创建执行才算理解了一点。\n#include &lt;QApplication&gt;#include &lt;QWidget&gt;#include &lt;QVBoxLayout&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsView&gt;#include &lt;OpenGl_GraphicDriver.hxx&gt;#include &lt;V3d_View.hxx&gt;#include &lt;AIS_InteractiveContext.hxx&gt;#include &lt;BRepPrimAPI_MakeSphere.hxx&gt;int main(int argc, char *argv[])&#123;    // 初始化 Qt 应用程序    QApplication app(argc, argv);    // 创建主窗口    QWidget window;    window.setWindowTitle(&quot;OCC and Qt Integration&quot;);    window.resize(640, 480);    // 创建图形场景和视图    QGraphicsScene scene;    QGraphicsView view(&amp;scene);    view.setViewport(new QOpenGLWidget());  // 使用 OpenGL 视口    // 创建 OCC 视图    Handle(OpenGl_GraphicDriver) aDriver = new OpenGl_GraphicDriver();    Handle(V3d_View) aView = new V3d_View(aDriver);    Handle(AIS_InteractiveContext) aContext = new AIS_InteractiveContext(aView);    aView-&gt;SetContext(aContext);    // 创建 OCC 对象并将其添加到场景中    BRepPrimAPI_MakeSphere aSphere(50);    TopoDS_Shape aShape = aSphere.Shape();    Handle(AIS_Shape) anAisShape = new AIS_Shape(aShape);    aContext-&gt;Display(anAisShape, Standard_True);    aContext-&gt;UpdateCurrentViewer();    // 将 OCC 视图绑定到 Qt 视图中    aView-&gt;SetWindow(view.winId());    aView-&gt;MustBeResized();    view.show();    // 将 Qt 视图添加到主窗口中    QVBoxLayout layout;    layout.addWidget(&amp;view);    window.setLayout(&amp;layout);    window.show();    // 运行 Qt 应用程序    return app.exec();&#125;\n\n重点不在如何显示OCC模型，而在于该程序是标准的从int main（）主函数来构建程序的写法。从中我们可以加深对Qt代码的真实执行过程的理解。\n将上面的代码与下面新建的Qt项目所给出的int main（）比较，可以看到只有寥寥几行代码，当初被下面这几行代码整蒙了，寻思这是干嘛呢，但其实对照上面的代码来分析就比较好读懂了。上面把定义窗口组件的代码直接写在主函数main中，而下面这种其实就是把窗口定义之类的代码写到了类里，这里这个类是OCC_QT，然后OCC_QT w;这句其实是调用了该类的默认构造函数，通过构造函数的执行，来实现了窗口的创建等功能。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n下面来看OCC_QT这个类，先看头文件OCC_QT.h，这里就是类的声明，其中构造函数OCC_QT(QWidget *parent = nullptr);\n#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include &quot;ui_OCC_QT.h&quot;class OCC_QT : public QMainWindow&#123;    Q_OBJECTpublic:    OCC_QT(QWidget *parent = nullptr);    ~OCC_QT();private:    Ui::OCC_QTClass ui;&#125;;\n\n我们可以看到它引入了一个头文件“ui_OCC_QT.h”，这里面就是窗口组件相关的代码\n具体来看“ui_OCC_QT.h”，这里面定义了各种窗口组件的代码，包括页面组件的声明、布局的位置等。\n/********************************************************************************** Form generated from reading UI file &#x27;OCC_QT.ui&#x27;**** Created by: Qt User Interface Compiler version 6.4.0**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_OCC_QT_H#define UI_OCC_QT_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QMainWindow&gt;#include &lt;QtWidgets/QMenuBar&gt;#include &lt;QtWidgets/QStatusBar&gt;#include &lt;QtWidgets/QToolBar&gt;#include &lt;QtWidgets/QWidget&gt;QT_BEGIN_NAMESPACEclass Ui_OCC_QTClass&#123;public:    QMenuBar *menuBar;    QToolBar *mainToolBar;    QWidget *centralWidget;    QStatusBar *statusBar;    void setupUi(QMainWindow *OCC_QTClass)    &#123;        if (OCC_QTClass-&gt;objectName().isEmpty())            OCC_QTClass-&gt;setObjectName(&quot;OCC_QTClass&quot;);        OCC_QTClass-&gt;resize(600, 400);        menuBar = new QMenuBar(OCC_QTClass);        menuBar-&gt;setObjectName(&quot;menuBar&quot;);        OCC_QTClass-&gt;setMenuBar(menuBar);        mainToolBar = new QToolBar(OCC_QTClass);        mainToolBar-&gt;setObjectName(&quot;mainToolBar&quot;);        OCC_QTClass-&gt;addToolBar(mainToolBar);        centralWidget = new QWidget(OCC_QTClass);        centralWidget-&gt;setObjectName(&quot;centralWidget&quot;);        OCC_QTClass-&gt;setCentralWidget(centralWidget);        statusBar = new QStatusBar(OCC_QTClass);        statusBar-&gt;setObjectName(&quot;statusBar&quot;);        OCC_QTClass-&gt;setStatusBar(statusBar);        retranslateUi(OCC_QTClass);        QMetaObject::connectSlotsByName(OCC_QTClass);    &#125; // setupUi    void retranslateUi(QMainWindow *OCC_QTClass)    &#123;        OCC_QTClass-&gt;setWindowTitle(QCoreApplication::translate(&quot;OCC_QTClass&quot;, &quot;OCC_QT&quot;, nullptr));    &#125; // retranslateUi&#125;;namespace Ui &#123;    class OCC_QTClass: public Ui_OCC_QTClass &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_OCC_QT_H\n\n补充一点关于上面部分代码的理解：\nnamespace Ui &#123;    class OCC_QTClass: public Ui_OCC_QTClass &#123;&#125;;&#125; // namespace Ui\n\n这段代码声明了一个命名空间Ui，并在里面定义了一个新的类OCC_QTClass来继承上面具体实现功能的类Ui_OCC_QTClass，然后OCC_QT.h中，声明窗口类的时候：Ui::OCC_QTClass ui;，用的也是这个新建的OCC_QTClass类，至于为什么要这么干，我猜可能是进一步提高代码的封装性，提高项目的安全性。\n最后再来看OCC_QT.cpp，这里面就是OCC_QT类的各种函数功能的具体实现。这里别看这个构造函数就一句话，当时我也懵了一下，寻思这怎么就能把窗口之类的东西都弄出来了？现在懂了，就像上面说的，窗口之类的代码实现实际上都在上面ui_OCC_QT.h里，所以cpp这里的构造函数只需要调用一下setupUi（）函数，把窗口布局的代码运行一下即可。\n#include &quot;OCC_QT.h&quot;OCC_QT::OCC_QT(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);&#125;OCC_QT::~OCC_QT()&#123;&#125;\n\n分析完这个OCC_QT类，再来看主函数的代码就很好理解了，调用OCC_QT的构造函数将窗口组件都定义好了，之后再使用w.show()函数显示在w这个类中声明与定义的窗口即可。其中这个show()函数我们注意到并没有定义在OCC_QT类中，它应该是继承自QMainWindow的方法。\n#include &quot;OCC_QT.h&quot;#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    OCC_QT w;    w.show();    return a.exec();&#125;\n\n最后大致总结一下新建的这个Qt项目，它在执行时所做的一些工作：\n定义了UI界面类Ui_OCC_QTClass，写在“ui_OCC_QT.h”中，其中有窗口各种组件的声明和布局定义，与槽函数的连接也默认写在这里面，又定义了一个新的类OCC_QTCLass继承Ui_OCC_QTClass作为访问接口。定义了窗口类OCC_QT，声明部分写在“OCC_QT.h”里，声明了OCC_QTClass类的对象ui，之后的槽函数声明也写在该文件里；定义部分写在“OCC_QT.cpp”里，构造函数调用ui.setup（）函数对窗口组件进行实现，之后的槽函数定义也写在该文件里。\n有了上述这些类的定义，之后就是在主函数中使用，主函数main声明了OCC_QT类的对象w，并调用其构造函数，该构造函数调用OCC_QTClass的实例ui的setup函数，对窗口组件进行声明和定义，即对窗口各组件进行实现。之后再调用OCC_QT的父类QMainWindow继承来的show（）函数将窗口显示出来。\n了解了Qt项目的这些结构之后，我们对Qt项目代码的执行过程就有了基本的了解，就可以更好地编写自己的Qt项目。\n可以就依赖它给出的这种结构来写，也可以按自己想法来写不按它上面的这种结构，步骤对了就行。\n后记：槽函数的声明、定义、与信号的连接等基本步骤见后续的Qt学习笔记，想记录一下两种方式，一种是配合Qt Designer的可视化编程，一种就是纯代码开发的方式。在第一种方式里，想着用上上面说的Qt项目自带的这种文件结果，把OCC_QT.h，OCC_QT.cpp，ui_OCC_QT.h三个文件都用上。在第二中纯代码的方式里，就不要这个ui_OCC_QT.h文件了，毕竟这个文件其实是为了配合Qt Designer可视化编程而存在的，把里面的组件声明、定义等代码都放到外面来。\n","categories":["Qt学习"],"tags":["Qt"]},{"title":"更改PyCharm缓存路径","url":"/2023/03/15/PyCharm-Cache/","content":"越来越小的C盘最近C盘的空间越来越小了，于是便又开始找找有没有什么能删的垃圾文件。\n推荐一个软件“SpaceSniffer”，它可以扫描分析每个盘里面各个文件所占的大小，我用他扫描了一下我的C盘结果看到用户目录下的PyCharm文件夹里有个文件“content.dat.storage.data”有4.4个G的大小。\n\n\n网上一查是PyCharm的缓存文件，补充一下，该文件存放在Caches文件夹里，Cache一般就是指缓存文件夹，用来存缓存文件的，当时没反应过来，不过就算直到Cache放缓存文件可能也还是查一查确认一下放心。\n这个缓存文件可以直接删除。但删除并不能从根源解决问题，因为下次使用PyCharm还是会生成缓存文件，早晚还是会一点一点挤占C盘的位置，所以最好的办法就是给PyCharm换一个缓存路径。\n更换PyCharm缓存路径找到PyCharm的安装目录下的bin文件夹，如E:\\PyCharm Community Edition 2022.3.2\\bin，找到其中的idea.properties文件\n\n\n打开该文件，修改其中的四处位置，推荐用“NotePad++”打开。当然，记事本，VS Code之类的都可以。\n\n\n上面红框就是我们要修改的部分，它注释掉的语句应该是它本来默认的存放路径，不过可能因为注释掉了，所以其实并没有存在这个路径中，但还是在C盘建了别的文件夹来放这些文件。我们将这些路径改为我们想让它存放的路径。我在PyCharm的安装目录下新建了一个”.PyCharmCE2022.3”文件夹，并将这个路径改到了该文件夹下。\n\n修改config路径\n\n# idea.config.path=$&#123;user.home&#125;/.PyCharmCE/configidea.config.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/config\n\n\n修改system路径\n\n# idea.system.path=$&#123;user.home&#125;/.PyCharmCE/systemidea.system.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/system\n\n\n修改plugins路径\n\n# idea.plugins.path=$&#123;idea.config.path&#125;/pluginsidea.plugins.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/plugins\n\n\n修改log路径\n\n# idea.log.path=$&#123;idea.system.path&#125;/logidea.log.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/log\n\n之后重启PyCharm，它会自动检测之前的配置所在位置，并提示导入之前的配置\n\n\n点击ok就行了，然后就可以把之前C盘里的都删掉了。\n不过因为前面提到的，它配置文件里那四个部分都默认是注释掉的，所以它实际存放的位置是在C盘别的位置，我的位置是在：\nC:\\Users\\REINHARDT\\AppData\\Local\\JetBrains\\PyCharmCE2022.3C:\\Users\\REINHARDT\\AppData\\Roaming\\JetBrains\\PyCharmCE2022.3\n\n不过删完那个4.4G的缓存文件之后我看这两占内存也不是很大我就没删，以防之后发现上面的配置方法有问题，我好回来找。不过一般也没问题，咬咬牙删了也没事。\n","categories":["C盘减负"],"tags":["PyCharm"]},{"title":"SpringBoot学习心得","url":"/2023/03/16/SpringBoot/","content":"前言前面写了个Vue的学习心得，马上就想起来跟Vue前端技术配合的后端技术SpringBoot好像好久没用了，感觉也需要写个Blog总结一下，不然以后真忘了无从下手就乐了。不过也不至于，当时就是照着YouTube一个教程学得，那教程还不错，大不了再看看那个视频，就是时间可能有点长。还是找时间写一写，加深一下印象吧。\n就以之前写的仓库管理系统为例，大概介绍一下项目结构，每个文件干什么的，再写写经常配合使用，操作数据的MyBatis-Plus的使用，包括自定义功能之类的。\n干脆也可以把Thymeleaf也介绍一下。\n感觉叫学习心得也不大对，我是学完了（也不对，学了一点吧），在用的时候得出的一些心得。那叫使用心得吧，也不大对，你那才用了多点功能啊。。。就当是在使用中深入学习的意思吧，就叫学习心得算了。\n","categories":["后端技术学习"],"tags":["SpringBoot","MyBatis-Plus"]},{"title":"Qt在线安装包配置国内镜像源","url":"/2023/03/20/Qt6.4-mirror-download/","content":"最近在新电脑上重新装Qt6.4，学校的网不太行，安装时总是报错，干脆找了找教程，使用Qt官方的在线安装包配合国内镜像源来安装，这里记录一下。\nQt在线安装包下载他官网的安装包找起来绕过来绕过去，这里正好记录一下。\n打开Qt官网 https://www.qt.io/ ，找到右上角的 ”Download.Try.“ 点击进入\n\n\n进入的新页面拉到最底，找到”Download Qt for open source use”部分，点击”Go open source”进入下一个界面\n\n\n在进入的新页面再往下滑，也是快划到底的地方有个”Download the Qt Online Installer” ，点击这个按钮\n\n\n本来以为这就开始下载在线安装包了，结果还是进入新页面，点击新页面的这个”Download”，就真的开始下载在线安装包了\n\n\n服了，下个在线安装包点了4个download，还都不重样，牛。\n配置国内镜像源直接使用这个在线安装包的话，因为资源服务器在国外，难免网不行导致安装时出错，干脆直接配置国内镜像源来安装。\n找到Qt在线安装的存放路径，在空白处“shift+右键”，选择“打开Powershell窗口”\n\n\n输入命令.\\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt，注意该命令前半部分，是自己下载的qt在线安装包的名字，可能不一样，根据自己的情况改一改。\n\n\n输完之后回车，会不带任何提示地打开该安装包\n\n\n之后就是正常的qt安装过程了，根据自己的需求选就行\n\n\n之后就看各自的网速了\n\n\n资源下载完之后就开始解压缩，等进度条100%，qt就算是安好了\n","categories":["教程"],"tags":["Qt"]},{"title":"Wamp安装","url":"/2023/03/21/WampServer-download/","content":"写这个也是想吐槽一下他这个网站的下载设计\n下面这个是他官方网站的主页，可以看到下面，下面那么大一个黄色按钮，还写着wamp对应的版本号，一眼看上去就是以为点这个下载\n\n\n然后点击之后就会发现没什么反应，当时还以为是要挂梯子之类的原因，结果检查这个按钮超链接的路径，发现这个按钮链接的是当前页面，也就是说点这个按钮只是不停的跳转到当前页面而已。。。\n\n\n那么真正的下载按钮在哪里呢？在黄色按钮上面的“DOWNLOADS”部分，点击“SourceForge”，就会前往真正的下载页面。而且其实读一读“DOWNLOADS”部分里的英文也确实说了让我们去”SourceForge“下载。但是吧。。。就挺搞的。。。\n\n\n下面就是真正的下载页面了，可以直接点击绿色按钮下载最新安装包即可。有其他需求的也可以去下面各个文件夹看一看，看看有没有自己需要的东西。\n\n\n补充：后面发现点击黄色按钮右下角的”changelog“也可以，会自动跳转到对应版本的下载页面，等待5s后会自动开始下载\n\n\n题外话，上面说的对应版本指的是64位、32位这个，不是指wamp版本号。因为可以看到黄色按钮明明写着3.2.6，下面小字说的却是3.3.0，然后实际安装时，安装包的版本也是3.3.0的。当然这也没什么所谓，就是吐槽一下。\n","categories":["教程"],"tags":["Wamp"]},{"title":"Qt6.4.2-PCL1.12.1-VTK9.2.6-error","url":"/2023/03/09/Qt6.4-PCL1.12.1-VTK9.2.6-error/","content":"问题描述一开始因为PCL自带一个VTK9.1环境，因为要VTK和Qt配合，去官网下了完整VTK9.2自己编译了一下，然后又在Qt项目里配了一下VTK的环境，估计是他先找到了PCL自带的VTK9.1环境，就没管我自己配的VTK9.2，导致报了个“未定义标识符VTK_UNICODE_STRING”的错\n考虑到两个VTK环境冲突的问题，就把PCL自带的那个VTK9.2的环境配置都删了一遍，结果又出现了下面的问题\n\n\n看到这个dll想到可能是因为环境变量里PCL自带的VTK9,1和自己编译的VTK9.2冲突了，忘记改了，因为程序寻找dll文件是从环境变量PATH中从头到尾在找，当找到一个对应的目录的时候它就认定在这个目录里寻找dll文件了，而不会再往下找了，应该就是因为我把PCL自带的VTK9.1的bin路径放在了自己编译的VTK9.2的bin路径之前导致的问题\n结果一看不对啊，自己编译的VTK9.2的bin路径是在上面的呀，惊了。。。\n然后我又试了试直接把PCL自带的VTK9.1的bin路径删掉，结果程序报错找不到vtk9.1d的dll了，说明程序哪里还用着pcl自带的vtk9.1 。。。\n话说pcl自带的vtk9.1有QVTKOpenGLNativeWidget吗，有的话我直接用PCL自带vtk9.1算了。。。\n去看了一下没有，然后想起来了，这个模块是要编译VTK的时候选一下配合Qt才会生成，乐，还是要用自己配的。。。\n可能是PCL一些东西配合自带的VTK才能实现，明天试试把自己编译的VTK覆盖PCL自带的VTK试一下。。。记得做好备份\n实在不行就得把PCL编译需要的东西都下一遍，然后用CMake从头编译一下来弄了。。。\n第二天继续试，把VTK覆盖试了试好像不行\n然后开始调试，看看是哪个语句的问题，发现是初始化语句的问题，因为初始化用的是qvtkwidget版本时的代码，所以可能有些问题，于是就去找了QVTKOpenGLNativeWidget版本显示点云数据的代码\n结果照着别人的代码敲还是有问题\n\n\n找了找资料发现出现这种问题一般是因为这个类没有定义，其实就是vtkGenericOpenGLRenderWindow这个类的头文件没有引入，这里不得不吐槽一下，既然头文件没引入，你上面的的没啥不报错啊。。。\n引入头文件：\n#include &lt;vtkGenericOpenGLRenderWindow.h&gt;\n\n之后该语句就不会报错了\n\n\n以为终于没问题的时候，在执行到语句\nviewer.reset(new pcl::visualization::PCLVisualizer(renderer,renderWindow,&quot;viewer&quot;, false));\n\n的时候还是报错了。\n\n\n估计还是因为弄了两个vtk导致的，可能pcl1.12和自己配的这个vtk9.2不太搭，网上查了查资料，也都是自己下一个vtk9.1自己编译一下，然后覆盖原来的pcl自带的vtkk，然后再编译PCL。\n这次就老实照这个来一遍https://blog.csdn.net/qq_40732350/article/details/125394920，他跟我想的一样，除了vtk自己编译，其他直接用pcl自带的编译好的就行，省事。\n等开完会试一下。。。\n解决经过一番尝试，我已经完全理解了。\n正确的做法就是用自己编译的vtk替代pcl自带的vtk，然后从官网下载pcl源码，然后重新编译pcl，让它和自己编译的vtk配合起来。这样既有了自己编译的vtk的Qt相关插件，又可以让pcl跟自己配的vtk适配，正常用pcl库。\n具体的步骤见“PCL编译（暂定）”\n分析复盘要使用Qt+PCL显示点云，需要用到VTK来控制Qt窗口组件来显示。而PCL自带的vtk是不含与Qt配合相关的文件的。于是，我就想着去vtk官网下一个vtk自己用cmake编译一下，选上qt6组件。也成功编译了，问题就在，我以为就是用一下这个组件，就给项目既配了PCL（自带vtk9.1）环境，又配了自己编译的vtk9.2环境，而这两个都有的情况下，编译器编译的时候会有各种冲突，除非你能精准挑出来pcl用的vtk9.1的哪部分，Qt用的vtk9.2的哪部分，然后只把这些用到的引入，其他无关的全部不要引到环境里，其实就算这样pcl和qt用的vtk的部分也可能重合，比如pcl要用9.1的vtkcommon.dll而qt要用9.2的vtkcommon.dll，所以还是不行，这样肯定冲突。\n然后你又不能直接把pcl中vtk9.1的部分直接删掉或者替换成vtk9.2的，因为这个pcl是官网提供的编译好的，它是按照vtk9.1来编译的，对这个vtk9.1肯定又依赖。\n所以，只有按上面解决办法来才是正解。而且顺便还可以配一下GPU模块。\n","categories":["问题记录"],"tags":["PCL","Qt","VTK"]},{"title":"Vue互动教程学习","url":"/2023/03/16/Vue-Interactive-Tutorial/","content":"前言Vue，易学易用，性能出色，适用场景丰富的 Web 前端框架。 \n以上为官网给出的精炼概括，之前本科实习期间的项目是用Vue+SpringBoot来前后端分离地开发一个项目，就是那会儿接触到原来还有这么个东西。但是那会儿在忙考研，对搞前端又没有兴趣，所以当时分工的时候选择了后端开发，稍微学了学SpringBoot。而对前端开发技术Vue便是毫不关心，一点没学，现在想想也有点可惜，毕竟当时实习期间那个教程我感觉挺好的，应该是有很多干货的。\n现在之所以想学Vue了，是发现想自己搞点Web项目的时候，只会后端技术完全不够，前端没有人给你写，只能去找别人的模板，然后用Thymeleaf来前后端交互，感觉不够自由，不够灵活。前端嘛，感觉还是根据自己的需求来设计比较好，到时候跟自己写的后端搭配应该也更方便些。\n当然，以上还是我的幻想，Vue还没开始学，不知道到时候设计前端的这个难度具体到底如何。美好的幻想：想要个什么样的前端界面，都能给他弄出来，不求那种花里胡哨的，就基本功能能实现，界面设计得能好看点也就心满意足了。\n下面开始Vue的学习，主要是看Vue的官网 https://cn.vuejs.org/\n里面有比较详细的介绍了Vue的基本组件等。。。应该是吧，我也还没仔细看\n这里主要是想介绍一下官网提供的一个互动教程https://cn.vuejs.org/tutorial/#step-1\n该教材支持边教边实践，左边教着内容，右边给你地方写代码让你试。下面的内容主要围绕跟着这个互动教程学习过程的心得。\n互动教程声明式渲染Attribute绑定Attribute绑定，v-bind指令，拿div举例&lt;div v-bind:id=&quot;dynamicID&quot;&gt;&lt;/div&gt;，其中的v-bind一简写，就变成了&lt;div :id=&quot;dynamicID&quot;&gt;&lt;/div&gt;，就剩个冒号了，这一般还真不知道是个什么意思，也没法查起。\n事件监听事件监听，v-on指令，拿button举例&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;，可以简写为&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;，这种@的写法我感觉还真见过不少，当时没学不知道是什么意思，原来是事件监听v-on的缩写。\nVue脚手架写这个blog另一个很大的原因是，就是想找个地方感慨一下这个事儿。\n当时本科实习期间老师还是教着我们用Vue Cli这个脚手架，到现在我再回头想学Vue想着看看Cli脚手架的时候发现它已经进入维护状态，官方不再推荐了。现在官方推荐了新的Vue脚手架Vite，该脚手架也是Vue的作者写的。\n就是想感慨一下这技术发展是真快啊感觉，不过前面也说了，实习那会儿Vue我就基本没学，更不用说这个Vue Cli脚手架了，直接转去学新的脚手架Vite毫无负担，血赚，哎嘿。但没仔细学当时的Vue教程，血亏，嘤。\n话说这样我之前搭的Vue Cli脚手架就白搭了，等着看看Vite脚手架的搭建有没有什么主意的地方，有的好也可以写个Blog，写写使用心得之类的，到时候就把这部分内容移过去。\n","categories":["前端技术学习"],"tags":["Vue"]},{"title":"Hello World","url":"/2021/03/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n\n\n\n\n\n\n37bc485ba4a3b31d02a3ba25267af1715187b72c\n\n\n\n\n\n\n\n"}]
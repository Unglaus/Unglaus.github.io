<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-18T02:33:26.409Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dr.Unglaus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QT+PCL+VTK点云可视化</title>
    <link href="http://example.com/2024/04/18/QT-PCL-VTK-visualization/"/>
    <id>http://example.com/2024/04/18/QT-PCL-VTK-visualization/</id>
    <published>2024-04-18T02:14:21.000Z</published>
    <updated>2024-04-18T02:33:26.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QT-VTK-PCL显示点云"><a href="#QT-VTK-PCL显示点云" class="headerlink" title="QT+VTK+PCL显示点云"></a>QT+VTK+PCL显示点云</h2><p>VTK9.0版本之后删除了**<code>QVTKWidget</code><strong>，VTK9.0版本之前，还是有用</strong><code>QVTKWidget</code>**写的代码，一般也是配合Qt5</p><p>VTK9.0版本之后，配合Qt6一般使用**<code>QVTKOpenGLNativeWidget</code>**</p><h3 id="QT5"><a href="#QT5" class="headerlink" title="QT5"></a>QT5</h3><p>这里是配合**<code>QVTKWidget</code>**的代码</p><p><strong>ui_mainwindow.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qvtkwidget.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ui_MainWindow</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>...<br>QVTKWidget *qvtkWidget;<br>...<br>&#125;<br><span class="hljs-keyword">namespace</span> Ui &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>:</span> <span class="hljs-keyword">public</span> Ui_MainWindow &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>mainwindow.h</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/shared_ptr.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br>    <br>    ...<br>    <br><span class="hljs-keyword">private</span>:<br>    Ui::MainWindow *ui;<br>    boost::<span class="hljs-built_in">shared_ptr</span>&lt;pcl::visualization::PCLVisualizer&gt; viewer;<br>    <br>...<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>mainwindow.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vtkRenderWindow.h&gt;</span></span><br><br><span class="hljs-comment">//初始化PCL显示控件</span><br>viewer.reset(<span class="hljs-keyword">new</span> pcl::visualization::PCLVisualizer(<span class="hljs-string">&quot;viewer&quot;</span>, <span class="hljs-literal">false</span>));<br>ui-&gt;qvtkWidget-&gt;SetRenderWindow(viewer-&gt;getRenderWindow());<br>viewer-&gt;setupInteractor(ui-&gt;qvtkWidget-&gt;GetInteractor(), ui-&gt;qvtkWidget-&gt;GetRenderWindow());<br>ui-&gt;qvtkWidget-&gt;update();<br></code></pre></td></tr></table></figure><h3 id="QT6"><a href="#QT6" class="headerlink" title="QT6"></a>QT6</h3><p>这里是配合**<code>QVTKOpenGLNativeWidget</code>**的代码</p><p><strong>ui_mainwindow.h</strong></p><p>这里就是把<code>QVTKWidget</code>换成了<code>QVTKOpenGLNativeWidget</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qvtkopenglnativewidget.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ui_MainWindow</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>...<br>QVTKOpenGLNativeWidget *qvtkopenglnativewidget;<br>...<br>&#125;<br><span class="hljs-keyword">namespace</span> Ui &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>:</span> <span class="hljs-keyword">public</span> Ui_MainWindow &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>mainwindow.h</code></strong></p><p>这里都是一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/shared_ptr.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br>    <br>    ...<br>    <br><span class="hljs-keyword">private</span>:<br>    Ui::MainWindow *ui;<br>    boost::<span class="hljs-built_in">shared_ptr</span>&lt;pcl::visualization::PCLVisualizer&gt; viewer;<br>    <br>...<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>mainwindow.cpp</code></strong></p><p>主要区别在这里</p><p>区别于上面的版本，<code>render</code>和<code>renderwindow</code>需要初始化，保证不是空指针；</p><p><code>qvtkwidget</code>用的<code>GetInteractor()</code>、<code>GetRenderWindow()</code>方法在<code>qvtkopenglnativewidget</code>中替换为了<code>interactor()</code>、<code>renderWindow()</code>方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vtkRenderWindow.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vtkGenericOpenGLRenderWindow.h&gt;</span></span><br><br><span class="hljs-comment">//初始化PCL显示控件</span><br><span class="hljs-keyword">auto</span> renderer = vtkSmartPointer&lt;vtkRenderer&gt;::New();<br><span class="hljs-keyword">auto</span> renderWindow = vtkSmartPointer&lt;vtkGenericOpenGLRenderWindow&gt;::New();<br>renderWindow-&gt;AddRenderer(renderer.Get());<br>viewer.reset(<span class="hljs-keyword">new</span> pcl::visualization::PCLVisualizer(renderer, renderWindow, <span class="hljs-string">&quot;viewer&quot;</span>, <span class="hljs-literal">false</span>));<br><br>ui-&gt;qvtkopenglnativewidget-&gt;setRenderWindow(viewer-&gt;getRenderWindow());<br>viewer-&gt;setupInteractor(ui-&gt;qvtkopenglnativewidget-&gt;interactor(), ui-&gt;qvtkopenglnativewidget-&gt;renderWindow());<br>ui-&gt;qvtkopenglnativewidget-&gt;update();<br></code></pre></td></tr></table></figure><h4 id="PS：记录一个比较坑的点"><a href="#PS：记录一个比较坑的点" class="headerlink" title="PS：记录一个比较坑的点"></a>PS：记录一个比较坑的点</h4><img src="/2024/04/18/QT-PCL-VTK-visualization/image-20240103100103186.png" class="" title="image-20240103100103186"><p>在使用上面三句初始化的语句时，指着<code>renderWindow</code>报了个错，但实际上是因为<code>vtkGenericOpenGLRenderWindow</code>这个所需的头文件没有引入导致的，引入头文件<code>#include &lt;vtkGenericOpenGLRenderWindow.h&gt;</code>即可解决</p><p>不懂为什么它不提示<code>vtkGenericOpenGLRenderWindow</code>有问题，一般谁缺头文件就会提示谁有问题。</p><p>通过这个例子也记下来，提示指向不完整类类型”<code>xxx</code>“的时候，可能是缺了<code>xxx.h</code>的头文件，所以<code>xxx</code>才会定义不完整</p><h3 id="关于对VTK-PCL显示点云的理解"><a href="#关于对VTK-PCL显示点云的理解" class="headerlink" title="关于对VTK+PCL显示点云的理解"></a>关于对VTK+PCL显示点云的理解</h3><p>需要用到vtk的显示化窗口QVTKOpenGLNativeWidget</p><p>又用到了pcl的PCLVisualizer</p><p><strong>其中PCL可视化类PCLVisualizer负责管理数据，QVTKWidget才是真正渲染数据的地方，类似于画布。</strong></p><p>所以，可视化类一定要设置渲染窗口，即最终要把数据显示在哪里。关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">this</span>-&gt;SetRenderWindow(_viewer-&gt;getRenderWindow());<br></code></pre></td></tr></table></figure><p>有了可视化的容器，我们现在还不清楚到底怎么把数据刷到QVTKWidget上，刚才说过，PCL可视化器是管理数据的，所以，我们想显示谁就把谁添加到PCL可视化器上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">_viewer-&gt;addPointCloud(_cloud);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;QT-VTK-PCL显示点云&quot;&gt;&lt;a href=&quot;#QT-VTK-PCL显示点云&quot; class=&quot;headerlink&quot; title=&quot;QT+VTK+PCL显示点云&quot;&gt;&lt;/a&gt;QT+VTK+PCL显示点云&lt;/h2&gt;&lt;p&gt;VTK9.0版本之后删除了**&lt;code&gt;Q</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="PCL" scheme="http://example.com/tags/PCL/"/>
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
    <category term="VTK" scheme="http://example.com/tags/VTK/"/>
    
  </entry>
  
  <entry>
    <title>cpp-virtual</title>
    <link href="http://example.com/2024/03/02/cpp-virtual/"/>
    <id>http://example.com/2024/03/02/cpp-virtual/</id>
    <published>2024-03-02T03:07:24.000Z</published>
    <updated>2024-03-11T09:31:43.022Z</updated>
    
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>QString</title>
    <link href="http://example.com/2024/01/25/QString/"/>
    <id>http://example.com/2024/01/25/QString/</id>
    <published>2024-01-25T01:57:02.000Z</published>
    <updated>2024-01-29T07:24:44.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt的字符串操作–QString"><a href="#Qt的字符串操作–QString" class="headerlink" title="Qt的字符串操作–QString"></a>Qt的字符串操作–QString</h1><h2 id="从一段字符串中提取文件名–QFileInfo-fileName"><a href="#从一段字符串中提取文件名–QFileInfo-fileName" class="headerlink" title="从一段字符串中提取文件名–QFileInfo.fileName()"></a>从一段字符串中提取文件名–QFileInfo.fileName()</h2><p>读取文件名时通常得到的是带有文件路径的一串字符串，有时候只想要最后的那个文件名，这时就可以使用<code>QFileInfo</code>类的<code>fileName()</code>函数来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    QString filePath = <span class="hljs-string">&quot;/path/to/file.txt&quot;</span>;<br>    <br>    <span class="hljs-comment">// 使用QString的方法提取文件名</span><br>    QString filename = QFileInfo(filePath).fileName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Filename: &quot;</span> &lt;&lt; filename.toStdString() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Filename: file.txt<br></code></pre></td></tr></table></figure><h2 id="后缀名也不要如何做–QFileInfo-baseName"><a href="#后缀名也不要如何做–QFileInfo-baseName" class="headerlink" title="后缀名也不要如何做–QFileInfo.baseName()"></a>后缀名也不要如何做–QFileInfo.baseName()</h2><p>这时要使用<code>QFileInfo</code>类的<code>baseName()</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    QString filePath = <span class="hljs-string">&quot;/path/to/file.txt&quot;</span>;<br>    <br>    <span class="hljs-comment">// 使用 QFileInfo 的 baseName() 函数去掉文件后缀名</span><br>    QString filename = QFileInfo(filePath).baseName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Filename without extension: &quot;</span> &lt;&lt; filename.toStdString() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Filename withour extension: file<br></code></pre></td></tr></table></figure><hr><p><strong>实现原理：</strong><code>QFileInfo</code> 类的 <code>baseName()</code> 函数是通过查找文件名中最后一个点（.）之后的部分来确定文件的后缀。它将点之后的部分视为文件的后缀，并返回文件名中点之前的部分作为基本名称。</p><hr><p>注意上面提到了，是通过查找文件名中<strong>最后一个</strong>点（.）之后的部分来确定文件的后缀。所以如果对字符串<code>aaa.bbb.ccc</code>使用<code>baseName()</code>，首先会得到<code>aaa.bbb</code>，对这个字符串再使用一次<code>baseName()</code>，会得到<code>aaa</code></p><h2 id="匹配字符串末尾–QString-endsWith"><a href="#匹配字符串末尾–QString-endsWith" class="headerlink" title="匹配字符串末尾–QString.endsWith()"></a>匹配字符串末尾–QString.endsWith()</h2><p>使用 <code>QString</code> 的 <code>endsWith()</code> 函数来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  QString str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br>  <span class="hljs-comment">// 使用endsWith函数检查后缀</span><br>  <span class="hljs-keyword">if</span> (str.endsWith(<span class="hljs-string">&quot;world!&quot;</span>)) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;String ends with &#x27;world!&#x27;&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;String does not end with &#x27;world!&#x27;&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个 <code>QString</code> 对象 <code>str</code>，并使用 <code>endsWith</code> 函数来检查字符串是否以指定的后缀 <code>&quot;world!&quot;</code> 结尾。如果字符串以指定的后缀结尾，我们输出 “String ends with ‘world!’”，否则输出 “String does not end with ‘world!’”。</p><p>通过使用 <code>endsWith()</code> 函数，你可以检查 <code>QString</code> 对象是否以指定的后缀结尾，并根据需要执行相应的操作。</p><hr><p>相比<code>QFileInfo.baseName()</code>，<code>QString.endsWith()</code>不需要用（.）来分隔字符串，以确定后缀的内容，它就是根据你给定的字符串，去对一段字符串最后的几个字符进行字符匹配，若匹配上则返回<code>true</code>，否则返回<code>false</code></p><h2 id="QString和string的相互转换"><a href="#QString和string的相互转换" class="headerlink" title="QString和string的相互转换"></a>QString和string的相互转换</h2><h3 id="QString转std-string"><a href="#QString转std-string" class="headerlink" title="QString转std::string"></a><code>QString</code>转<code>std::string</code></h3><p>使用<code>QString::toStdString()</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    QString qstr = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = QString::toStdString(qstr);    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;string: &quot;</span> &lt;&lt; str &lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-string转QString"><a href="#std-string转QString" class="headerlink" title="std::string转QString"></a><code>std::string</code>转<code>QString</code></h3><p>使用<code>QString::fromStdString()</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;   <br>    QString qstr = QString::fromStdString(str);    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Converted QString: &quot;</span> &lt;&lt; qstr.toStdString() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>cout</code>输出的时候可以看到其实又用<code>toStdString</code>转成<code>string</code>来输出了，毕竟<code>std::cout</code>支持的输出类型中有<code>std::string</code>而没有<code>QString</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt的字符串操作–QString&quot;&gt;&lt;a href=&quot;#Qt的字符串操作–QString&quot; class=&quot;headerlink&quot; title=&quot;Qt的字符串操作–QString&quot;&gt;&lt;/a&gt;Qt的字符串操作–QString&lt;/h1&gt;&lt;h2 id=&quot;从一段字符串中提取</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Typora-Note</title>
    <link href="http://example.com/2024/01/23/Typora-Note/"/>
    <id>http://example.com/2024/01/23/Typora-Note/</id>
    <published>2024-01-23T09:21:45.000Z</published>
    <updated>2024-01-25T07:46:14.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="typora语法"><a href="#typora语法" class="headerlink" title="typora语法"></a>typora语法</h1><p>标题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">#一阶标题 （快捷键Ctrl+1）<br>##二阶标题 （快捷键Ctrl+2）<br>###三阶标题 （快捷键Ctrl+3）<br>####四阶标题 （快捷键Ctrl+4）<br>#####五阶标题 （快捷键Ctrl+5）<br>######六阶标题 （快捷键Ctrl+6）<br></code></pre></td></tr></table></figure><p><del>删除线</del></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">~~删除线~~<br></code></pre></td></tr></table></figure><p><strong>加粗</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**加粗** (快捷键Ctrl+B)<br></code></pre></td></tr></table></figure><p><em>字体倾斜</em></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">*字体倾斜* (快捷键Ctrl+I)<br></code></pre></td></tr></table></figure><p>将代码块快速格式化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">快捷键Shift+Tab<br></code></pre></td></tr></table></figure><p>超链接：在复制好网址的情况下，选择文本，然后使用下面的快捷键，会直接帮你把超链接网址填好，很方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">快捷键Ctrl+K<br></code></pre></td></tr></table></figure><h1 id="html语法"><a href="#html语法" class="headerlink" title="html语法"></a>html语法</h1><p><span style="background:#000000;color:black" >隐藏</span></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:#000000;color:black&quot;</span> &gt;</span>隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><del>删除线</del></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除线<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插入gif图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片地址&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom: 100%&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><u>下划线</u></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>下划线<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span> (快捷键Ctrl+U)<br></code></pre></td></tr></table></figure><h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>文件夹“typora相关”里收藏了一个知乎的“最全typora语法”，里面东西也挺好，到时可以一块整理一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;typora语法&quot;&gt;&lt;a href=&quot;#typora语法&quot; class=&quot;headerlink&quot; title=&quot;typora语法&quot;&gt;&lt;/a&gt;typora语法&lt;/h1&gt;&lt;p&gt;标题&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Typora" scheme="http://example.com/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>C++类的静态成员</title>
    <link href="http://example.com/2024/01/18/cpp-static/"/>
    <id>http://example.com/2024/01/18/cpp-static/</id>
    <published>2024-01-18T02:26:42.000Z</published>
    <updated>2024-01-18T03:27:30.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对静态成员变量的理解"><a href="#对静态成员变量的理解" class="headerlink" title="对静态成员变量的理解"></a>对静态成员变量的理解</h2><p>在类中，定义静态成员变量作为属性，该静态成员变量全局共享。</p><p>应当如何理解这个全局共享？是变量名一样就会访问到同一个变量吗？还是怎样？</p><p>从静态成员变量的初始化中其实可以看出端倪。</p><p>静态成员变量的初始化需要在类外进行，比如自定义一个类A，其成员变量a1为静态成员变量，以<code>static int a1;</code> 为例</p><p><code>a.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seta1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">geta1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么就需要在a.cpp中，类外对a1进行初始化，注意初始化时要带着变量类型和变量所属的类</p><p><code>a.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">int</span> A::a1 = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a::seta1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a1)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;a1 = a1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a::geta1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;a1;<br>&#125;<br></code></pre></td></tr></table></figure><p>这其实就表明<code>a1</code>这个变量的生命周期同类A共存，而且是所有的类A</p><p>就是说，你先声明一个<code>A a</code>，再声明一个<code>A aa</code>。</p><p>这两个对象，都是类A的对象，它们的成员变量a1是共享的。</p><p>改变aa的a1值，就等于改变a的a1值，他俩的a1值是一个东西，绑定的，共享的。是这样的一个共享。</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    A aa;<br>    a.seta1(<span class="hljs-number">50</span>);<br>    aa.seta1(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;a.a1 = &quot;</span>&lt;&lt;a.geta1()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;aa.a1 = &quot;</span>&lt;&lt;aa.geta1()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.a1 = 100<br>aa.a1 = 100<br></code></pre></td></tr></table></figure><hr><p>然后就算通过别的类，或是随便其他什么地方，创建了A的对象，来改变对象中a1的值，效果也是一样的。</p><p><code>b.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><code>b.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;b.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    A obj;<br>    obj.seta1(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;b.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    a.seta1(<span class="hljs-number">50</span>);<br>    bar();<span class="hljs-comment">//调用b.h中的方法</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;a.a1 = &quot;</span>&lt;&lt;a.geta1()&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.a1 = 100<br></code></pre></td></tr></table></figure><p>上面虽然主函数中的<code>a.seta1(50);</code>将a1的值设为了50，但是调用bar()方法，该方法中也声明了一个A的对象obj，也设置了a1的值为100，因为a1为静态成员变量，所以它们数据共享，相当于一个东西，所以最终a1的值就是最后改动的结果：100</p><hr><p>而在类A的外面的哪个地方，声明一个int a1，类型、变量名一样，这样是不会和类A里的a1共享的，这里的a1，是在它所在作用域的一个新的局部变量。</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a1;<br>    A a;<br>    a.seta1(<span class="hljs-number">50</span>);<br><span class="hljs-built_in">cout</span>&lt;&lt;a1&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//警告,使用未初始化的变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h2><p>上面说的是其实都是针对类来说的，类中的静态成员变量，下面提一下类中的静态成员函数</p><p>静态成员函数是属于类的函数，而不是类的对象实例。它们与特定的对象实例无关，可以直接通过类名来调用，而无需创建类的对象。静态成员函数在类的所有对象实例之间共享。</p><p><code>myclass.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticMemberVariable;  <span class="hljs-comment">// 静态成员变量</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMemberFunction</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数</span><br>        <span class="hljs-comment">// 实现代码</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> MyClass::staticMemberVariable = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::staticMemberFunction();  <span class="hljs-comment">// 调用静态成员函数</span><br><br>    <span class="hljs-keyword">int</span> value = MyClass::staticMemberVariable;  <span class="hljs-comment">// 访问静态成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>myclass.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myclass.h&quot;</span></span><br><br><span class="hljs-keyword">int</span> MyClass::staticMemberVariable = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMemberFunction</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数</span><br>    ... ... <span class="hljs-comment">// 实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员函数的定义和声明与普通成员函数类似，但需要在函数声明和定义中使用 <code>static</code> 关键字来标识。</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myclass.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::staticMemberFunction();  <span class="hljs-comment">// 调用静态成员函数</span><br>    <span class="hljs-keyword">int</span> value = MyClass::staticMemberVariable;  <span class="hljs-comment">// 访问静态成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在没有声明<code>MyClass</code>类的实例的情况下，可以直接通过范围解析运算符 <strong>::</strong> 对静态成员函数进行访问</p><p>顺便一提，可以看到静态成员变量也可以通过这种方式访问，不过前提是该成员变量是<code>public</code>的，通常情况下成员变量会设为<code>private</code>，所以没法这样直接访问</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对静态成员变量的理解&quot;&gt;&lt;a href=&quot;#对静态成员变量的理解&quot; class=&quot;headerlink&quot; title=&quot;对静态成员变量的理解&quot;&gt;&lt;/a&gt;对静态成员变量的理解&lt;/h2&gt;&lt;p&gt;在类中，定义静态成员变量作为属性，该静态成员变量全局共享。&lt;/p&gt;
&lt;p&gt;应</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中function关键字及lambda表达式</title>
    <link href="http://example.com/2024/01/16/cpp-function-lambda/"/>
    <id>http://example.com/2024/01/16/cpp-function-lambda/</id>
    <published>2024-01-16T01:23:44.000Z</published>
    <updated>2024-01-16T01:28:03.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="function关键字"><a href="#function关键字" class="headerlink" title="function关键字"></a>function关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>举例说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; dp = [&amp;](<span class="hljs-keyword">int</span> i)-&gt;<span class="hljs-keyword">int</span> &#123;...&#125;;<span class="hljs-comment">//注意分号;结尾</span><br></code></pre></td></tr></table></figure><p>上面是用function关键字定义的lambda表达式，其中<code>function&lt;int(int)&gt;中int(int)</code>部分的含义为：</p><p>前一个<code>int</code>，即紧跟着尖括号“<code>&lt;</code>”的<code>int</code>表示返回值类型；小括号中的<code>(int)</code>表示参数类型。</p><p>再举一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = add; <span class="hljs-comment">// 定义一个函数对象，指向函数add</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int(int, int)</code>表示函数的参数列表和返回值类型，其中<code>int</code>表示返回值类型，<code>(int, int)</code>表示参数列表，表示该函数接受两个<code>int</code>类型参数。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>以下来自ChatGPT</strong></p><p>在C++中，<code>function</code>是一个函数对象，它可以像普通函数一样调用。<code>function</code>通常用于实现回调函数、函数指针、函数对象等功能。</p><p><code>function</code>的用法有以下几种：</p><ul><li><strong>1、定义函数对象</strong></li></ul><p>可以使用<code>function</code>关键字定义一个函数对象，该函数对象可以像普通函数一样调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = add;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>function</code>定义了一个名为<code>add_func</code>的函数对象，该对象接受两个整数参数并返回它们的和。我们将其初始化为指向函数<code>add</code>的指针，并使用<code>add_func</code>调用该函数。</p><ul><li><strong>2、定义Lambda表达式</strong></li></ul><p>可以使用<code>function</code>关键字定义一个Lambda表达式，该表达式可以像普通函数一样调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; add_func = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br>  <span class="hljs-built_in">cout</span> &lt;&lt; add_func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 5</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>function</code>定义了一个名为<code>add_func</code>的函数对象，该对象接受两个整数参数并返回它们的和。我们将其初始化为一个Lambda表达式，并使用<code>add_func</code>调用该表达式。</p><ul><li><strong>3、实现回调函数</strong></li></ul><p>可以使用<code>function</code>定义一个回调函数，该函数可以作为参数传递给其他函数，并在需要时被调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; callback)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> result = a + b;<br>  callback(result);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  doSomething(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [](<span class="hljs-keyword">int</span> result) &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个函数<code>doSomething</code>，该函数接受两个整数参数和一个回调函数作为参数。在函数内部，我们计算两个整数的和，并将结果传递给回调函数。我们在<code>main</code>函数中调用<code>doSomething</code>函数，并传递一个Lambda表达式作为回调函数，该表达式输出计算结果。</p><p>需要注意的是，<code>function</code>可以接受任意类型的函数或Lambda表达式作为参数，并可以返回任意类型的值。这使得<code>function</code>非常灵活和通用。</p><h2 id="lambda函数（C-11新特性）"><a href="#lambda函数（C-11新特性）" class="headerlink" title="lambda函数（C++11新特性）"></a>lambda函数（C++11新特性）</h2><p>lambda 表达式可以说是 c++11 引用的最重要的特性之一， 它定义了一个匿名函数， 可以捕获一定范围的变量在函数内部使用，<br> 一般有如下语法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = [capture] (params) opt -&gt; ret &#123; func_body &#125;;<br></code></pre></td></tr></table></figure><p>其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt： 不需要可以省略，ret 是返回值类型，func_body 是函数体。<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> a) -&gt; <span class="hljs-keyword">int</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-keyword">auto</span> func2 = [](<span class="hljs-keyword">int</span> a) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>; &#125;;<br><span class="hljs-built_in">cout</span> &lt;&lt; func1(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; func2(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><table><thead><tr><th>[]</th><th>不捕捉任何变量</th></tr></thead><tbody><tr><td>[&amp;]</td><td>捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</td></tr><tr><td>[=]</td><td>捕获外部作用域所有变量，在函数内内有个副本使用,拷贝的副本在匿名函数体内部是只读的</td></tr><tr><td>[=,&amp;foo]</td><td>按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</td></tr><tr><td>[bar]</td><td>按值捕获 bar 变量，同时不捕获其他变量</td></tr><tr><td>[&amp;bar]</td><td>按引用捕获 bar 变量，同时不捕获其他变量</td></tr><tr><td>[this]</td><td>捕获当前类中的 this 指针,让 lambda 表达式拥有和当前类成员函数同样的访问权限,如果已经使用了 &amp; 或者 =, 默认添加此选项</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//auto x1 = [] &#123;return m_number; &#125;;                      // error</span><br>        <span class="hljs-keyword">auto</span> x2 = [=] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x3 = [&amp;] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x4 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number; &#125;;                  <span class="hljs-comment">// ok</span><br>        <span class="hljs-comment">//auto x5 = [this] &#123;return m_number + x + y; &#125;;          // error</span><br>        <span class="hljs-keyword">auto</span> x6 = [<span class="hljs-keyword">this</span>, x, y] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;    <span class="hljs-comment">// ok</span><br>        <span class="hljs-keyword">auto</span> x7 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number++; &#125;;                <span class="hljs-comment">// ok</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> m_number = <span class="hljs-number">100</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><table><thead><tr><th>x1</th><th>错误，没有捕获外部变量，不能使用类成员 m_number</th></tr></thead><tbody><tr><td>x2</td><td>正确，以值拷贝的方式捕获所有外部变量</td></tr><tr><td>x3</td><td>正确，以引用的方式捕获所有外部变量</td></tr><tr><td>x4</td><td>正确，捕获 this 指针，可访问对象内部成员</td></tr><tr><td>x5</td><td>错误，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</td></tr><tr><td>x6</td><td>正确，捕获 this 指针，x，y</td></tr><tr><td>x7</td><td>正确，捕获 this 指针，并且可以修改对象内部变量的值</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>   <span class="hljs-comment">// auto f1 = [] &#123;return a; &#125;;                        // error</span><br>    <span class="hljs-keyword">auto</span> f2 = [&amp;] &#123;<span class="hljs-keyword">return</span> a++; &#125;;                     <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">auto</span> f3 = [=] &#123;<span class="hljs-keyword">return</span> a; &#125;;                       <span class="hljs-comment">// ok</span><br>  <span class="hljs-comment">//  auto f4 = [=] &#123;return a++; &#125;;                     // error</span><br> <span class="hljs-comment">//   auto f5 = [a] &#123;return a + b; &#125;;                   // error</span><br>    <span class="hljs-keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>f1</th><th>错误，没有捕获外部变量，因此无法访问变量 a</th></tr></thead><tbody><tr><td>f2</td><td>正确，使用引用的方式捕获外部变量，可读写</td></tr><tr><td>f3</td><td>正确，使用值拷贝的方式捕获外部变量，可读</td></tr><tr><td>f4</td><td>错误，使用值拷贝的方式捕获外部变量，可读不能写</td></tr><tr><td>f5</td><td>错误，使用拷贝的方式捕获了外部变量 a，没有捕获外部变量 b，因此无法访问变量 b</td></tr><tr><td>f6</td><td>正确，使用拷贝的方式捕获了外部变量 a，只读，使用引用的方式捕获外部变量 b，可读写</td></tr><tr><td>f7</td><td>正确，使用值拷贝的方式捕获所有外部变量以及 b 的引用，b 可读写，其他只读</td></tr></tbody></table><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 完整的lambda表达式定义</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> a) -&gt; <span class="hljs-keyword">int</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+<span class="hljs-number">10</span>;  <br>&#125;;<br><br><span class="hljs-comment">// 忽略返回值的lambda表达式定义</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">return</span> a+<span class="hljs-number">10</span>;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，<code>但需要注意的是 labmda表达式不能通过列表初始化自动推导出返回值类型</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ok，可以自动推导出返回值类型</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">// error，不能推导出返回值类型</span><br><span class="hljs-keyword">auto</span> f1 = []()<br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 基于列表初始化推导返回值，错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数本质"><a href="#函数本质" class="headerlink" title="函数本质"></a>函数本质</h3><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=] &#123;<span class="hljs-keyword">return</span> a++; &#125;;              <span class="hljs-comment">// error, 按值捕获外部变量, a是只读的</span><br><span class="hljs-keyword">auto</span> f2 = [=]()<span class="hljs-keyword">mutable</span> &#123;<span class="hljs-keyword">return</span> a++; &#125;;     <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><p>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。<br>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。<br>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 包装可调用函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; f1 = [](<span class="hljs-keyword">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;;<br>    <span class="hljs-comment">// 绑定可调用函数</span><br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; f2 = bind([](<span class="hljs-keyword">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;, placeholders::_1);<br><br>    <span class="hljs-comment">// 函数调用</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; f1(<span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; f2(<span class="hljs-number">200</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func_ptr = <span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>);<br><span class="hljs-comment">// 没有捕获任何外部变量的匿名函数</span><br>func_ptr f = [](<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">return</span> a;  <br>&#125;;<br><span class="hljs-comment">// 函数调用</span><br>f(<span class="hljs-number">1314</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;function关键字&quot;&gt;&lt;a href=&quot;#function关键字&quot; class=&quot;headerlink&quot; title=&quot;function关键字&quot;&gt;&lt;/a&gt;function关键字&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hexo-g-error</title>
    <link href="http://example.com/2024/01/08/hexo-g-error/"/>
    <id>http://example.com/2024/01/08/hexo-g-error/</id>
    <published>2024-01-08T01:24:03.000Z</published>
    <updated>2024-01-08T02:04:55.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>好久没有更新hexo博客了，因为<code>hexo -d</code>经常要试好几次才能传上去，有点懒得搞了，所以只把笔记<code>git push</code> 到Github上就结束了</p><p>这天想着攒了不少了，更新一下hexo博客，结果<code>hexo -g</code>的时候出了很奇怪的错</p><img src="/2024/01/08/hexo-g-error/image-20240108093022287.png" class="" title="image-20240108093022287"><p>上网找了找相关的问题，没有完全一样的，只找到一个也是说<code>hexo -g</code>的时候有奇怪的错误，不过跟我报的错不一样。</p><p>他遇到的问题，删除hexo的所有依赖，即删除“node_modules”文件夹，然后重新安装一遍所有依赖，就解决了。</p><p>记录一下安装依赖的命令，以防后面有用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo --save<br></code></pre></td></tr></table></figure><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>然后我想起来宿舍电脑上的hexo文件夹好久没动了，一直保持后就之前没更新的状态，去试了一下，发现那台电脑上可以正常<code>hexo -g</code></p><p>就想到估计是新写的一些md笔记出了点问题，然后用了一下<code>git pull</code>，看看更新了哪些笔记</p><img src="/2024/01/08/hexo-g-error/0W7A6FM3DA_OXK5_VD2L5U.png" class="" title="~0W7A6FM3DA_OXK5_VD2L5U"><img src="/2024/01/08/hexo-g-error/image-20240108094253175.png" class="" title="image-20240108094253175"><p>从上面可以看到，主要改动的就是”<code>index.md</code>“，”<code>hello-world.md</code>“，”<code>C-Note.md</code>“，”<code>Qt-Note.md</code>“，”<code>Qt6.4-PCL1.12.1-VTK9.2.6-error.md</code>“，”<code>QtCreator-config.md</code>“这几篇文章更新了。</p><p>我就把它们都移出文件夹，然后<code>hexo -clean</code>，<code>hexo -g</code>试了一下，发现果然好了，那问题就出在他们其中</p><p><strong>因为我本来以为是不是哪个配置文件出问题了，或者hexo哪个组件升级了还是咋，导致的，想着重装一遍hexo呢，这样看来就是文件的问题</strong></p><p>确定了问题范围之后，我就把他们分别一个一个移进文件夹里，并用<code>hexo -clean</code>，<code>hexo -g</code>测试</p><p>最后锁定是**<code>QtCreator-config.md</code>**中哪个地方出了问题</p><h2 id="进一步排查"><a href="#进一步排查" class="headerlink" title="进一步排查"></a>进一步排查</h2><p>找到具体的文件<code>QtCreator-config.md</code>之后，把这个有问题的原文件放在外面，里面”_post”文件夹新建一个同名文件，然后一段一段的从原文件复制到这个新文件，并用<code>hexo -clean</code>，<code>hexo -g</code>测试</p><p>复制的时候用的代码模式查看，方便一点</p><p>最后发现有一段插入图片的代码跟别人都不一样</p><img src="/2024/01/08/hexo-g-error/image-20240108095825372.png" class="" title="image-20240108095825372"><p>别的图片都是正常的用Markdown语法插入的，这一个图片不知道为什么是用html格式插入的。。。</p><p>然后把这段图片插入代码改成了Markdown风格，果然问题就解决了。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是由于图片插入的时候，使用了html的语法，导致hexo调用node_modules里的相关插件进行格式转换的时候出现了问题</p><p>（ps：hexo通过node_modules里的插件，把本地的md文件转换成html语言，在网页上显示出来）</p><p>以后遇到类似问题，可以试着在”代码模式”下检查一下图片的插入语法是否有问题</p><p>不过我到底是没想起来，当时是怎么搞的，让这一张图片的插入语法变成了html语法。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;好久没有更新hexo博客了，因为&lt;code&gt;hexo -d&lt;/code&gt;经常要试好几次才能传上去，有点懒得搞了，所以只把笔记</summary>
      
    
    
    
    <category term="问题记录" scheme="http://example.com/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>配置Qt Creator环境</title>
    <link href="http://example.com/2023/09/13/QtCreator-config/"/>
    <id>http://example.com/2023/09/13/QtCreator-config/</id>
    <published>2023-09-13T08:33:05.000Z</published>
    <updated>2024-01-08T01:25:52.163Z</updated>
    
    <content type="html"><![CDATA[<p>在安装Qt时，一般会自动安装配套的编译器Qt Creator，并为其自动配置好对应的Qt版本。比如当时安装Qt6.4时，自动安的Qt Creator 9，并为Qt6.4自动配置好了开发环境。</p><p>之后又安装了Qt5.15的版本，又给安装了一个Qt Creator 4，把Qt5.15的开发环境配置在里面，每次打开Qt5项目的时候都是自动用Qt Creator 4打开的</p><p>但其实完全没必要，Qt Creator就是个编译器，就用新版的就行，只不过是需要自己手动配置一下需要的Qt版本的开发环境罢了</p><p>下面举例说明</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>打开Qt Creator，找到编辑–&gt;Preferences</p><img src="/2023/09/13/QtCreator-config/image-20230913173513687.png" class="" title="image-20230913173513687"><p>找到 构建套件(kit)</p><img src="/2023/09/13/QtCreator-config/image-20230913173553228.png" class="" title="image-20230913173553228"><p>可以看到已经自动配置好了当时配套安装的Qt6.4的环境（自动检测）</p><p>自己之后安装的其他版本的Qt就需要自己手动设置了，如下面手动设置的Qt5.15</p><p>这样其实当时安装其他版本Qt的时候就不需要勾选Qt Creator选项了</p><h3 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h3><p>在上图构建套件窗口选择–&gt;编译器</p><img src="/2023/09/13/QtCreator-config/image-20230913191041419.png" class="" title="image-20230913191041419"><p>上图中”手动设置”部分就是我们需要配的，图中是已经配置好的效果</p><p>一般就配置两种编译器环境，一种MSVC，一种MinGW</p><p>然后每一种都把C、C++版本都配了就行</p><h4 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h4><p>MinGW是Qt最原生的编译器，所以配起来也简单，可以看到MinGW的编译器C和C++都只配了一个，而MSVC的C和C++每个配了四个</p><h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p>先配C吧，点击右上角”添加”，选MinGW–&gt;C</p><img src="/2023/09/13/QtCreator-config/image-20230913191928071.png" class="" title="image-20230913191928071"><p>之后可以看到这个界面</p><img src="/2023/09/13/QtCreator-config/image-20230913192058948.png" class="" title="image-20230913192058948"><p>我们参考上面自动检测到的MinGW For C的配置</p><img src="/2023/09/13/QtCreator-config/image-20230913192145930.png" class="" title="image-20230913192145930"><p>找到Qt5的gcc.exe路径，设置好即可，名称也参照着改了一下，这样就行了</p><img src="/2023/09/13/QtCreator-config/image-20230913192241380.png" class="" title="image-20230913192241380"><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><p>然后配置C++版本的也是同理，先添加–&gt;MinGW–&gt;C++</p><img src="/2023/09/13/QtCreator-config/image-20230913191703610.png" class="" title="image-20230913191703610"><p>然后配置好编译器路径即可，不过C++用的是g++.exe，就这点区别</p><img src="/2023/09/13/QtCreator-config/image-20230913192505720.png" class="" title="image-20230913192505720"><h4 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h4><p>MSVC稍微麻烦点，其实也不用C、C++每个配四个，不过因为对标上面自动检测出来的配置，所以就每个配了四个</p><h5 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h5><p>跟前面一样，要添加什么就选什么</p><img src="/2023/09/13/QtCreator-config/image-20230913192957494.png" class="" title="image-20230913192957494"><p>不过跟MinGW不同的是，MSVC中C\C++配置的路径都指向同一个东西，都是vcvarsall.bat</p><p>至于这个东西位置在哪，用”everything”来找就行</p><p>根据我的安装路径，找到<code>vcvarsall.bat</code>在<code>E:\Microsoft Visual Studio 2022\Community\VC\Auxiliary\Build\vcvarsall.bat</code></p><p>然后参照着上面自动检测到的配置来配就行，这里给出每一种具体的配置，到时候自己来调就行</p><p>C和C++的除了到时候自己起的名称不一样，其他所有的东西都一样，这里就以C++为例展示了</p><ul><li><strong>Microsoft Visual C++ Compiler 2019_x86_amd64</strong></li></ul><img src="/2023/09/13/QtCreator-config/image-20230913193953039.png" class="" title="image-20230913193953039"><ul><li><strong>Microsoft Visual C++ Compiler 2019_x86</strong></li></ul><img src="/2023/09/13/QtCreator-config/image-20230913194104721.png" class="" title="image-20230913194104721"><ul><li><strong>Microsoft Visual C++ Compiler 2019_amd64</strong></li></ul><img src="/2023/09/13/QtCreator-config/image-20230913194228510.png" class="" title="image-20230913194228510"><ul><li><strong>Microsoft Visual C++ Compiler 2019_amd64_x86</strong></li></ul><img src="/2023/09/13/QtCreator-config/image-20230913194314492.png" class="" title="image-20230913194314492"><h5 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h5><p>可看到自己手动配置的版本都是用的msvc2019，这是因为要配合Qt5.15来使用，好像这个版本的Qt适配的版本就是msvc2019</p><p>到时候具体看要用的Qt版本适配msvc20XX，咱就配msvc20XX</p><p>可能存在的问题就是自己选“ABI”那一栏的时候，可能没有自己想要的msvc20XX，具体什么原因不清楚</p><img src="/2023/09/13/QtCreator-config/image-20230913194841255.png" class="" title="image-20230913194841255"><p>遇到这种情况不要在意，去选ABI中的“&lt;自定义&gt;”，然后就可以自定义后续的选项了</p><img src="/2023/09/13/QtCreator-config/image-20230913194949764.png" class="" title="image-20230913194949764"><p>这种时候msvc20XX的可选范围一般就很大了，根据自己的需求选就行</p><p>然后其余的选项就对照着前面自动检测到的对应版本来设置就行</p><h3 id="Qt版本"><a href="#Qt版本" class="headerlink" title="Qt版本"></a>Qt版本</h3><p>也是根据下面自动检测到的Qt6版本的qmake.exe路径，配置好我们所需的qmake.exe的路径</p><img src="/2023/09/13/QtCreator-config/image-20230913195503926.png" class="" title="image-20230913195503926"><p>当然根据下面自动检测的来看，如果要用ARM64之类的，可能要配的是qmake.bat的路径，不过一直没用上过，也没仔细研究</p><h3 id="构建套件（Kit）"><a href="#构建套件（Kit）" class="headerlink" title="构建套件（Kit）"></a>构建套件（Kit）</h3><p>上面两步配置好了之后，回到构建套件(kit)一栏，分别配置MinGW和MSVC的开发套件即可</p><h4 id="MinGW-1"><a href="#MinGW-1" class="headerlink" title="MinGW"></a><strong>MinGW</strong></h4><p>Qt版本选择我们刚才自定义的所需的版本</p><p>调试器也选择合适的版本，这个好像就用自动检测到的就行，好像不需太在意几点几版本</p><p>然后选择之前配置好的编译器即可，MinGW的编译器选择比较省心，没有多的，就选那俩就行</p><img src="/2023/09/13/QtCreator-config/image-20230913201207209.png" class="" title="image-20230913201207209"><h4 id="MSVC-1"><a href="#MSVC-1" class="headerlink" title="MSVC"></a><strong>MSVC</strong></h4><p>MSVC同理，跟上面大差不差</p><p>选择Qt版本</p><p>选择调试器，注意MinGW和MSVC的调试器可不一样，这可不能选混了</p><p>然后也是要选择对应的编译器</p><img src="/2023/09/13/QtCreator-config/image-20230913201522055.png" class="" title="image-20230913201522055"><h5 id="可能存在的问题-1"><a href="#可能存在的问题-1" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h5><p>这里有个问题，就是因为前面msvc的编译器配了很多个，然后C、C++的还要配合起来才能用，导致不一定哪一个配上好用，这里只能一个一个来试，不过这个试也有一点小技巧</p><p>就是看配置前面的图标，像这种小电脑图标就表示配置成功了，可以正常使用</p><img src="/2023/09/13/QtCreator-config/image-20230913203210951.png" class="" title="image-20230913203210951"><p>如果是黄叹号标志，就是存在问题，不可用</p><img src="/2023/09/13/QtCreator-config/image-20230913202116876.png" class="" title="image-20230913202116876"><p>如果是红色叹号，那就是C和C++没对应起来，也不能用</p><img src="/2023/09/13/QtCreator-config/image-20230913203146696.png" class="" title="image-20230913203146696"><p>emm，好像也不算技巧，反正就是看着这个图标来判断能不能行，然后慢慢试</p><p>然后因为当时配置编译器那一步，所有自动配置的编译器，其名称、配置都是参考上面编译器名称、配置来的，所以应该是能做到一一对应关系</p><p>所以在构建套件（kit）这一步，其实也可以参考自动检测到的可用的开发环境的编译器配置来进行自定义的设置</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上面一直说的是照着自动检测好的来配置自定义配置</p><p>当然其实也可能他自动识别出来的配置不可用，可能还是要上面这样手动配置一下</p><p>那个时候虽然步骤跟上面一样，但可能没有可参考的，所以这一笔记也可作为后续配置过程中的参考配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在安装Qt时，一般会自动安装配套的编译器Qt Creator，并为其自动配置好对应的Qt版本。比如当时安装Qt6.4时，自动安的Qt Creator 9，并为Qt6.4自动配置好了开发环境。&lt;/p&gt;
&lt;p&gt;之后又安装了Qt5.15的版本，又给安装了一个Qt Creator </summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>基于ccViewer二次开发</title>
    <link href="http://example.com/2023/06/01/VS2022-ccViewer/"/>
    <id>http://example.com/2023/06/01/VS2022-ccViewer/</id>
    <published>2023-06-01T13:27:46.000Z</published>
    <updated>2023-06-02T05:26:39.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ccViewer是CloudCompare的一个子项目，负责点云数据的显示部分，可在其基础上专注于增加点云处理功能。</p><p>下面介绍如何在VS2022中使用编译好的ccviewer项目作为基础，或者说将其看作是像PCL一样的库来使用。</p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>因为是需要编译过程中产生的一系列文件，所以需要首先编译Cloud Compare，其中捎带着会把子项目ccViewer也编译了。</p><p>具体见之前的博客“编译CloudCompare”</p><p>编译用的source、中间生成的build、最终的结果install如下</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601213740840.png" class="" title="image-20230601213740840"><h2 id="VS2022"><a href="#VS2022" class="headerlink" title="VS2022"></a>VS2022</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>因为是在ccviewer基础上，所以第一步先把ccviewer项目涉及到的文件在新建的项目中拷贝一遍</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601214149643.png" class="" title="image-20230601214149643"><p>以下是子项目ccviewer原本的文件结构，可以看出就是整个照搬一遍。不过里面具体的代码就是按照自己的需要来改了</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601214337146.png" class="" title="image-20230601214337146"><h3 id="配置头文件路径"><a href="#配置头文件路径" class="headerlink" title="配置头文件路径"></a>配置头文件路径</h3><p>虽然从上述文件结构来看ccviewer本身没有太多文件，但其中实现具体方法的时候用到了大量的外部文件，外部文件又用到了其他的文件，层层嵌套，导致实际上文件结构很复杂。</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601214948573.png" class="" title="image-20230601214948573"><p>但实际我们无需关注这些文件中的具体实现，我们就把他们当成PCL一样的库来使用即可，所以现在要做的就是像当时配置PCL那类库时一样，配置头文件路径、配置链接器、添加dll文件所在路径到path。不过因为是用编译后的项目来做库，还是有点区别的，后面会提到。</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>具体的配置头文件的路径的过程就是根据错误提示，看找不到的是哪些 .h文件</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601215414851.png" class="" title="image-20230601215414851"><p>用everything找到文件所在</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601215516626.png" class="" title="image-20230601215516626"><p>将路径添加到项目属性配置中，C/C++ -&gt;常规-&gt;附加包含目录，最终所有的路径如下</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222345038.png" class="" title="image-20230601222345038"><h3 id="配置链接器"><a href="#配置链接器" class="headerlink" title="配置链接器"></a>配置链接器</h3><p>根据错误提示中的输出，重点关注图示中括号里面的部分</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601220611109.png" class="" title="image-20230601220611109"><p>将括号里面的部分复制，使用“Far Manger 3”来搜索含有这部分内容的lib文件</p><p>首先定位到大致的搜索位置</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601220842339.png" class="" title="image-20230601220842339"><p>然后点击Commands-&gt;Find file，他这个软件上面菜单栏不知道为什么是隐藏的，不用在意，就往那个Commands的位置点就行，就会出来菜单了</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601220909494.png" class="" title="image-20230601220909494"><p>在Containing text中粘贴上面提到的复制的内容，注意不要括号，然后进行搜索</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601221029447.png" class="" title="image-20230601221029447"><p>最终找到目标lib</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601221208984.png" class="" title="image-20230601221208984"><p>把lib文件名添加到链接器-&gt;输入-&gt;附加依赖项</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222039812.png" class="" title="image-20230601222039812"><p>把lib所在路径添加到链接器-&gt;常规-&gt;附加库目录</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222257795.png" class="" title="image-20230601222257795"><h3 id="配置dll路径"><a href="#配置dll路径" class="headerlink" title="配置dll路径"></a>配置dll路径</h3><p>再根据运行时的错误提示找到缺少的dll文件，还是用”everything”来找就行，前面提过跟多次就不细说了</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222559516.png" class="" title="image-20230601222559516"><p>问了后续操作的方便，把缺少的这些dll文件都放到了一个文件夹中CC\bin</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222702443.png" class="" title="image-20230601222702443"><p>不过实际上这些dll都在一个文件夹D:\CC\install\ccViewer_debug中，就先这样了，后续添加功能可能有其他其他文件夹的dll放进来，省的后续的麻烦了</p><p>然后把这个bin路径添加到环境变量path中即可</p><img src="/2023/06/01/VS2022-ccViewer/image-20230601222934400.png" class="" title="image-20230601222934400"><h3 id="PCL插件"><a href="#PCL插件" class="headerlink" title="PCL插件"></a>PCL插件</h3><p>编译好的ccviewer读取pcd格式依赖于配合pcl生成的插件，所以我们在自己建的项目里也要把那些插件的dll复制过去。</p><p>找到编译好的ccviewer程序所在，选中plugins、shaders两个文件夹</p><img src="/2023/06/01/VS2022-ccViewer/image-20230602132621122.png" class="" title="image-20230602132621122"><p>将它们复制到我们新建项目的ccviewer_Qt5\x64\Debug路径下</p><img src="/2023/06/01/VS2022-ccViewer/image-20230602132638678.png" class="" title="image-20230602132638678"><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>至此程序就可以正常运行了，再在此基础上进行二次开发即可</p><p>不过程序有些图标没显示，因为没把图标资源文件复制过去，后续研究一下复制到哪里去，待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ccViewer是CloudCompare的一个子项目，负责点云数据的显示部分，可在其基础上专注于增加点云处理功能。&lt;/p&gt;
&lt;p&gt;下面介绍</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="ccViewer" scheme="http://example.com/tags/ccViewer/"/>
    
  </entry>
  
  <entry>
    <title>cmake使用笔记</title>
    <link href="http://example.com/2023/05/05/CMake-Note/"/>
    <id>http://example.com/2023/05/05/CMake-Note/</id>
    <published>2023-05-05T07:17:00.000Z</published>
    <updated>2023-05-05T07:21:56.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>最近再新电脑上使用cmake-gui的时候发现选项都列在一起，没有像之前旧电脑上那样把每一项归好类</p><img src="/2023/05/05/CMake-Note/image-20230505151913285.png" class="" title="image-20230505151913285"><p>旧电脑上是3.25版本的，这个新的是3.26，一开始以为是版本升级的负优化，结果重新下了个3.25还是一样的。</p><p>最后发现原来在界面上有个“Grouped”选项，选一下就好了。。。</p><img src="/2023/05/05/CMake-Note/image-20230505152057032.png" class="" title="image-20230505152057032">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;界面&quot;&gt;&lt;a href=&quot;#界面&quot; class=&quot;headerlink&quot; title=&quot;界面&quot;&gt;&lt;/a&gt;界面&lt;/h2&gt;&lt;p&gt;最近再新电脑上使用cmake-gui的时候发现选项都列在一起，没有像之前旧电脑上那样把每一项归好类&lt;/p&gt;
&lt;img src=&quot;/2023/</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="cmake" scheme="http://example.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>CloudCompare源码学习笔记</title>
    <link href="http://example.com/2023/04/19/CloudCompare-Note/"/>
    <id>http://example.com/2023/04/19/CloudCompare-Note/</id>
    <published>2023-04-19T02:51:00.000Z</published>
    <updated>2024-01-31T03:29:58.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ccViewer"><a href="#ccViewer" class="headerlink" title="ccViewer"></a>ccViewer</h1><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ccViewer::ccViewer(QWidget *parent, Qt::WindowFlags flags)<br>: QMainWindow(parent, flags)<br>, m_glWindow(<span class="hljs-literal">nullptr</span>)<br>, m_selectedObject(<span class="hljs-literal">nullptr</span>)<br>, m_3dMouseInput(<span class="hljs-literal">nullptr</span>)<br></code></pre></td></tr></table></figure><p>这段代码是一个类 <code>ccViewer</code> 的构造函数的实现，该类是继承自 <code>QMainWindow</code> 类的。</p><p>构造函数的参数 <code>parent</code> 是一个指向父窗口的指针，参数 <code>flags</code> 是窗口的标志。</p><p>下面是成员变量的初始化：</p><ul><li><code>m_glWindow</code> 是一个指向 <code>QOpenGLWidget</code> 对象的指针，初始化为 <code>nullptr</code>。</li><li><code>m_selectedObject</code> 是一个指向选中的对象的指针，初始化为 <code>nullptr</code>。</li><li><code>m_3dMouseInput</code> 是一个指向 <code>Q3DMouseInput</code> 对象的指针，初始化为 <code>nullptr</code>。</li></ul><p>在这个构造函数中，这些成员变量都被初始化为默认值。这些成员变量可以在类的其他成员函数中使用，以实现类的功能。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">connect(m_glWindow, &amp;ccGLWindow::filesDropped, <span class="hljs-keyword">this</span>, qOverload&lt;QStringList&gt;(&amp;ccViewer::addToDB), Qt::QueuedConnection);<br></code></pre></td></tr></table></figure><p>这是一个Qt中的信号与槽连接语句，用于连接一个发送信号的对象（<code>m_glWindow</code>）和一个接收信号的对象（<code>this</code>，即当前对象）。</p><p>具体来说，这条连接语句的含义是：当<code>m_glWindow</code>对象发出<code>filesDropped</code>信号时，调用当前对象（即this）的addToDB函数，该函数需要一个<code>QStringList</code>参数。<strong>连接使用的是Qt的<code>QueuedConnection</code>方式</strong>，这意味着函数调用将被放入事件队列中，以便在当前事件处理结束后执行。</p><p>值得注意的是，这里使用了一个函数指针<code>qOverload&lt;QStringList&gt;(&amp;ccViewer::addToDB)</code>，它指定了要调用的函数的签名。这对于具有多个重载版本的函数非常有用，因为它可以让Qt找到正确的函数版本并进行调用。</p><p>至于如何理解其中的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">qOverload&lt;QStringList&gt;(&amp;ccViewer::addToDB)<br></code></pre></td></tr></table></figure><p><code>qOverload</code>是Qt提供的一个模板函数，用于指定信号与槽连接中要调用的槽函数的签名，以避免函数重载时的二义性。具体来说，它的语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">qOverload&lt;T&gt;(&amp;Class::Function)<br></code></pre></td></tr></table></figure><p>其中，Class是包含该函数的类，Function是要调用的函数名，T则代表该重载函数区别于其他函数的形参类型。</p><p>具体来说，<code>addToDB</code>函数有两个重载，分别为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ccViewer::addToDB</span><span class="hljs-params">(QStringList filenames)</span></span><br><span class="hljs-function"></span>&#123;<br>···<br>&#125;<br></code></pre></td></tr></table></figure><p>以及</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ccViewer::addToDB</span><span class="hljs-params">(ccHObject* entity)</span></span><br><span class="hljs-function"></span>&#123;<br>···<br>&#125;<br></code></pre></td></tr></table></figure><p>经典的重载函数，名字、返回值相同，以传入的形参不同进行区分</p><p>根据语句<code>qOverload&lt;QStringList&gt;(&amp;ccViewer::addToDB)</code>，QT可以清楚地知道要调用的是第一个<code>addToDB</code>函数（形参类型为<code>QStringList</code>），而不会和其他重载函数混淆，保证将信号与正确地槽函数相连接。</p><h1 id="CloudCompare"><a href="#CloudCompare" class="headerlink" title="CloudCompare"></a>CloudCompare</h1><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">CloudCopmare<br>    ^      ^<br>    |      |<br>QCC_IO     QCC_GL<br>   ^        ^  ^<br>    \      /    \<br>     QCC_DB     CC_FBO<br>       ^<br>       |<br>    CC_CORE<br></code></pre></td></tr></table></figure><p>上图描述了 <code>CloudCompare</code> 的几个主要模块和他们之间的依赖关系。</p><ul><li><code>CloudCopmare</code> 是程序本身</li><li><code>QCC_IO</code> 负责点云文件的加载和保存</li><li><code>QCC_GL</code> 负责点云的渲染</li><li><code>CC_FBO</code> 负责实现渲染数据的管理</li><li><code>QCC_DB</code> 负责实现模型数据在内存中的存储管理</li><li><code>CC_CORE</code> 实现了点云相关的数据结构和算法</li></ul><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p>上面这些主要模块中，带有 “Q” 开头的说明这个模块依赖 QT。下面自底向上逐个介绍这些模块。</p><h3 id="CC-CORE"><a href="#CC-CORE" class="headerlink" title="CC_CORE"></a>CC_CORE</h3><p>CC_CORE 被作为独立代码库脱离了 CloudCompare 仓库，放在<a href="https://github.com/CloudCompare/CCCoreLib"><code>CCCoreLib库</code></a>，在 CloudCompare 项目下的 <code>/libs/qCC_db/extern/CCCoreLib</code> 目录作为 git 子模块引入。</p><p>该部分实现了很多点云处理相关数据结构和算法，例如数据结构 <code>CCVector</code>、<code>DgmOctree</code> 和<code>Neighbourhood</code>等，还有用来描述三维模型的各种 <code>cloud</code>、<code>mesh</code> 和 <code>polyline</code> 类型，算法方面提供了常用的点云算法。</p><h3 id="QCC-DB"><a href="#QCC-DB" class="headerlink" title="QCC_DB"></a>QCC_DB</h3><p>该模块在 <code>/libs/qCC_db</code> 目录下。</p><p>这部分实现了 <code>cloud</code>、<code>mesh</code> 和 <code>polyline</code> 等模型数据在内存中存储和管理功能。</p><p>这些模型类全都继承自 <code>ccHObject</code> 类型，<code>ccHobject</code> 又继承了 <code>ccDrawableObject</code>、<code>ccSeriallzableObject</code> 和 <code>ccObject</code>，分别提供绘制、序列化和元信息查询的接口。</p><h3 id="QCC-IO"><a href="#QCC-IO" class="headerlink" title="QCC_IO"></a>QCC_IO</h3><p>该模块在 <code>/libs/qCC_io</code> 目录下。</p><p>这部分规范了文件输入输出的接口，使用 <code>FileIOFilter</code> 作为基类，派生实现不同类型的模型文件的加载和保存。</p><p>源码中已经实现了几个常见的文件类型的 <code>FileIOFilter</code>，如果想要实现自己的模型文件的加载和保存，可以以插件的形式添加到到 <code>CloudCompare</code> 中，继承 <code>FileIOFilter</code> 类并实现对应的接口，最后再调用注册函数启用。</p><h3 id="QCC-GL-和-CC-FBO"><a href="#QCC-GL-和-CC-FBO" class="headerlink" title="QCC_GL 和 CC_FBO"></a>QCC_GL 和 CC_FBO</h3><p>这俩模块在 <code>/libs/qCC_glWindow</code> 和 <code>/libs/CCFbo</code> 目录下。</p><p>这部分实现了模型数据的渲染，底层用的是 <code>OpenGL</code>，实现比较复杂。如果需要拓展新类型的模型或者是自定义渲染效果就需要关注这个模块。</p><h2 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h2><p>拓展 CloudCompare 的方式有两种，一种是 UI 界面添加新的组件，另一种是插件化开发。</p><h3 id="UI-功能扩展"><a href="#UI-功能扩展" class="headerlink" title="UI 功能扩展"></a>UI 功能扩展</h3><p>UI 拓展就是 QT 信号槽那一套，先打开 <code>/qCC/ui_templates</code> 目录，找到想要修改的 ui 文件，然后再实现一下对应的槽函数就可以了。</p><h3 id="插件扩展"><a href="#插件扩展" class="headerlink" title="插件扩展"></a>插件扩展</h3><p>插件拓展除了不能修改 CloudCompare 本身的 UI 以外，可以拓展任意想要的功能，CloudCompare 提供了三种基本类型的插件抽象，分别是 IO 插件、GL 插件和标准插件。</p><p>IO 插件是对 <code>QCC_IO</code> 模块的拓展，实现自定义文件的加载和保存。</p><p>GL 插件是对 <code>QCC_GL</code> 和 <code>CC_FBO</code> 的拓展，实现自定义的模型渲染或渲染效果。</p><p>标准插件则没有上俩个插件的限制，可以拓展任何想要的功能。 </p><h2 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ccViewer&quot;&gt;&lt;a href=&quot;#ccViewer&quot; class=&quot;headerlink&quot; title=&quot;ccViewer&quot;&gt;&lt;/a&gt;ccViewer&lt;/h1&gt;&lt;h2 id=&quot;代码解析&quot;&gt;&lt;a href=&quot;#代码解析&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
    <category term="cloudcompare" scheme="http://example.com/tags/cloudcompare/"/>
    
  </entry>
  
  <entry>
    <title>Qt学习笔记</title>
    <link href="http://example.com/2023/04/17/Qt-Note/"/>
    <id>http://example.com/2023/04/17/Qt-Note/</id>
    <published>2023-04-17T13:14:46.000Z</published>
    <updated>2024-01-23T09:35:44.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><h2 id="clicked-、triggered-、toggled-三个信号的区别"><a href="#clicked-、triggered-、toggled-三个信号的区别" class="headerlink" title="clicked()、triggered()、toggled()三个信号的区别"></a>clicked()、triggered()、toggled()三个信号的区别</h2><h3 id="toggled"><a href="#toggled" class="headerlink" title="toggled()"></a>toggled()</h3><p>toggle 类似开关。 具有2个状态，打开/关闭。  使用这个信号，是在这2个状态之间切换。checkable按纽或是图标的槽函数应该用toggled()事件来激活</p><h3 id="triggered"><a href="#triggered" class="headerlink" title="triggered()"></a>triggered()</h3><p>trigger是一次性的。 点击后，无法改变状态。 要么是打开，要么是关闭。一般的按纽（uncheckable）的激活方式即是triggered()。更有触发的意思。这个单词还有另一个意思就是板机</p><h3 id="clicked"><a href="#clicked" class="headerlink" title="clicked()"></a>clicked()</h3><p>和triggered()用法一样，使用场景不同，triggered() 正常情况下应该广泛地多，比如快捷键等</p><h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><h3 id="信号-signals"><a href="#信号-signals" class="headerlink" title="信号 signals"></a>信号 signals</h3><p>信号的创建规则：</p><ul><li>信号使用 signals 关键字声明，在其后面有一个冒号“:”，在其前面不能有 public、private、protected 访问控制符，信号默认是 public 的。</li></ul><ul><li>信号只需像函数那样声明即可，其中可以有参数，参数的主要作用是用于和槽的通信，这就像普通函数的参数传递规则一样。信号虽然像函数，但是对他的调用方式不一样，信号需要使用 emit 关键字发射。</li></ul><ul><li>信号只需声明，不能对其进行定义，信号是由 moc 自动生成的。</li></ul><ul><li>信号的返回值只能是 void 类型的。</li></ul><h3 id="槽-slots"><a href="#槽-slots" class="headerlink" title="槽 slots"></a>槽 slots</h3><p>槽的创建规则：</p><ul><li>声明槽需要使用 slots 关键字，在其后面有一个冒号“:”，且槽需使用 public、private、protected 访问控制符之一。</li><li>槽就是一个普通的函数，可以像使用普通函数一样进行使用，槽与普通函数的主要区别是，槽可以与信号关联。</li></ul><h3 id="发射信号-emit"><a href="#发射信号-emit" class="headerlink" title="发射信号 emit"></a>发射信号 emit</h3><p>注意这里的”发射信号”指的是一个动作</p><p>发射信号的创建规则：</p><ul><li><p>发射信号需要使用 emit 关键字，注意，在 emit 后面不需要冒号。</p></li><li><p>emit 发射的信号使用的语法与调用普通函数相同，比如有一个信号为 void f(int)，则发送的语法为：emit f(3); </p></li><li><p>当信号被发射时，与其相关联的槽函数会被调用(注意：信号和槽需要使用</p></li><li><p>QObject::connect 函数进行关联之后，发射信号后才会调用相关联的槽函数。</p></li><li><p>因为信号位于类之中，因此发射信号的位置需要位于该类的成员函数中或该</p></li><li><p>类能见到信号的标识符的位置。</p></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头文件 m.h 的内容</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">public</span> QObject&#123; <span class="hljs-comment">//信号和槽必须继承自 QObject 类</span><br>  Q_OBJECT                    <span class="hljs-comment">//必须添加该宏</span><br>  <br>  <span class="hljs-comment">//public signals:void s1(int);  //错误 signals 前不能有访问控制符。</span><br>  <br>  signals:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//使用 signals 关键字声明信号，信号的语法与声明函数相同。</span><br>  signals:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-comment">//正确，信号可以有参数，也可以重载。</span><br>  <br>  <span class="hljs-comment">//void s2()&#123;&#125; //错误，信号只需声明，不能定义。</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s3</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//注意：这仍是声明的一个信号</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//信号声明结束后，重新使用访问控制符，表示以下声明的是成员函数。</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">emit <span class="hljs-title">s3</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//发射信号</span><br>  &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">public</span> QObject&#123;<br>  Q_OBJECT<br><span class="hljs-keyword">public</span> slots:               <span class="hljs-comment">//使用 slots 关键字声明槽</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">x</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;X&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>  &#125;<br>  <span class="hljs-comment">//slots: void x()&#123;&#125;     //错误，声明槽时需要指定访问控制符。</span><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-comment">// emit s3();       //错误，在类 B 中对于标识符 s3 是不可见的</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">//源文件的内容</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;<br>  A ma; <br>  B mb;<br>  QObject::connect(&amp;ma,&amp;A::s3,&amp;mb,&amp;B::x); <span class="hljs-comment">//关联信号和槽</span><br>  ma.g(); <span class="hljs-comment">//调用g发送信号</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Qt-Designer使用"><a href="#Qt-Designer使用" class="headerlink" title="Qt Designer使用"></a>Qt Designer使用</h1><h2 id="菜单栏、工具栏的创建"><a href="#菜单栏、工具栏的创建" class="headerlink" title="菜单栏、工具栏的创建"></a>菜单栏、工具栏的创建</h2><p>创建新项目时，其实已经帮我们默认创建好菜单栏、工具栏和状态栏了。菜单栏在窗口顶部，可以看到“在这里输入”的提示，那一栏就是菜单栏的位置，其对象名为menuBar，可以在右侧对象检查器中看到，菜单栏只能有一个。工具栏在菜单栏下面紧挨着，初始也帮我们建了一个，对象名为mainToolBar，工具栏可以有多个，想创建的话，在主对象上右键-&gt;创建工具栏即可。状态栏我不知道在哪，不过这东西也只能有一个，且初始帮我们创建了，对象名为statusBar。</p><img src="/2023/04/17/Qt-Note/image-20230418164800697.png" class="" title="image-20230418164800697"><p>在主对象上右键-&gt;添加工具栏以添加新的工具栏，状态栏因为已经有了所以这里显示”移除状态栏”，菜单栏也因为已经有了直接不显示，若初始没有菜单栏，这里右键就能看到“创建菜单栏”的选项。</p><img src="/2023/04/17/Qt-Note/image-20230418171053498.png" class="" title="image-20230418171053498"><p>在菜单栏的“在这里输入”中输入具体的内容，如option。这时右侧menuBar下会多一栏menuoption，而且点击菜单栏的option，该栏会展开，一开始也是只有“在这里输入”和“添加分隔符”两项内容，在里面输入具体内容之后就相当于给它们创建了实体，如这里我输入了option1和option2，这种就算是具体的动作了，创建这两个的同时，不光右侧对象检查器的menuoption栏下会多两个QAction：actionoption1和actionoption2，动作编辑器中也会多出两项：actionoption1和actionoption2。另外，option1右侧可以看到蓝色的小加号，点击之后可以将option1再展开，通过“在这里输入”输入具体的名称，继续添加具体的项。</p><p>之后将具体的对象与槽函数连接来实现具体功能即可。</p><img src="/2023/04/17/Qt-Note/image-20230418173258431.png" class="" title="image-20230418173258431"><h1 id="Qt-VS多窗口程序"><a href="#Qt-VS多窗口程序" class="headerlink" title="Qt+VS多窗口程序"></a>Qt+VS多窗口程序</h1><h2 id="新建ui及配套-h与-cpp文件"><a href="#新建ui及配套-h与-cpp文件" class="headerlink" title="新建ui及配套.h与.cpp文件"></a>新建ui及配套.h与.cpp文件</h2><p>想创建新的ui，并自动创建配套的.h和.cpp文件时，选择新建Qt Widgets Class 这一项</p><img src="/2023/04/17/Qt-Note/image-20231228113628805.png" class="" title="image-20231228113628805"><p>然后就会弹出Qt的创建Widgets类的窗口，根据自己的需要自定义name，选择新窗口要继承的基类，即可生成 xx.ui ，xx.h  ，xx.cpp三件套</p><img src="/2023/04/17/Qt-Note/image-20231228113904241.png" class="" title="image-20231228113904241"><p>顺便提一嘴，添加新项的时候，选第一个“Qt Class”，会创建一个Qt类，包含xx.h 和 xx.cpp，下面看看它xx.h和xx.cpp中的内容：</p><p><strong><code>QtClass.h</code>：</strong></p><img src="/2023/04/17/Qt-Note/image-20231229101345541.png" class="" title="image-20231229101345541"><p><strong><code>QtClass.cpp</code>：</strong></p><img src="/2023/04/17/Qt-Note/image-20231229101511693.png" class="" title="image-20231229101511693"><p>相比创建Qt Widget Class 来，就少了个ui界面文件，想用纯代码风格编程，来键窗口之类的，创建这种Qt Class就行</p><hr><p>然后创建新项那一栏再往下：</p><p>下面“Qt Dialog From File”是只单独创建xx.ui一个文件，没有配套的xx.h和xx.cpp文件生成的</p><p>再往下的一些选项是创建xx.qml，xx.qrc之类的，具体的创建新项的时候去看右边的说明吧</p><h2 id="主窗口调用新建的窗口"><a href="#主窗口调用新建的窗口" class="headerlink" title="主窗口调用新建的窗口"></a>主窗口调用新建的窗口</h2><h3 id="新建窗口的内容"><a href="#新建窗口的内容" class="headerlink" title="新建窗口的内容"></a>新建窗口的内容</h3><p>先看一眼刚刚新建的窗口头文件与源文件，看看它们如何与ui文件联系起来的</p><p><strong><code>filter_voxel.h</code></strong></p><img src="/2023/04/17/Qt-Note/image-20231228143931471.png" class="" title="image-20231228143931471"><p>主要还是靠自动配置好的<code>#include&quot;Ui_filter_voxel.h&quot;</code>配合起来的</p><p><strong><code>filter_voxel.cpp</code></strong></p><img src="/2023/04/17/Qt-Note/image-20231228143849340.png" class="" title="image-20231228143849340"><p>之后有什么要让这个窗口实现的内容就在这个窗口来做就行。添加组件、添加信号、添加槽函数。。。</p><h3 id="主窗口的内容"><a href="#主窗口的内容" class="headerlink" title="主窗口的内容"></a>主窗口的内容</h3><p>现在来看如何让主窗口和新建的窗口联系起来</p><p><strong>主窗口头文件<code>mainwindow.h</code></strong></p><img src="/2023/04/17/Qt-Note/image-20231228160308494.png" class="" title="image-20231228160308494"><p>一是引入新建窗口的头文件<code>#include “filter_voxel.h”</code></p><p>二是在成员中声明新建窗口类<code>filter_voxel *filter_voxel_dialog</code></p><p>三就是创建一个槽函数<code>void on_actionVoxel_Filter_triggered()</code>，一会用来产生与新建窗口相关的响应</p><p><strong>PS：</strong>其中关于第二条，声明新建窗口类时，这里声明的是个指针，而注意到上面<code>ui</code>声明的是个非指针的对象。在开源项目CloudCompare，以及看别人写的项目中，包含<code>ui</code>在内的，这些窗口相关的对象的声明都是声明成<strong>指针</strong>类型，所以我这里也声明成指针类型。而上面这个<code>ui</code>是创建项目时自定义生成的，它就没声明成指针类型，然后我就没搞明白为什么会这样，那些开源项目里的指针类型的<code>ui</code>都是他们后来自己改的吗？指针类型相较非指针类型有哪些好处吗？那这个初始创建的时候它为什么是默认生成的非指针类型啊？</p><p><strong>主窗口源文件<code>mainwindow.cpp</code></strong></p><img src="/2023/04/17/Qt-Note/image-20231228171042418.png" class="" title="image-20231228171042418"><p>在源文件中一是把槽函数进行实现，这里对<code>filter_voxel</code>新窗口类进行初始化，并调用<code>show()</code>函数进行窗口的显示</p><p>二是将具体的信号与槽函数进行连接，这里是将主窗口的一个按钮<code>pushButton</code>与刚才实现的槽函数进行连接，这样点击主窗口的按钮时，就会执行槽函数的命令，创建<code>filter_voxel</code>窗口并显示</p><p>效果如下：</p><img src="/2023/04/17/Qt-Note/image-20231229083639138.png" class="" title="image-20231229083639138"><h3 id="关于connect的写法"><a href="#关于connect的写法" class="headerlink" title="关于connect的写法"></a>关于connect的写法</h3><p>上面用到的connect的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">connect(ui.pushButton,&amp;QPushButton::clicked, <span class="hljs-keyword">this</span>, &amp;mainwindow::on_actionVoxel_Filter_triggered);<br></code></pre></td></tr></table></figure><p>这种写法使用了 C++11 引入的新的信号和槽语法。它通过使用成员函数指针来连接信号和槽。在这个例子中，<code>ui.pushButton</code> 是一个 <code>QPushButton</code> 对象，<code>clicked</code> 是 <code>QPushButton</code> 类的一个信号，<code>this</code> 是当前对象（通常是一个派生自 <code>QObject</code> 的类的实例），<code>on_actionVoxel_Filter_triggered</code> 是一个槽函数。</p><p>这种语法有一些优点，包括静态类型检查、更好的编译时错误检测和自动的函数重载解析。它是推荐的写法，尤其是在使用 C++11 或更高版本的编译器时。</p><hr><p>然后还有这样一种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">connect(ui.pushButton, SIGNAL(triggered()), <span class="hljs-keyword">this</span>, SLOT(on_actionVoxel_Filter_triggered()));<br></code></pre></td></tr></table></figure><p>这种写法使用了旧版本的信号和槽语法，称为字符串连接。在这种语法中，<code>SIGNAL</code> 和 <code>SLOT</code> 是宏，它们将信号和槽函数的名称作为字符串传递给 <code>connect</code> 函数。</p><p>这种语法在较早的 Qt 版本中广泛使用，但在较新的 Qt 版本中已经被废弃。它的缺点是不进行静态类型检查，容易出现拼写错误或函数重载引起的问题。因此，建议使用第一种 C++11 引入的语法，以获得更好的类型安全性和编译时错误检查。</p><hr><p><strong>总结：</strong>以后连接信号与槽函数都使用第一种写法，第二种旧版的写法应该是已经弃用了，虽然不会报错，但写了完全没有起到作用，信号与槽完全没有连接起来</p><h2 id="窗口之间相互传递数据"><a href="#窗口之间相互传递数据" class="headerlink" title="窗口之间相互传递数据"></a>窗口之间相互传递数据</h2><p>就以新建的窗口向主窗口传递数据为例：</p><p><strong><code>filter_voxel.h</code></strong></p><img src="/2023/04/17/Qt-Note/image-20240102095511731.png" class="" title="image-20240102095511731"><p>自定义信号<code>sendData(QString data)</code>，其中函数的参数列表，这里是一个<code>QString</code>，即是到时要传递的参数的数量和类型，这里可以知道到时只传递一个<code>QString</code>类型的数据</p><p>像下面这种，就是到时要传递四个<code>QString</code>类型的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendData</span><span class="hljs-params">(QString data1, QString data2, QString data3, QString data4)</span></span>;<br></code></pre></td></tr></table></figure><p><strong><code>filter_voxel.cpp</code></strong></p><img src="/2023/04/17/Qt-Note/image-20240102100232002.png" class="" title="image-20240102100232002"><p>当按钮被按下的时候使用<code>emit</code>触发自定义的信号，并将要传递的数据赋给形参，<code>ui-&gt;lineEdit-text()</code>即是将新窗口<code>lineEdit</code>中的文本传递给了之前自定义的形参<code>QString data</code></p><p>如果有多个参数要传，就都一一对应地写明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">emit <span class="hljs-title">sendData</span><span class="hljs-params">(ui-&gt;lineEdit-&gt;text(), ui-&gt;lineEdit_2-&gt;text(), ui-&gt;lineEdit_3-&gt;text(), ui-&gt;lineEdit_4-&gt;text())</span></span>;<br></code></pre></td></tr></table></figure><p><strong><code>mainwindow.cpp</code></strong></p><img src="/2023/04/17/Qt-Note/image-20240102102013144.png" class="" title="image-20240102102013144"><p>使用<code>connect</code>将信号与槽函数连接，信号的形参列表里的参数就传给了槽函数</p><img src="/2023/04/17/Qt-Note/image-20240102103220882.png" class="" title="image-20240102103220882"><p>参数传给槽函数，槽函数就正常用就行</p><hr><p>信号的参数数量与连接的槽函数的参数数量一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">connect(dialog_icp, SIGNAL(sendData(QString, QString, QString, QString)),<br>        <span class="hljs-keyword">this</span>, SLOT(Icp_clicked(QString, QString, QString, QString)));<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::Icp_clicked</span><span class="hljs-params">(QString data1, QString data2, QString data3, QString data4)</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h1 id="Qt多线程"><a href="#Qt多线程" class="headerlink" title="Qt多线程"></a>Qt多线程</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h1&gt;&lt;h2 id=&quot;clicked-、triggered-、toggled-三个信号的区别&quot;&gt;&lt;a href=&quot;#clicked-、triggered</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>编译CloudCompare</title>
    <link href="http://example.com/2023/04/06/CloudCompare-Cmake/"/>
    <id>http://example.com/2023/04/06/CloudCompare-Cmake/</id>
    <published>2023-04-06T13:11:17.000Z</published>
    <updated>2023-06-07T13:25:49.364Z</updated>
    
    <content type="html"><![CDATA[<p>CloudCompare，后续简称CC</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="Qt5"><a href="#Qt5" class="headerlink" title="Qt5"></a>Qt5</h3><p>CC是基于Qt5开发的，所以编译前需要安装Qt5，具体的Qt5版本根据CC源码的版本可能也有不同，需要自己去看源码中build.md文件说明。我要编译的CC版本是2.12.4，该版本的build.md文件提到2.11+版本之后的Qt版本要求为：5.9 &lt;= Qt &lt; 6.0. 所以我直接安装了Qt5的最新版本Qt5.15.2，就用的官网提供的在线安装包，具体的安装教程见“Qt在线安装包配置国内镜像源”。</p><h3 id="OpenGL（可跳过）"><a href="#OpenGL（可跳过）" class="headerlink" title="OpenGL（可跳过）"></a>OpenGL（可跳过）</h3><p>OpenGL其实电脑有自带的，但我看Cmake找到的那个自带的好像是win8版本的，不知道好用不好用，我就给他重新配了之前VS安装的win11版本的。这个OpenGL不用特意装，安装Windows SDK就会带着，通过VS installer就可以安。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406213202725.png" class="" title="image-20230406213202725"><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>上面两个依赖配置好之后去官方Github下载需要编译的源码，前面也提到过，我选了v2.12.4版本</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406213413137.png" class="" title="image-20230406213413137"><p>下下来之后要注意这个其实是不完整的，作者把核心算法库单独拿了出来，放在CCCoreLib项目里。</p><p>我们直接打开下载下来的文件，找到”CloudCompare/libs/qCC_db/extern/“ 目录，会发现里面是空的，但是用Cmake编译的时候他又会报错，告诉你需要这个文件夹中的文件，那如何找到这个项目的位置，只需要在GitHub中找到这个目录的位置，会发现官方在这里给出了超链接，跟着超链接就能找到需要的内容。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406214843292.png" class="" title="image-20230406214843292"><p>点击这个超链接就会跳转到CCCoreLib库的所在，这里直接下载这个默认的即可</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406214307674.png" class="" title="image-20230406214307674"><p>之后将下载下来的文件解压到之前空文件夹的位置即可，后面再细说。</p><p>然后这个其实也不是完整的，它里面也有需要去其他地方下载的文件，找到”CCCoreLib/extern/“ 目录，发现里面也有个超链接</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406215131181.png" class="" title="image-20230406215131181"><p>这个下载默认的即可，下载下来解压到对应的目录。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406215401556.png" class="" title="image-20230406215401556"><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>下载下来一共3个项目</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406215555439.png" class="" title="image-20230406215555439"><p>将nanoflann中的内容，全部放到”CCCoreLib-master/extern/nanoflann“目录中</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406215837581.png" class="" title="image-20230406215837581"><p>然后再把上面这个组合好的CCCoreLib-master中的内容全部放到”CloudCompare-2.12.4/libs/qCC_db/extern/CCCoreLib“目录里</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406220053868.png" class="" title="image-20230406220053868"><p>这样才算是得到完整的能够编译的CC文件，后面就用这个CloudCompare-2.12.4文件夹里的内容做Source，用Cmake编译即可。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>老三样，三个文件夹source、build、install</p><p>Cmake编译，记得把install路径改过来</p><h3 id="配置Qt5路径"><a href="#配置Qt5路径" class="headerlink" title="配置Qt5路径"></a>配置Qt5路径</h3><p>主要是配Qt5_DIR的路径，根据自己的Qt5安装路径来配，我的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5<br></code></pre></td></tr></table></figure><p>配完这个之后其他的Qt5路径它就自动识别了</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406220458490.png" class="" title="image-20230406220458490"><h4 id="Qt5LinguistTools路径"><a href="#Qt5LinguistTools路径" class="headerlink" title="Qt5LinguistTools路径"></a>Qt5LinguistTools路径</h4><p>有一个除外，每错，就是这个Qt5LinguistTools的路径，明明安装了，而且也跟它识别到的其他的Qt5组件在一个路径里，不知道它为什么自己找不到，需要我们自己再告诉它一下，路径为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:&#x2F;QT5&#x2F;5.15.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;Qt5LinguistTools<br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>其实只要在环境变量path中，将需要的Qt5版本对应的bin路径配置好，cmake的时候是会自动找到相应Qt5路径的，也不会找不到出现上述找不到Qt5LinguistTools路径的这个问题。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517194556596.png" class="" title="image-20230517194556596"><h3 id="配置OpenGL路径（可跳过）"><a href="#配置OpenGL路径（可跳过）" class="headerlink" title="配置OpenGL路径（可跳过）"></a>配置OpenGL路径（可跳过）</h3><p>他其实自己找到了一个路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:&#x2F;Program Files (x86)&#x2F;Windows Kits&#x2F;8.0&#x2F;Lib&#x2F;win8&#x2F;um&#x2F;x64<br></code></pre></td></tr></table></figure><img src="/2023/04/06/CloudCompare-Cmake/image-20230406221544652.png" class="" title="image-20230406221544652"><p>但我看他这个路径名，好像是win8的版本吧。。。我不太放心，就用了前面提到的用VS安装的win11版本的，具体路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:&#x2F;Windows Kits&#x2F;10&#x2F;Lib&#x2F;10.0.22000.0&#x2F;um&#x2F;x64<br></code></pre></td></tr></table></figure><img src="/2023/04/06/CloudCompare-Cmake/image-20230406221749652.png" class="" title="image-20230406221749652"><p>至于具体怎么找到这个路径的，还是用到之前其它教程提到的”everything“，搜索”OpenGL32.lib“，这个文件所在路径即为所求</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406221949937.png" class="" title="image-20230406221949937"><p><strong>补充：</strong>不过通过后续的实验来看，就用这个默认的就行，不用非得换。。。</p><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>之后就是一路configure、generate、Open Project老三样</p><p>然后在VS里”ALL_BUILD“右键生成、”INSTALL“右键生成即可</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230406222220907.png" class="" title="image-20230406222220907"><h2 id="编译文件说明"><a href="#编译文件说明" class="headerlink" title="编译文件说明"></a>编译文件说明</h2><p>编译前的源代码中有xxx.ui文件，可以通过该文件学习其中的界面布局</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230407165943192.png" class="" title="image-20230407165943192"><p>可以通过文本编辑器来打开xxx.ui文件，里面是用xml语言写的布局。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230407170845775.png" class="" title="image-20230407170845775"><p>也可以通过Qt Designer打开该xxx.ui文件，直接来看它的布局</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230407171054333.png" class="" title="image-20230407171054333"><p>不过上述两种都只能是辅助，比较好的还是要看与xxx.ui文件所对应的ui_xxx.h文件，直接看代码来学，再结合Qt Designer里的布局来学比较好，xml语言还是不太熟，而且一般也不会自己写xml来设计布局吧。。。</p><p>而对应的ui_xxx.h文件的生成是靠编译xxx.ui文件产生的，之前我们编译整个项目的时候，它也跟着生成了，编译生成的文件位置就在build文件夹当中</p><p>以Source源码中ccViewer子项目中的ccviewer.ui文件为例，其生成的对应的ui_ccviewer.h文件具体位置为<code>build/ccViewer</code></p><img src="/2023/04/06/CloudCompare-Cmake/image-20230407173005272.png" class="" title="image-20230407173005272"><p>不过根据具体项目的不同，可能具体位置也有点出入，不过都是编译生成再build文件中</p><p>具体的可以通过everything来搜索ui_xxx.h来确定具体的位置</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230407173607288.png" class="" title="image-20230407173607288"><h2 id="编译PCL插件"><a href="#编译PCL插件" class="headerlink" title="编译PCL插件"></a>编译PCL插件</h2><p>测试了一下编译生成的cloudcompare和ccviewer，发现不能读取pcd文件，（而且图标也比安装版的糊，不知道为什么。。。）</p><p>通过查阅资料，cc读取pcd文件是通过调用pcl功能实现的，所以在编译时，需要在PLUGIN栏中勾选QPCL选项。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230421114513526.png" class="" title="image-20230421114513526"><p>顺便提一嘴，这个GUI界面红色那部分上面有个“Grouped”，把这个勾选上就能将每一项分好组，找起来比较有条理，这里我一开始没选，每一项就都挤在一块了</p><p>选了QPCL这一项之后再Configure，就会根据系统环境变量里的PCL路径配置PCL相关的路径</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517200157590.png" class="" title="image-20230517200157590"><p>之后再configure，没有问题就generate+open Project即可。</p><p>注意这里用的PCL就用官方提供的AllInOne版本安装的一系列PCL文件，不要用自己编译的那些，没有必要。</p><p>之后就是在VS中，All_BUILD、INSTALL</p><p>检查一下install文件夹中，生成的cc相关exe所在位置是否有<strong>OpenNI2.dll</strong>文件，如果没有，用“everything”找到这个文件，把它复制过来。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517201136465.png" class="" title="image-20230517201136465"><p>至此编译生成的cc和ccviewer就可以读取pcd文件，使用pcl插件的功能了</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517201536852.png" class="" title="image-20230517201536852"><h3 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h3><h4 id="pcl路径的选择"><a href="#pcl路径的选择" class="headerlink" title="pcl路径的选择"></a>pcl路径的选择</h4><p>一开始我直接用了之前自己重新编译过的pcl，即E盘下的pcl所在位置：</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230421114707927.png" class="" title="image-20230421114707927"><p>结果配置好，点configure，报错力：</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230421122132860-1682053102945-1.png" class="" title="image-20230421122132860"><p>可能编译的时候有些东西没弄好导致后续像cc这种第三方要调用的时候，一些东西匹配不上，导致报错。</p><p>于是我又去pcl官方下了AllInOne版本安装包，并把它安在D盘，稍稍区分一下</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517202635310.png" class="" title="image-20230517202635310"><p>安好之后，编译选择pcl路径时都用D盘这个AllInOne版本的，就没有问题，直接就编译通过了。。。</p><h4 id="生成的cc-exe读取不了pcd文件"><a href="#生成的cc-exe读取不了pcd文件" class="headerlink" title="生成的cc.exe读取不了pcd文件"></a>生成的cc.exe读取不了pcd文件</h4><p>可以看到ALL_BUILD显示全部成功。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517203958182.png" class="" title="image-20230517203958182"><p>INSTALL也都没有问题。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517204337940.png" class="" title="image-20230517204337940"><p>题外话，生成INSTALL的时候可以不要直接右键-&gt;生成，而是选仅用于项目-&gt;仅生成INSTALL，这样即可在install文件夹中生成相应的目标文件，而且会快很多。上图其实就是仅用于项目-&gt;仅生成INSTALL的结果。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517204135730.png" class="" title="image-20230517204135730"><p>但是生成的cc.exe在读取pcd文件时会报错。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517204453563.png" class="" title="image-20230517204453563"><p>而且打开文件选项中也确实找不到pcd选项。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517204600853.png" class="" title="image-20230517204600853"><p>下面就开始了漫长的找问题环节。</p><h5 id="QPCL-IO-PLUGIN"><a href="#QPCL-IO-PLUGIN" class="headerlink" title="QPCL_IO_PLUGIN"></a>QPCL_IO_PLUGIN</h5><p>百度这个问题的时候，一个链接跳转到了cc官方开发人员的一个相同问题的回复，题主也是读取不了pcd文件，但是通过他们问答发现，他其实是没编译QPCL_IO_PLUGIN这部分导致的，但我已经都生成过了，所以其实不是这方面的问题。</p><p>不过还是了解到了与读取pcd文件相关的部分，就是生成文件中QPCL_IO_PLUGIN这部分</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230421163243751.png" class="" title="image-20230421163243751"><p>我还特意去看了install文件夹中，相应位置也都生成了相关的dll文件</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517212530860.png" class="" title="image-20230517212530860"><p>然后点开了这部分具体的项目文件来查看（这一看不要紧，后续好多路直接走歪了）</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230512203546468.png" class="" title="image-20230512203546468"><p>发现QPCL_IO_PLUGIN中的文件有报错，而输出又没显示，ALL_BUILD也都显示是成功，所以一直都被我忽略了。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517205156521.png" class="" title="image-20230517205156521"><p>错误提示为”<strong>C++ 命令行错误: 宏定义无效: BOOST_ALL_NO_LIB-DBOOST_ALL_NO_LIB</strong>“</p><p>去查了一下这个问题，通过修改PCL安装目录下cmake目录，里面有个PCLConfig.cmake文件，定位到该文件的第130行。将**if(WIN32 AND NOT MINGW)<strong>替换成</strong>if(WIN32 AND NOT MINGW AND NOT “${BOOST_DEFINITIONS}” MATCHES “BOOST_ALL_NO_LIB”)**。这样就不会报上述错误了。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230512204528335.png" class="" title="image-20230512204528335"><p>但是编译之后还是不行，仍然没法读PCD格式的文件。</p><h5 id="SDK（显然不是）"><a href="#SDK（显然不是）" class="headerlink" title="SDK（显然不是）"></a>SDK（显然不是）</h5><p>又注意到cmake编译时第一句”Selecting Windows SDK version 10.0.22000.0 to target Windows 10.0.22621.“ </p><img src="/2023/04/06/CloudCompare-Cmake/image-20230512202314854.png" class="" title="image-20230512202314854"><p>我去看了一下确实没安Windows 10.0.22621版本的SDK，然后我又去重新安了一下这个版本的SDK</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230512202833414.png" class="" title="image-20230512202833414"><p>安完这个SDK之后，再来编译发现确实不太一样</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230512203003590.png" class="" title="image-20230512203003590"><p>但最后结果一样的，还是不行，pcd格式识别不了。</p><h5 id="VS版本（显然不是）"><a href="#VS版本（显然不是）" class="headerlink" title="VS版本（显然不是）"></a>VS版本（显然不是）</h5><p>有人提到说qt5.15.2对应的版本是msvc2019，我用vs2022来编译是不有问题？我一开始是不屑的，但当我死活调不出来时，我也怀疑是不是跟这玄学有点关系？于是我又安了个vs2019来做编译环境，结果一样的，还是不行。然后也提到过我安的东西有点多？可能哪些东西冲突了？具体指什么有点多我其实也不知道。。。一开始我也是不屑的，可还是找不到原因，那快试试吧。然后安了个虚拟机，配了win10的环境，配win10环境是我怀疑是不是win11的编译环境有点问题，然后在安好vs2019、cmake、cc源码、qt5、pcl，只安了编译cc需要的东西，折腾一天多。然后编译出来的cc.exe还是读不了pcd文件。</p><p>虽说花了一天多有点亏，但也让我确信，肯定跟上面vs版本、编译环境多之类的问题无关<span style="background:#000000;color:black" >（怎么可能是这种问题。。。真是这种问题我也不是没遇到过，应该是能看出来的，我就是太容易被别人的意见影响，尤其不知道对面深浅的时候，容易把对面的意见当真）</span></p><p>主要是肯定了我之前配置的环境什么的都没有问题，毕竟之前又说我vs版本，又说东西安的有点多，搞得我好像是外行，不知道自己在干嘛一样。。。</p><p>后续就是专心找到底是哪里出了问题。</p><h5 id="GitHub-issues"><a href="#GitHub-issues" class="headerlink" title="GitHub-issues"></a>GitHub-issues</h5><p>慢慢学会了去cc官方的GitHub中，有专门的答疑区，即“issues”，其中有各种关于cc这个项目的问题、建议即答疑</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517211729424.png" class="" title="image-20230517211729424"><p>通过对其中众多帖子的浏览，找了3、4个相关问题的答疑帖来看，大致有了点思路。</p><p>打开自己编译生成的有问题的cc.exe文件，观察下方的控制台输出</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517212034556.png" class="" title="image-20230517212034556"><p>比较正常能够读取pcd文件官方下载版的cc.exe来看</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517212334064.png" class="" title="image-20230517212334064"><p>这样配合cc开发这的回答，基本可以确认就是这个QPCL_IO_PLUGIN.dll没有被正确识别为插件，导致的没法读取pcd文件。</p><p>然后我又针对这个问题开始查资料，cc开发这提到可能是缺少qcl相关的dll导致没有程序没有把QPCL_IO_PLUGIN.dll正确识别为插件。但我去检查了，pcl相关的dll都已经加载到cc.exe所在位置了</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517213136660.png" class="" title="image-20230517213136660"><p>cc开发者还提到了一个判断dll缺失的工具“dependency walker”，通过把想要查看的dll或exe拖到该工具中，帮助快速查看缺少哪些dll文件。</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517213827451.png" class="" title="image-20230517213827451"><p>但其实到最后我也没搞明白这东西怎么用。。。</p><h5 id="OpenNI2-dll"><a href="#OpenNI2-dll" class="headerlink" title="OpenNI2.dll"></a>OpenNI2.dll</h5><p>最后解决问题还是靠的CSDN上国人写的帖子，他在其中也提到了这种插件加载失败的问题，并给出了解决办法：找不到PCL相关插件的时候，把OpenNI2.dll添加到cc.exe所在位置。</p><p>我去看了眼生成的文件中，cc.exe所在位置中的确没有OpenNI2.dll，于是去当时OpenNI2的安装路径中找到该文件（当然是everything来找的），把它复制到了cc.exe所在位置</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517214455957.png" class="" title="image-20230517214455957"><p>然后再打开cc.exe，查看支持的打开文件类型，奇迹出现了</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517214658045.png" class="" title="image-20230517214658045"><p>再看一眼控制台，这次插件也确实地加载上了</p><img src="/2023/04/06/CloudCompare-Cmake/image-20230517214844705.png" class="" title="image-20230517214844705"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面结果来看，竟然真是缺了OpenNI2.dll导致的。。。难蚌。</p><p>所以之前编译等等一系列步骤其实都没有问题，包括前面提到的点开具体QPCL_IO_PLUGIN项目有报错的问题，也不用在意。毕竟ALL_BUILD下面确实都显示成功了。</p><p>应该就是OpenNI2这个东西比较“各色”，之前安装pcl的时候它就表现不凡，跟别人的安装过程、位置都不一样。所以在INSTALL的过程中，虽然pcl相关的dll都正常加载到了cc.exe所在的位置，而这个OpenNI2.dll并没有被INSTALL加载过去。不过师兄说他直接编译成功了，那看来他的INSTALL有正确的把OpenNI2.dll加载过去？也可能师兄的环境变量path里配置了OpenNI2的环境？具体不太清楚，可能还有哪里有点问题，导致我的INSTALL没有正确加载OpenNI2.dll。不过鉴于我在舍友电脑、宿舍电脑、虚拟机电脑、工位电脑都试过，结果这个INSTALL都没把OpenNI2.dll加载过去来看，我倾向于是师兄比我多配置了点环境变量（maybe？）。当然也可能就是我哪步有点问题？（不可能啊。。。）</p><p>另外从帮我解决问题的CSDN帖子的题主的描述来看，他是通过之前提到“Dependency Walker”检查出来的，但通过我的体验来看，“Dependency Walker”丝毫没有给我提示过缺少OpenNI2.dll的问题。</p><p>当然可能是我没学会怎么用，感觉可以后续试着找找资料学一下，就像题主说的：“怎么才能知道exe运行缺什么dll？有时exe自己会提示，但是有些偏不提示，我们也不是神仙，也猜不到，那就用Dependency Walker检查一下”</p><p>后续开发遇到相关问题也能比较好下手。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>之后我以为生成exe就算结束了，把pcl在环境变量里的路径从d换回了e，结果运行时又读取不了pcd格式的文件了。。。</p><p>可能是因为依托于D路径下的pcl文件编译生成的程序，后续读取pcd格式需要的pcl相关文件还是要从D盘路径下的pcl文件来找？依托于D盘pcl的bin文件。。。</p><p>所以我又把路径从E改回D了，不过本来我自己编译E盘的pcl是因为要重新编译里面的vtk，要用vtk的显示模块，如果后续在ccviewer基础上二次开发，那也用不到vtk的显示，也就用不到自己编译的E盘的pcl了，也没啥影响，唯一的问题就是PCL的配置文件路径又要改了。。。</p><hr><p>后续又发现，改变path环境变量里的pcl路径，是用cmake编译的cc和ccviewer加载不了pcl_io_plugin，而vs调式启动的ccviewer可以，应该是因为vs调试时是动态加载dll，所以可以。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CloudCompare，后续简称CC&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;&lt;h3 id=&quot;Qt5&quot;&gt;&lt;a href=&quot;#Qt5&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CloudCompare" scheme="http://example.com/tags/CloudCompare/"/>
    
  </entry>
  
  <entry>
    <title>Wamp安装</title>
    <link href="http://example.com/2023/03/21/WampServer-download/"/>
    <id>http://example.com/2023/03/21/WampServer-download/</id>
    <published>2023-03-21T01:55:56.000Z</published>
    <updated>2023-04-06T03:12:33.010Z</updated>
    
    <content type="html"><![CDATA[<p>写这个也是想吐槽一下他这个网站的下载设计</p><p>下面这个是他官方网站的主页，可以看到下面，下面那么大一个黄色按钮，还写着wamp对应的版本号，一眼看上去就是以为点这个下载</p><img src="/2023/03/21/WampServer-download/image-20230321092638643.png" class="" title="image-20230321092638643"><p>然后点击之后就会发现没什么反应，当时还以为是要挂梯子之类的原因，结果检查这个按钮超链接的路径，发现这个按钮链接的是当前页面，也就是说点这个按钮只是不停的跳转到当前页面而已。。。</p><img src="/2023/03/21/WampServer-download/image-20230321093626347.png" class="" title="image-20230321093626347"><p>那么真正的下载按钮在哪里呢？在黄色按钮上面的“DOWNLOADS”部分，点击“SourceForge”，就会前往真正的下载页面。而且其实读一读“DOWNLOADS”部分里的英文也确实说了让我们去”SourceForge“下载。但是吧。。。就挺搞的。。。</p><img src="/2023/03/21/WampServer-download/image-20230321093920065.png" class="" title="image-20230321093920065"><p>下面就是真正的下载页面了，可以直接点击绿色按钮下载最新安装包即可。有其他需求的也可以去下面各个文件夹看一看，看看有没有自己需要的东西。</p><img src="/2023/03/21/WampServer-download/image-20230321094353450.png" class="" title="image-20230321094353450"><p>补充：后面发现点击黄色按钮右下角的”changelog“也可以，会自动跳转到对应版本的下载页面，等待5s后会自动开始下载</p><img src="/2023/03/21/WampServer-download/image-20230321095006509.png" class="" title="image-20230321095006509"><p>题外话，上面说的对应版本指的是64位、32位这个，不是指wamp版本号。因为可以看到黄色按钮明明写着3.2.6，下面小字说的却是3.3.0，然后实际安装时，安装包的版本也是3.3.0的。当然这也没什么所谓，就是吐槽一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这个也是想吐槽一下他这个网站的下载设计&lt;/p&gt;
&lt;p&gt;下面这个是他官方网站的主页，可以看到下面，下面那么大一个黄色按钮，还写着wamp对应的版本号，一眼看上去就是以为点这个下载&lt;/p&gt;
&lt;img src=&quot;/2023/03/21/WampServer-download/i</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Wamp" scheme="http://example.com/tags/Wamp/"/>
    
  </entry>
  
  <entry>
    <title>Qt在线安装包配置国内镜像源(已失效)</title>
    <link href="http://example.com/2023/03/20/Qt6.4-mirror-download/"/>
    <id>http://example.com/2023/03/20/Qt6.4-mirror-download/</id>
    <published>2023-03-20T13:34:56.000Z</published>
    <updated>2023-05-15T11:59:05.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="23-5-15更新"><a href="#23-5-15更新" class="headerlink" title="23-5-15更新"></a>23-5-15更新</h2><p>Qt6直接商业化，在线安装包直接变成商业Qt安装包，而且也不再提供Qt5安装了，只提供qt5.15.2的静态资源包。。。或者Qt5.12.12的离线安装包。</p><p>———————————————————————————————–分界线———————————————————————————————————————</p><p>最近在新电脑上重新装Qt6.4，学校的网不太行，安装时总是报错，干脆找了找教程，使用Qt官方的在线安装包配合国内镜像源来安装，这里记录一下。</p><h2 id="Qt在线安装包下载"><a href="#Qt在线安装包下载" class="headerlink" title="Qt在线安装包下载"></a>Qt在线安装包下载</h2><p>他官网的安装包找起来绕过来绕过去，这里正好记录一下。</p><p>打开Qt官网 <a href="https://www.qt.io/">https://www.qt.io/</a> ，找到右上角的 ”Download.Try.“ 点击进入</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320192030545.png" class="" title="image-20230320192030545"><p>进入的新页面拉到最底，找到”Download Qt for open source use”部分，点击”Go open source”进入下一个界面</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320192432884.png" class="" title="image-20230320192432884"><p>在进入的新页面再往下滑，也是快划到底的地方有个”Download the Qt Online Installer” ，点击这个按钮</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320192910732.png" class="" title="image-20230320192910732"><p>本来以为这就开始下载在线安装包了，结果还是进入新页面，点击新页面的这个”Download”，就真的开始下载在线安装包了</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320193314913.png" class="" title="image-20230320193314913"><p>服了，下个在线安装包点了4个download，还都不重样，牛。</p><h2 id="配置国内镜像源"><a href="#配置国内镜像源" class="headerlink" title="配置国内镜像源"></a>配置国内镜像源</h2><p>直接使用这个在线安装包的话，因为资源服务器在国外，难免网不行导致安装时出错，干脆直接配置国内镜像源来安装。</p><p>找到Qt在线安装的存放路径，在空白处“shift+右键”，选择“打开Powershell窗口”</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320194136944.png" class="" title="image-20230320194136944"><p>输入命令<code>.\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt</code>，注意该命令前半部分，是自己下载的qt在线安装包的名字，可能不一样，根据自己的情况改一改。</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320194447596.png" class="" title="image-20230320194447596"><p>输完之后回车，会不带任何提示地打开该安装包</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320194827749.png" class="" title="image-20230320194827749"><p>之后就是正常的qt安装过程了，根据自己的需求选就行</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320195018161.png" class="" title="image-20230320195018161"><p>之后就看各自的网速了</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320195149839.png" class="" title="image-20230320195149839"><p>资源下载完之后就开始解压缩，等进度条100%，qt就算是安好了</p><img src="/2023/03/20/Qt6.4-mirror-download/image-20230320203628573.png" class="" title="image-20230320203628573">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;23-5-15更新&quot;&gt;&lt;a href=&quot;#23-5-15更新&quot; class=&quot;headerlink&quot; title=&quot;23-5-15更新&quot;&gt;&lt;/a&gt;23-5-15更新&lt;/h2&gt;&lt;p&gt;Qt6直接商业化，在线安装包直接变成商业Qt安装包，而且也不再提供Qt5安装了，只提</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习心得</title>
    <link href="http://example.com/2023/03/16/SpringBoot/"/>
    <id>http://example.com/2023/03/16/SpringBoot/</id>
    <published>2023-03-16T13:14:39.000Z</published>
    <updated>2023-03-20T12:51:19.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面写了个Vue的学习心得，马上就想起来跟Vue前端技术配合的后端技术SpringBoot好像好久没用了，感觉也需要写个Blog总结一下，不然以后真忘了无从下手就乐了。不过也不至于，当时就是照着YouTube一个教程学得，那教程还不错，大不了再看看那个视频，就是时间可能有点长。还是找时间写一写，加深一下印象吧。</p><p>就以之前写的仓库管理系统为例，大概介绍一下项目结构，每个文件干什么的，再写写经常配合使用，操作数据的MyBatis-Plus的使用，包括自定义功能之类的。</p><p>干脆也可以把Thymeleaf也介绍一下。</p><p>感觉叫学习心得也不大对，我是学完了（也不对，学了一点吧），在用的时候得出的一些心得。那叫使用心得吧，也不大对，你那才用了多点功能啊。。。就当是在使用中深入学习的意思吧，就叫学习心得算了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面写了个Vue的学习心得，马上就想起来跟Vue前端技术配合的后端技术SpringBoot好像好久没用了，感觉也需要写个Blog总结一下，不</summary>
      
    
    
    
    <category term="后端技术学习" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="MyBatis-Plus" scheme="http://example.com/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>Vue互动教程学习</title>
    <link href="http://example.com/2023/03/16/Vue-Interactive-Tutorial/"/>
    <id>http://example.com/2023/03/16/Vue-Interactive-Tutorial/</id>
    <published>2023-03-16T12:02:38.000Z</published>
    <updated>2024-01-24T03:37:26.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue，易学易用，性能出色，适用场景丰富的 Web 前端框架。 </p><p>以上为官网给出的精炼概括，之前本科实习期间的项目是用Vue+SpringBoot来前后端分离地开发一个项目，就是那会儿接触到原来还有这么个东西。但是那会儿在忙考研，对搞前端又没有兴趣，所以当时分工的时候选择了后端开发，稍微学了学SpringBoot。而对前端开发技术Vue便是毫不关心，一点没学，现在想想也有点可惜，毕竟当时实习期间那个教程我感觉挺好的，应该是有很多干货的。</p><p>现在之所以想学Vue了，是发现想自己搞点Web项目的时候，只会后端技术完全不够，前端没有人给你写，只能去找别人的模板，然后用Thymeleaf来前后端交互，感觉不够自由，不够灵活。前端嘛，感觉还是根据自己的需求来设计比较好，到时候跟自己写的后端搭配应该也更方便些。</p><p>当然，以上还是我的幻想，Vue还没开始学，不知道到时候设计前端的这个难度具体到底如何。美好的幻想：想要个什么样的前端界面，都能给他弄出来，不求那种花里胡哨的，就基本功能能实现，界面设计得能好看点也就心满意足了。</p><p>下面开始Vue的学习，主要是看Vue的官网 <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p><p>里面有比较详细的介绍了Vue的基本组件等。。。应该是吧，我也还没仔细看</p><p>这里主要是想介绍一下官网提供的一个互动教程<a href="https://cn.vuejs.org/tutorial/#step-1">https://cn.vuejs.org/tutorial/#step-1</a></p><p>该教材支持边教边实践，左边教着内容，右边给你地方写代码让你试。下面的内容主要围绕跟着这个互动教程学习过程的心得。</p><hr><p><strong>下面笔记记的代码、代码解释，最好是拿到互动教程的页面，对照着实际页面生成的效果来看，更容易有深刻的理解。</strong></p><hr><h1 id="互动教程"><a href="#互动教程" class="headerlink" title="互动教程"></a>互动教程</h1><h2 id="声明式渲染-reactive、ref"><a href="#声明式渲染-reactive、ref" class="headerlink" title="声明式渲染(reactive、ref)"></a>声明式渲染(reactive、ref)</h2><p>Vue 的核心功能是<strong>声明式渲染</strong>：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。</p><p>能在改变时触发更新的状态被称作是<strong>响应式</strong>的。我们可以使用 Vue 的 <code>reactive()</code> API 来声明响应式状态。由 <code>reactive()</code> 创建的对象都是 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>，其行为与普通对象一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> counter = reactive(&#123;<br>  count: <span class="hljs-number">0</span><br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(counter.count) <span class="hljs-comment">// 0</span><br>counter.count++<br></code></pre></td></tr></table></figure><p>其中reactive中可以定义有多个属性，属性之间用逗号“，”分隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> student = reactive(&#123;<br>    name: <span class="hljs-string">&#x27;SJH&#x27;</span>,<br>    age: <span class="hljs-number">24</span>,<br>    wages: <span class="hljs-number">200</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><code>reactive()</code> 只适用于对象 (包括数组和内置类型，如 <code>Map</code> 和 <code>Set</code>)。而另一个 API <code>ref()</code> 则可以接受任何值类型。<code>ref</code> 会返回一个包裹对象，并在 <code>.value</code> 属性下暴露内部值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> message = ref(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(message.value) <span class="hljs-comment">// &quot;Hello World!&quot;</span><br>message.value = <span class="hljs-string">&#x27;Changed&#x27;</span><br></code></pre></td></tr></table></figure><p><code>reactive()</code> 和 <code>ref()</code> 的细节在<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html">指南 - 响应式基础</a>一节中有进一步讨论。</p><p>在组件的 <code>&lt;script setup&gt;</code> 块中声明的响应式状态，可以直接在模板中使用。下面展示了我们如何使用双花括号语法，根据 <code>counter</code> 对象和 <code>message</code> ref 的值渲染动态文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count is: &#123;&#123; counter.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意我们在模板中访问的 <code>message</code> ref 时不需要使用 <code>.value</code>：它会被自动解包，让使用更简单。</p><p>在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Attribute绑定-v-bind-“-“"><a href="#Attribute绑定-v-bind-“-“" class="headerlink" title="Attribute绑定(v-bind “ : “)"></a>Attribute绑定(v-bind “ : “)</h2><p>Attribute绑定，<code>v-bind</code>指令，拿<code>div</code>举例<code>&lt;div v-bind:id=&quot;dynamicID&quot;&gt;&lt;/div&gt;</code>，其中的<code>v-bind</code>一简写，就变成了<code>&lt;div :id=&quot;dynamicID&quot;&gt;&lt;/div&gt;</code>，就剩个冒号了，这一般还真不知道是个什么意思，也没法查起。</p><p>在 Vue 中，mustache 语法 (即双大括号) 只能用于文本插值。为了给 attribute 绑定一个动态值，需要使用 <code>v-bind</code> 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>指令</strong>是由 <code>v-</code> 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。和文本插值类似，指令的值是可以访问组件状态的 JavaScript 表达式。关于 <code>v-bind</code> 和指令语法的完整细节请详阅<a href="https://cn.vuejs.org/guide/essentials/template-syntax.html">指南 - 模板语法</a>。</p><p>冒号后面的部分 (<code>:id</code>) 是指令的“参数”。此处，元素的 <code>id</code> attribute 将与组件状态里的 <code>dynamicId</code> 属性保持同步。</p><p>由于 <code>v-bind</code> 使用地非常频繁，它有一个专门的简写语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，试着把一个动态的 <code>class</code> 绑定添加到这个 <code>&lt;h1&gt;</code> 上，并使用 <code>titleClass</code> 的 ref 作为它的值。如果绑定正确，文字将会变为红色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#39;vue&#39;<br><br>const titleClass &#x3D; ref(&#39;title&#39;)<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;h1 :class &#x3D; titleClass&gt;Make me red&lt;&#x2F;h1&gt; &lt;!-- 此处添加一个动态 class 绑定 --&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style&gt;<br>.title &#123;<br>  color: red;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>使用 <strong><code>&lt;script setup&gt;</code></strong> 标签来编写 Vue 3 的组合式 API 代码。</p><p>在 <code>&lt;style&gt;</code> 标签中，定义了 <code>.title</code> 类选择器，将文本颜色设置为红色。</p><p>在渲染时将 <code>&lt;h1&gt;</code> 元素的 class 设置为 <code>&#39;title&#39;</code>，从而应用 <code>.title</code> 类的样式，使文本颜色变为红色。</p><p>设置的时候用到的是动态绑定，让<code>&lt;h1&gt;</code>的<code>class</code>设为<code>titleClass</code>，而<code>titleClass</code>的值为<code>title</code>，从而实现<code>class = title</code>的赋值</p><h2 id="事件监听-v-on-“-“"><a href="#事件监听-v-on-“-“" class="headerlink" title="事件监听(v-on “ @ “)"></a>事件监听(v-on “ @ “)</h2><p>事件监听，<code>v-on</code>指令，拿<code>button</code>举例<code>&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</code>，可以简写为<code>&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</code>，这种@的写法我感觉还真见过不少，当时没学不知道是什么意思，原来是事件监听<code>v-on</code>的缩写。</p><p>我们可以使用 <code>v-on</code> 指令监听 DOM 事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button v-on:click&#x3D;&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><p>因为其经常使用，<code>v-on</code> 也有一个简写语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click&#x3D;&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><p>此处，<code>increment</code> 引用了一个在 <code>&lt;script setup&gt;</code> 中声明的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#39;vue&#39;<br><br>const count &#x3D; ref(0)<br><br>function increment() &#123;<br>  &#x2F;&#x2F; 更新组件状态<br>  count.value++<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>在函数中，我们可以通过修改 ref 来更新组件状态。</p><p>事件处理函数也可以使用内置表达式，并且可以使用修饰符简化常见任务。这些细节包含在<a href="https://cn.vuejs.org/guide/essentials/event-handling.html">指南 - 事件处理</a>。</p><p>现在，尝试自行实现 <code>increment</code> 函数并通过使用 <code>v-on</code> 将其绑定到按钮上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#39;vue&#39;<br><br>const count &#x3D; ref(0)<br>function sub()&#123;<br>  count.value--<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;!-- 使此按钮生效 --&gt;<br>  &lt;button @click&#x3D;&quot;sub&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><h2 id="表单绑定-v-model"><a href="#表单绑定-v-model" class="headerlink" title="表单绑定 (v-model)"></a>表单绑定 (v-model)</h2><p>我们可以同时使用 <code>v-bind</code> 和 <code>v-on</code> 来在表单的输入元素上创建双向绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input :value&#x3D;&quot;text&quot; @input&#x3D;&quot;onInput&quot;&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">onInput</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    <span class="hljs-comment">// v-on 处理函数会接收原生 DOM 事件</span><br>    <span class="hljs-comment">// 作为其参数。</span><br>    <span class="hljs-built_in">this</span>.text = e.target.value<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>试着在文本框里输入——你会看到 <code>&lt;p&gt;</code> 里的文本也随着你的输入更新了。</p><p>为了简化双向绑定，Vue 提供了一个 <code>v-model</code> 指令，它实际上是上述操作的语法糖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-model&#x3D;&quot;text&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>v-model</code> 会将被绑定的值与 <code>&lt;input&gt;</code> 的值自动同步，这样我们就不必再使用事件处理函数了。</p><p><code>v-model</code> 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在<a href="https://cn.vuejs.org/guide/essentials/forms.html">指南 - 表单绑定</a>中讨论了更多的细节。</p><p>现在，试着用 <code>v-model</code> 把代码重构一下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      text: &#39;&#39;<br>    &#125;<br>  &#125;,<br>  &#x2F;&#x2F;methods: &#123;<br>  &#x2F;&#x2F;  onInput(e) &#123;<br>  &#x2F;&#x2F;    this.text &#x3D; e.target.value<br>  &#x2F;&#x2F;  &#125;<br>  &#x2F;&#x2F;&#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>&lt;!--   &lt;input :value&#x3D;&quot;text&quot; @input&#x3D;&quot;onInput&quot; placeholder&#x3D;&quot;Type here&quot;&gt; --&gt;<br>  &lt;input v-model&#x3D; &quot;text&quot; placeholder&#x3D;&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;p&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><p>我们注意到当使用<code>v-model</code>关键字时，就不需要使用<code>methods</code>中的<code>onInput(e)</code>函数来控制<code>text</code>的变化了。</p><p>因为text已经使用了v-model关键字，将<code>data()&#123;return&#123;text: &#39;&#39;&#125; &#125;</code>中的<code>text</code>变量与<code>&lt;input&gt;</code>块中输入的<code>value</code>值进行了双向绑定，即在<code>input</code>中输入一个值就会直接改变<code>text</code>的值，而且是动态进行的</p><p>如果使用上面<code>&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;</code>这种传统绑定发放，就还是需要上面注释掉的<code>methods</code>中的<code>onInput(e)</code>方法</p><h2 id="条件渲染-v-if"><a href="#条件渲染-v-if" class="headerlink" title="条件渲染 (v-if)"></a>条件渲染 (v-if)</h2><p>我们可以使用 <code>v-if</code> 指令来有条件地渲染元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;<br></code></pre></td></tr></table></figure><p>这个 <code>&lt;h1&gt;</code> 标签只会在 <code>awesome</code> 的值为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">真值 (Truthy)</a> 时渲染。若 <code>awesome</code> 更改为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值 (Falsy)</a>，它将被从 DOM 中移除。</p><p>我们也可以使用 <code>v-else</code> 和 <code>v-else-if</code> 来表示其他的条件分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;<br>&lt;h1 v-else&gt;Oh no 😢&lt;&#x2F;h1&gt;<br></code></pre></td></tr></table></figure><p>现在，示例程序同时展示了两个 <code>&lt;h1&gt;</code> 标签，并且按钮不执行任何操作。尝试给它们添加 <code>v-if</code> 和 <code>v-else</code> 指令，并实现 <code>toggle()</code> 方法，让我们可以使用按钮在它们之间切换。</p><p>更多细节请查阅 <code>v-if</code>：<a href="https://cn.vuejs.org/guide/essentials/conditional.html">指南 - 条件渲染</a></p><p>简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      awesome: true<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    toggle() &#123;<br>      this.awesome &#x3D; !this.awesome<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click&#x3D;&quot;toggle&quot;&gt;toggle&lt;&#x2F;button&gt;<br>  &lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;<br>  &lt;h1 v-else&gt;Oh no 😢&lt;&#x2F;h1&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><h3 id="data-属性的用法"><a href="#data-属性的用法" class="headerlink" title="data()属性的用法"></a>data()属性的用法</h3><p>在Vue中，<code>data</code>属性用于定义组件实例的数据。它是一个函数，返回一个包含数据属性的对象。这些数据属性可以在组件的模板或方法中使用。</p><p>以下是使用<code>data</code>属性的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      message: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span>,<br>      count: <span class="hljs-number">0</span><br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>data</code>属性是一个函数，返回一个对象。该对象包含两个属性：<code>message</code>和<code>count</code>。这些属性可以在组件的模板中绑定数据，或在组件的方法中进行读取和修改。</p><p>在模板中使用数据属性时，可以通过双大括号插值语法（<code>&#123;&#123; &#125;&#125;</code>）将其绑定到HTML内容中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>message</code>属性和<code>count</code>属性被绑定到两个<code>&lt;p&gt;</code>元素中的文本内容。当组件渲染时，模板中的插值表达式将被实际的属性值替换。</p><p>在组件的方法中，可以通过<code>this</code>关键字访问数据属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      message: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span>,<br>      count: <span class="hljs-number">0</span><br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">incrementCount</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.count++;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>incrementCount</code>方法通过<code>this.count</code>访问和修改<code>count</code>属性的值。通过这种方式，你可以在方法中操作数据属性。</p><p>需要注意的是，Vue的响应式系统会跟踪数据属性的变化，并在其发生变化时自动更新相关的视图。这意味着，如果你修改了数据属性的值，与之相关的模板将自动更新以反映这些变化。</p><h2 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染 (v-for)"></a>列表渲染 (v-for)</h2><p>我们可以使用 <code>v-for</code> 指令来渲染一个基于源数组的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>  &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.id&quot;&gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure><p>这里的 <code>todo</code> 是一个局部变量，表示当前正在迭代的数组元素。它只能在 <code>v-for</code> 所绑定的元素上或是其内部访问，就像函数的作用域一样。</p><p>注意，我们还给每个 todo 对象设置了唯一的 <code>id</code>，并且将它作为<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key">特殊的 <code>key</code> attribute</a> 绑定到每个 <code>&lt;li&gt;</code>。<code>key</code> 使得 Vue 能够精确的移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。</p><p>更新列表有两种方式：</p><ol><li>在源数组上调用<a href="https://stackoverflow.com/questions/9009879/which-javascript-array-functions-are-mutating">变更方法</a>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.todos.push(newTodo)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用新的数组替代原数组：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.todos = <span class="hljs-built_in">this</span>.todos.filter(<span class="hljs-comment">/* ... */</span>)<br></code></pre></td></tr></table></figure><p>这里有一个简单的 todo 列表——试着实现一下 <code>addTodo()</code> 和 <code>removeTodo()</code> 这两个方法的逻辑，使列表能够正常工作！</p><p>关于 <code>v-for</code> 的更多细节：<a href="https://cn.vuejs.org/guide/essentials/list.html">指南 - 列表渲染</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;script&gt;<br>&#x2F;&#x2F; 给每个 todo 对象一个唯一的 id<br>let id &#x3D; 0<br><br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      newTodo: &#39;&#39;,<br>      todos: [<br>        &#123; id: id++, text: &#39;Learn HTML&#39; &#125;,<br>        &#123; id: id++, text: &#39;Learn JavaScript&#39; &#125;,<br>        &#123; id: id++, text: &#39;Learn Vue&#39; &#125;<br>      ]<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    addTodo() &#123;<br>      this.todos.push(&#123; id: id++, text: this.newTodo &#125;) &#x2F;&#x2F;按照&#123; &#125;中的格式更新todos<br>      this.newTodo &#x3D; &#39;&#39; &#x2F;&#x2F;更新完todos之后，初始化newTodo，为下一次输入做准备<br>    &#125;,<br>    removeTodo(todo) &#123;<br>      this.todos &#x3D; this.todos.filter((t) &#x3D;&gt; t !&#x3D;&#x3D; todo) &#x2F;&#x2F;注2<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;form @submit.prevent&#x3D;&quot;addTodo&quot;&gt; &lt;!-- 注1--&gt;<br>    &lt;input v-model&#x3D;&quot;newTodo&quot;&gt;  &lt;!-- 使用v-model将input的值与变量newTodo双向绑定 --&gt;<br>    &lt;button&gt;Add Todo&lt;&#x2F;button&gt;    <br>  &lt;&#x2F;form&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.id&quot;&gt;<br>      &#123;&#123; todo.text &#125;&#125;<br>      &lt;button @click&#x3D;&quot;removeTodo(todo)&quot;&gt;X&lt;&#x2F;button&gt;<br>    &lt;&#x2F;li&gt;<br>  &lt;&#x2F;ul&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;form @submit.prevent=&quot;addTodo&quot;&gt;</code> ：这是一个Vue.js中的模板语法，用于在表单提交时触发<code>addTodo</code>方法，并阻止表单默认的提交行为。</p><p>在这个模板中，<code>@submit</code>是Vue.js的事件绑定语法，表示监听表单的提交事件。<code>.prevent</code>是一个修饰符，用于阻止表单的默认提交行为，即防止页面刷新。</p><p><code>addTodo</code>是一个在Vue实例中定义的方法，它会在表单提交时被调用。通过<code>@submit.prevent</code>绑定到表单的提交事件，可以在调用<code>addTodo</code>方法之前阻止表单的默认提交行为。</p></li><li><p><code>this.todos = this.todos.filter((t) =&gt; t !== todo)</code>：这段代码是一个在Vue.js中使用的数组过滤操作，它会从<code>this.todos</code>数组中移除与指定的<code>todo</code>对象相等的元素。在这段代码中，<code>this.todos</code>是一个数组，<code>.filter()</code>是JavaScript数组的方法之一，它用于遍历数组并返回一个新的数组，该新数组包含满足指定条件的元素。在这里，<code>.filter((t) =&gt; t !== todo)</code>表示使用一个箭头函数作为过滤条件。箭头函数中的<code>(t) =&gt; t !== todo</code>是一个回调函数，它接收数组中的每个元素作为参数<code>t</code>，并返回一个布尔值，用于确定是否保留该元素。具体到这段代码中，<code>(t) =&gt; t !== todo</code>表示只保留与<code>todo</code>对象不相等的元素。如果元素与<code>todo</code>对象相等，它将被过滤掉，不包含在最终的过滤结果中。最后，通过将过滤结果赋值给<code>this.todos</code>，实现了从<code>this.todos</code>数组中移除与指定的<code>todo</code>对象相等的元素。请注意，这段代码中的<code>this</code>指的是Vue实例或组件的上下文，在Vue组件中可以使用<code>this</code>来访问组件的数据和方法。</p></li></ul><h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 (computed)"></a>计算属性 (computed)</h2><p>让我们在上一步的 todo 列表基础上继续。现在，我们已经给每一个 todo 添加了切换功能。这是通过给每一个 todo 对象添加 <code>done</code> 属性来实现的，并且使用了 <code>v-model</code> 将其绑定到复选框上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;li v-for&#x3D;&quot;todo in todos&quot;&gt;<br>  &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;todo.done&quot;&gt;<br>  ...<br>&lt;&#x2F;li&gt;<br></code></pre></td></tr></table></figure><p>下一个可以添加的改进是隐藏已经完成的 todo。我们已经有了一个能够切换 <code>hideCompleted</code> 状态的按钮。但是应该如何基于状态渲染不同的列表项呢？</p><p>介绍一个新概念：<a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。我们可以使用 <code>computed</code> 选项声明一个响应式的属性，它的值由其他属性计算而来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">filteredTodos</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-comment">// 根据 `this.hideCompleted` 返回过滤后的 todo 项目</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="hljs-addition">+ &lt;li v-for=&quot;todo in filteredTodos&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>计算属性会自动跟踪其计算中所使用的到的其他响应式状态，并将它们收集为自己的依赖。计算结果会被缓存，并只有在其依赖发生改变时才会被自动更新。</p><p>现在，试着添加 <code>filteredTodos</code> 计算属性并实现计算逻辑！如果实现正确，在隐藏已完成项目的状态下勾选一个 todo，它也应当被立即隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>let id &#x3D; 0<br><br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      newTodo: &#39;&#39;,<br>      hideCompleted: false,<br>      todos: [<br>        &#123; id: id++, text: &#39;Learn HTML&#39;, done: true &#125;,<br>        &#123; id: id++, text: &#39;Learn JavaScript&#39;, done: true &#125;,<br>        &#123; id: id++, text: &#39;Learn Vue&#39;, done: false &#125;<br>      ]<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    filteredTodos() &#123;<br>      &#x2F;&#x2F;... ...<br>      return this.hideCompleted<br>        ? this.todos.filter((t) &#x3D;&gt; !t.done)<br>        : this.todos<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    addTodo() &#123;<br>      this.todos.push(&#123; id: id++, text: this.newTodo, done: false &#125;)<br>      this.newTodo &#x3D; &#39;&#39;<br>    &#125;,<br>    removeTodo(todo) &#123;<br>      this.todos &#x3D; this.todos.filter((t) &#x3D;&gt; t !&#x3D;&#x3D; todo)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;form @submit.prevent&#x3D;&quot;addTodo&quot;&gt;<br>    &lt;input v-model&#x3D;&quot;newTodo&quot;&gt;<br>    &lt;button&gt;Add Todo&lt;&#x2F;button&gt;<br>  &lt;&#x2F;form&gt;<br>  &lt;ul&gt;<br>    &lt;!-- &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.id&quot;&gt; --&gt;<br>    &lt;li v-for&#x3D;&quot;todo in filteredTodos&quot; :key&#x3D;&quot;todo.id&quot;&gt;<br>      &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;todo.done&quot;&gt;<br>      &lt;span :class&#x3D;&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;button @click&#x3D;&quot;removeTodo(todo)&quot;&gt;X&lt;&#x2F;button&gt;<br>    &lt;&#x2F;li&gt;<br>  &lt;&#x2F;ul&gt;<br>  &lt;button @click&#x3D;&quot;hideCompleted &#x3D; !hideCompleted&quot;&gt;<br>    &#123;&#123; hideCompleted ? &#39;Show all&#39; : &#39;Hide completed&#39; &#125;&#125;<br>  &lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;style&gt;<br>.done &#123;<br>  text-decoration: line-through;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><ul><li><code>return this.hideCompleted ? this.todos.filter((t) =&gt; !t.done) : this.todos</code>：由后面<code>html</code>部分中<code>&lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</code>可知该按钮根据按下次数在两种形态切换，根据<code>hideCompleted</code>的值判断是否进行隐藏，若不需要隐藏，<code>filteredTodos</code>的值就等于<code>todos</code>的值，若要隐藏，使用<code>vue</code>的数组过滤操作，滤除<code>todos</code>中<code>done</code>属性为<code>true</code>的值，<code>this.todos.filter((t) =&gt; !t.done)</code>仅允许<code>!t.done</code>为<code>ture</code>，即<code>t.done</code>为<code>false</code>的值通过过滤器，保留下来，成为<code>filteredTodos</code>的成员。其中<code>t.done</code>属性是根据下面<code>html</code>部分中<code>&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</code>选择框是否勾选来决定的，勾选即表示完成，因为通过<code>v-model</code>进行了绑定，会将与其绑定的值置为<code>true</code>，这里与<code>todo.done</code>绑定，所以勾选时会将<code>todo.done</code>置为<code>true</code>，取消勾选时会将<code>todo.done</code>置为<code>false</code></li><li><code>&lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</code>：将要显示的数组由静态的<code>todos</code>换成可变化的<code>filteredTodos</code>，以实现要求的功能</li></ul><h2 id="生命周期和模板引用-mounted"><a href="#生命周期和模板引用-mounted" class="headerlink" title="生命周期和模板引用 (mounted)"></a>生命周期和模板引用 (mounted)</h2><p>目前为止，Vue 为我们处理了所有的 DOM 更新，这要归功于响应性和声明式渲染。然而，有时我们也会不可避免地需要手动操作 DOM。</p><p>这时我们需要使用<strong>模板引用</strong>——也就是指向模板中一个 DOM 元素的 ref。我们需要通过<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#ref">这个特殊的 <code>ref</code> attribute</a> 来实现模板引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;p ref&#x3D;&quot;pElementRef&quot;&gt;hello&lt;&#x2F;p&gt;<br></code></pre></td></tr></table></figure><p>此元素将作为 <code>this.$refs.pElementRef</code> 暴露在 <code>this.$refs</code> 上。然而，你只能在组件<strong>挂载</strong>之后访问它。</p><p>要在挂载之后执行代码，我们可以使用 <code>mounted</code> 选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 此时组件已经挂载。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这被称为<strong>生命周期钩子</strong>——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 <code>created</code> 和 <code>updated</code>。更多细节请查阅<a href="https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram">生命周期图示</a>。</p><p>现在，尝试添加一个 <code>mounted</code> 钩子，然后通过 <code>this.$refs.pElementRef</code> 访问 <code>&lt;p&gt;</code>，并直接对其执行一些 DOM 操作。(例如修改它的 <code>textContent</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  &#x2F;&#x2F; ...<br>  mounted()&#123;<br>    const element &#x3D; this.$refs.pElementRef;<br>    element.textContent &#x3D; &#39;aaa&#39;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;template&gt;<br>  &lt;p ref&#x3D;&quot;pElementRef&quot;&gt;hello&lt;&#x2F;p&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><p>这个例子中，给<code>&lt;p&gt;</code>添加了一个<code>ref</code>属性(?)，<code>ref=&quot;pElementRef&quot;</code>，这样我们就可以通过<code>this.$refs.pElementRef</code>来将它锁定，并可以对他进行一些操作。</p><p>不过就跟上面说的，需要在组件<strong>挂载</strong>之后才能访问，而要在挂载之后执行代码，就要使用<code>mounted</code>选项，在这里面写具体的代码。</p><p>说一下上面例子的结果，本来<code>&lt;p&gt;</code>跟着hello，网页上显示的也就是hello，而通过<code>this.$refs.pElementRef</code>锁定了<code>&lt;p&gt;</code>，并对它的<code>textContent</code>进行了修改，令其<code>textContent = &#39;aaa&#39;</code>，所以最后网页上<code>&lt;p&gt;</code>的内容也就变成了<code>aaa</code></p><p>上面的写法可以直接改成<code>this.$refs.pElementRef.textContent = &#39;aaa&#39;</code>，效果是一样的。</p><p>另外<code>const element = this.$refs.pElementRef;</code>要注意前面的**<code>const</code>**，将<code>element</code>声明为了静态变量，这是必须的，如果不加这个关键字将其声明为静态变量，则声明的这个<code>element</code>相当于是<code>&lt;p&gt;</code>的一个副本，不会真正与下面<code>&lt;p&gt;</code>绑定，后续的<code>element.textContent = &#39;aaa&#39;</code>也不会改变<code>hello</code>为<code>aaa</code>。</p><p>而添加<code>const</code>关键字，声明成静态变量，则这个<code>element</code>才是真正跟下面的<code>&lt;p&gt;</code>进行了绑定，<code>element.textContent = &#39;aaa&#39;</code>也就能够改变<code>hello</code>为<code>aaa</code></p><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h3 id="关于export-default"><a href="#关于export-default" class="headerlink" title="关于export default"></a>关于export default</h3><p><code>export default</code> 是 ES6（ECMAScript 2015）模块系统中用于导出默认值的语法。</p><p>在 JavaScript 中，模块系统可以帮助我们将代码分割为不同的模块，以便更好地组织、复用和维护代码。ES6 引入了一种新的模块语法，其中 <code>export</code> 关键字用于将值、函数或类等从模块中导出，而 <code>import</code> 关键字用于在其他模块中导入这些导出的内容。</p><p><code>export default</code> 的作用是导出模块的默认值。一个模块只能有一个默认导出，而且默认导出可以是任何合法的 JavaScript 值，例如对象、函数、类等。通过使用 <code>export default</code>，我们可以在导入该模块时，直接获取默认导出的值，而无需使用具体的名称。</p><p>以下是一个示例，展示了如何使用 <code>export default</code> 导出和导入默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">const</span> myDefault = &#123;<br>  name: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  age: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myDefault;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> myDefault <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(myDefault); <span class="hljs-comment">// 输出: &#123; name: &#x27;John&#x27;, age: 30 &#125;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>module.js</code> 文件中使用 <code>export default</code> 导出了一个对象 <code>myDefault</code>，它作为模块的默认导出。然后，在 <code>main.js</code> 文件中使用 <code>import myDefault from &#39;./module.js&#39;</code> 导入了该默认导出，并将其赋值给了 <code>myDefault</code> 变量。此后，我们可以直接使用 <code>myDefault</code> 变量来访问和操作模块的默认导出值。</p><p>需要注意的是，使用 <code>export default</code> 导出的默认值在导入时可以使用任意的名称，因为它是默认导出。但是，可以通过 <code>import &#123; ... &#125; from &#39;./module.js&#39;</code> 的语法导入模块中其他被具名导出的成员。</p><h4 id="export-default中的属性"><a href="#export-default中的属性" class="headerlink" title="export default中的属性"></a>export default中的属性</h4><p>以下是一些常见的 Vue 组件属性：</p><ul><li><code>props</code>: 用于接收父组件传递的数据，可以通过属性传递给子组件。</li><li><code>computed</code>: 用于定义基于组件的响应式数据计算得出的属性。可以根据其他数据的变化自动更新。</li><li><code>watch</code>: 用于监听一个或多个数据的变化，并在数据发生变化时执行相应的操作。</li><li><code>components</code>: 用于注册子组件，使其在当前组件中可用。</li><li><code>template</code>: 定义组件的模板，包含 HTML 结构和 Vue 模板语法。</li><li><code>created</code>: 组件生命周期钩子，表示组件实例被创建后立即调用的钩子函数。</li><li><code>mounted</code>: 组件生命周期钩子，表示组件挂载到 DOM 后调用的钩子函数。</li><li><code>beforeDestroy</code>: 组件生命周期钩子，表示组件销毁之前调用的钩子函数。</li><li><code>computed</code>: 用于定义计算属性，可以根据响应式数据的变化动态计算出新的值。</li><li><code>methods</code>: 定义组件的方法，用于处理事件、执行业务逻辑等。</li><li><code>v-model</code>: 用于实现双向数据绑定，将组件的数据绑定到表单元素或自定义组件上。</li></ul><h1 id="Vue脚手架"><a href="#Vue脚手架" class="headerlink" title="Vue脚手架"></a>Vue脚手架</h1><p>写这个blog另一个很大的原因是，就是想找个地方感慨一下这个事儿。</p><p>当时本科实习期间老师还是教着我们用Vue Cli这个脚手架，到现在我再回头想学Vue想着看看Cli脚手架的时候发现它已经进入维护状态，官方不再推荐了。现在官方推荐了新的Vue脚手架Vite，该脚手架也是Vue的作者写的。</p><p>就是想感慨一下这技术发展是真快啊感觉，不过前面也说了，实习那会儿Vue我就基本没学，更不用说这个Vue Cli脚手架了，直接转去学新的脚手架Vite毫无负担，血赚，哎嘿。但没仔细学当时的Vue教程，血亏，嘤。</p><p>话说这样我之前搭的Vue Cli脚手架就白搭了，等着看看Vite脚手架的搭建有没有什么主意的地方，有的好也可以写个Blog，写写使用心得之类的，到时候就把这部分内容移过去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Vue，易学易用，性能出色，适用场景丰富的 Web 前端框架。 &lt;/p&gt;
&lt;p&gt;以上为官网给出的精炼概括，之前本科实习期间的项目是用Vue+</summary>
      
    
    
    
    <category term="前端技术学习" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Qt项目的文件结构</title>
    <link href="http://example.com/2023/03/16/Qt-Project-Structure/"/>
    <id>http://example.com/2023/03/16/Qt-Project-Structure/</id>
    <published>2023-03-16T02:50:11.000Z</published>
    <updated>2023-03-20T12:51:19.123Z</updated>
    
    <content type="html"><![CDATA[<p>之前新建Qt项目看它那个代码，总是感觉怪怪的，直到今天在问ChatGPT关于Qt6和OCC7.6的配合时，它给出了一个Qt+OCC的显示模型的例程，看了这个之后我感觉对Qt程序的创建执行才算理解了一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QVBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QGraphicsScene&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QGraphicsView&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;OpenGl_GraphicDriver.hxx&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;V3d_View.hxx&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;AIS_InteractiveContext.hxx&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;BRepPrimAPI_MakeSphere.hxx&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化 Qt 应用程序</span><br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    <span class="hljs-comment">// 创建主窗口</span><br>    QWidget window;<br>    window.setWindowTitle(<span class="hljs-string">&quot;OCC and Qt Integration&quot;</span>);<br>    window.resize(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);<br><br>    <span class="hljs-comment">// 创建图形场景和视图</span><br>    QGraphicsScene scene;<br>    <span class="hljs-function">QGraphicsView <span class="hljs-title">view</span><span class="hljs-params">(&amp;scene)</span></span>;<br>    view.setViewport(<span class="hljs-keyword">new</span> QOpenGLWidget());  <span class="hljs-comment">// 使用 OpenGL 视口</span><br><br>    <span class="hljs-comment">// 创建 OCC 视图</span><br>    Handle(OpenGl_GraphicDriver) aDriver = <span class="hljs-keyword">new</span> OpenGl_GraphicDriver();<br>    Handle(V3d_View) aView = <span class="hljs-keyword">new</span> V3d_View(aDriver);<br>    Handle(AIS_InteractiveContext) aContext = <span class="hljs-keyword">new</span> AIS_InteractiveContext(aView);<br>    aView-&gt;SetContext(aContext);<br><br>    <span class="hljs-comment">// 创建 OCC 对象并将其添加到场景中</span><br>    <span class="hljs-function">BRepPrimAPI_MakeSphere <span class="hljs-title">aSphere</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>    TopoDS_Shape aShape = aSphere.Shape();<br>    Handle(AIS_Shape) anAisShape = <span class="hljs-keyword">new</span> AIS_Shape(aShape);<br>    aContext-&gt;Display(anAisShape, Standard_True);<br>    aContext-&gt;UpdateCurrentViewer();<br><br>    <span class="hljs-comment">// 将 OCC 视图绑定到 Qt 视图中</span><br>    aView-&gt;SetWindow(view.winId());<br>    aView-&gt;MustBeResized();<br>    view.show();<br><br>    <span class="hljs-comment">// 将 Qt 视图添加到主窗口中</span><br>    QVBoxLayout layout;<br>    layout.addWidget(&amp;view);<br>    window.setLayout(&amp;layout);<br>    window.show();<br><br>    <span class="hljs-comment">// 运行 Qt 应用程序</span><br>    <span class="hljs-keyword">return</span> app.exec();<br>&#125;<br></code></pre></td></tr></table></figure><p>重点不在如何显示OCC模型，而在于该程序是标准的从int main（）主函数来构建程序的写法。从中我们可以加深对Qt代码的真实执行过程的理解。</p><p>将上面的代码与下面新建的Qt项目所给出的int main（）比较，可以看到只有寥寥几行代码，当初被下面这几行代码整蒙了，寻思这是干嘛呢，但其实对照上面的代码来分析就比较好读懂了。上面把定义窗口组件的代码直接写在主函数main中，而下面这种其实就是把窗口定义之类的代码写到了类里，这里这个类是OCC_QT，然后<code>OCC_QT w;</code>这句其实是调用了该类的默认构造函数，通过构造函数的执行，来实现了窗口的创建等功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OCC_QT.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QApplication&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    OCC_QT w;<br>    w.show();<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面来看OCC_QT这个类，先看头文件OCC_QT.h，这里就是类的声明，其中构造函数<code>OCC_QT(QWidget *parent = nullptr);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_OCC_QT.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OCC_QT</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    OCC_QT(QWidget *parent = <span class="hljs-literal">nullptr</span>);<br>    ~OCC_QT();<br><br><span class="hljs-keyword">private</span>:<br>    Ui::OCC_QTClass ui;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>我们可以看到它引入了一个头文件“ui_OCC_QT.h”，这里面就是窗口组件相关的代码</p><p>具体来看“ui_OCC_QT.h”，这里面定义了各种窗口组件的代码，包括页面组件的声明、布局的位置等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/********************************************************************************</span><br><span class="hljs-comment">** Form generated from reading UI file &#x27;OCC_QT.ui&#x27;</span><br><span class="hljs-comment">**</span><br><span class="hljs-comment">** Created by: Qt User Interface Compiler version 6.4.0</span><br><span class="hljs-comment">**</span><br><span class="hljs-comment">** WARNING! All changes made in this file will be lost when recompiling UI file!</span><br><span class="hljs-comment">********************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UI_OCC_QT_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UI_OCC_QT_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtCore/QVariant&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QMenuBar&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QStatusBar&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QToolBar&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QWidget&gt;</span></span><br><br>QT_BEGIN_NAMESPACE<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ui_OCC_QTClass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    QMenuBar *menuBar;<br>    QToolBar *mainToolBar;<br>    QWidget *centralWidget;<br>    QStatusBar *statusBar;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupUi</span><span class="hljs-params">(QMainWindow *OCC_QTClass)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (OCC_QTClass-&gt;objectName().isEmpty())<br>            OCC_QTClass-&gt;setObjectName(<span class="hljs-string">&quot;OCC_QTClass&quot;</span>);<br>        OCC_QTClass-&gt;resize(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);<br>        menuBar = <span class="hljs-keyword">new</span> QMenuBar(OCC_QTClass);<br>        menuBar-&gt;setObjectName(<span class="hljs-string">&quot;menuBar&quot;</span>);<br>        OCC_QTClass-&gt;setMenuBar(menuBar);<br>        mainToolBar = <span class="hljs-keyword">new</span> QToolBar(OCC_QTClass);<br>        mainToolBar-&gt;setObjectName(<span class="hljs-string">&quot;mainToolBar&quot;</span>);<br>        OCC_QTClass-&gt;addToolBar(mainToolBar);<br>        centralWidget = <span class="hljs-keyword">new</span> QWidget(OCC_QTClass);<br>        centralWidget-&gt;setObjectName(<span class="hljs-string">&quot;centralWidget&quot;</span>);<br>        OCC_QTClass-&gt;setCentralWidget(centralWidget);<br>        statusBar = <span class="hljs-keyword">new</span> QStatusBar(OCC_QTClass);<br>        statusBar-&gt;setObjectName(<span class="hljs-string">&quot;statusBar&quot;</span>);<br>        OCC_QTClass-&gt;setStatusBar(statusBar);<br><br>        retranslateUi(OCC_QTClass);<br><br>        QMetaObject::connectSlotsByName(OCC_QTClass);<br>    &#125; <span class="hljs-comment">// setupUi</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">retranslateUi</span><span class="hljs-params">(QMainWindow *OCC_QTClass)</span></span><br><span class="hljs-function">    </span>&#123;<br>        OCC_QTClass-&gt;setWindowTitle(QCoreApplication::translate(<span class="hljs-string">&quot;OCC_QTClass&quot;</span>, <span class="hljs-string">&quot;OCC_QT&quot;</span>, <span class="hljs-literal">nullptr</span>));<br>    &#125; <span class="hljs-comment">// retranslateUi</span><br><br>&#125;;<br><br><span class="hljs-keyword">namespace</span> Ui &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OCC_QTClass</span>:</span> <span class="hljs-keyword">public</span> Ui_OCC_QTClass &#123;&#125;;<br>&#125; <span class="hljs-comment">// namespace Ui</span><br><br>QT_END_NAMESPACE<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// UI_OCC_QT_H</span></span><br></code></pre></td></tr></table></figure><p>补充一点关于上面部分代码的理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> Ui &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OCC_QTClass</span>:</span> <span class="hljs-keyword">public</span> Ui_OCC_QTClass &#123;&#125;;<br>&#125; <span class="hljs-comment">// namespace Ui</span><br></code></pre></td></tr></table></figure><p>这段代码声明了一个命名空间Ui，并在里面定义了一个新的类OCC_QTClass来继承上面具体实现功能的类Ui_OCC_QTClass，然后OCC_QT.h中，声明窗口类的时候：<code>Ui::OCC_QTClass ui;</code>，用的也是这个新建的OCC_QTClass类，至于为什么要这么干，我猜可能是进一步提高代码的封装性，提高项目的安全性。</p><p>最后再来看OCC_QT.cpp，这里面就是OCC_QT类的各种函数功能的具体实现。这里别看这个构造函数就一句话，当时我也懵了一下，寻思这怎么就能把窗口之类的东西都弄出来了？现在懂了，就像上面说的，窗口之类的代码实现实际上都在上面ui_OCC_QT.h里，所以cpp这里的构造函数只需要调用一下setupUi（）函数，把窗口布局的代码运行一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OCC_QT.h&quot;</span></span><br><br>OCC_QT::OCC_QT(QWidget *parent)<br>    : QMainWindow(parent)<br>&#123;<br>    ui.setupUi(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>OCC_QT::~OCC_QT()<br>&#123;&#125;<br><br></code></pre></td></tr></table></figure><p>分析完这个OCC_QT类，再来看主函数的代码就很好理解了，调用OCC_QT的构造函数将窗口组件都定义好了，之后再使用w.show()函数显示在w这个类中声明与定义的窗口即可。其中这个show()函数我们注意到并没有定义在OCC_QT类中，它应该是继承自QMainWindow的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;OCC_QT.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtWidgets/QApplication&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    OCC_QT w;<br>    w.show();<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后大致总结一下新建的这个Qt项目，它在执行时所做的一些工作：</p><p>定义了UI界面类Ui_OCC_QTClass，写在“ui_OCC_QT.h”中，其中有窗口各种组件的声明和布局定义，与槽函数的连接也默认写在这里面，又定义了一个新的类OCC_QTCLass继承Ui_OCC_QTClass作为访问接口。定义了窗口类OCC_QT，声明部分写在“OCC_QT.h”里，声明了OCC_QTClass类的对象ui，之后的槽函数声明也写在该文件里；定义部分写在“OCC_QT.cpp”里，构造函数调用ui.setup（）函数对窗口组件进行实现，之后的槽函数定义也写在该文件里。</p><p>有了上述这些类的定义，之后就是在主函数中使用，主函数main声明了OCC_QT类的对象w，并调用其构造函数，该构造函数调用OCC_QTClass的实例ui的setup函数，对窗口组件进行声明和定义，即对窗口各组件进行实现。之后再调用OCC_QT的父类QMainWindow继承来的show（）函数将窗口显示出来。</p><p>了解了Qt项目的这些结构之后，我们对Qt项目代码的执行过程就有了基本的了解，就可以更好地编写自己的Qt项目。</p><p>可以就依赖它给出的这种结构来写，也可以按自己想法来写不按它上面的这种结构，步骤对了就行。</p><p>后记：槽函数的声明、定义、与信号的连接等基本步骤见后续的Qt学习笔记，想记录一下两种方式，一种是配合Qt Designer的可视化编程，一种就是纯代码开发的方式。在第一种方式里，想着用上上面说的Qt项目自带的这种文件结果，把OCC_QT.h，OCC_QT.cpp，ui_OCC_QT.h三个文件都用上。在第二中纯代码的方式里，就不要这个ui_OCC_QT.h文件了，毕竟这个文件其实是为了配合Qt Designer可视化编程而存在的，把里面的组件声明、定义等代码都放到外面来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前新建Qt项目看它那个代码，总是感觉怪怪的，直到今天在问ChatGPT关于Qt6和OCC7.6的配合时，它给出了一个Qt+OCC的显示模型的例程，看了这个之后我感觉对Qt程序的创建执行才算理解了一点。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Qt学习" scheme="http://example.com/categories/Qt%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>更改PyCharm缓存路径</title>
    <link href="http://example.com/2023/03/15/PyCharm-Cache/"/>
    <id>http://example.com/2023/03/15/PyCharm-Cache/</id>
    <published>2023-03-15T09:19:46.000Z</published>
    <updated>2023-03-20T12:51:19.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="越来越小的C盘"><a href="#越来越小的C盘" class="headerlink" title="越来越小的C盘"></a>越来越小的C盘</h2><p>最近C盘的空间越来越小了，于是便又开始找找有没有什么能删的垃圾文件。</p><p>推荐一个软件“SpaceSniffer”，它可以扫描分析每个盘里面各个文件所占的大小，我用他扫描了一下我的C盘结果看到用户目录下的PyCharm文件夹里有个文件“content.dat.storage.data”有4.4个G的大小。</p><img src="/2023/03/15/PyCharm-Cache/image-20230315192453628.png" class="" title="image-20230315192453628"><p>网上一查是PyCharm的缓存文件，补充一下，该文件存放在Caches文件夹里，Cache一般就是指缓存文件夹，用来存缓存文件的，当时没反应过来，不过就算直到Cache放缓存文件可能也还是查一查确认一下放心。</p><p>这个缓存文件可以直接删除。但删除并不能从根源解决问题，因为下次使用PyCharm还是会生成缓存文件，早晚还是会一点一点挤占C盘的位置，所以最好的办法就是给PyCharm换一个缓存路径。</p><h2 id="更换PyCharm缓存路径"><a href="#更换PyCharm缓存路径" class="headerlink" title="更换PyCharm缓存路径"></a>更换PyCharm缓存路径</h2><p>找到PyCharm的安装目录下的bin文件夹，如<code>E:\PyCharm Community Edition 2022.3.2\bin</code>，找到其中的idea.properties文件</p><img src="/2023/03/15/PyCharm-Cache/image-20230315193543798.png" class="" title="image-20230315193543798"><p>打开该文件，修改其中的四处位置，推荐用“NotePad++”打开。当然，记事本，VS Code之类的都可以。</p><img src="/2023/03/15/PyCharm-Cache/image-20230315194055634.png" class="" title="image-20230315194055634"><p>上面红框就是我们要修改的部分，它注释掉的语句应该是它本来默认的存放路径，不过可能因为注释掉了，所以其实并没有存在这个路径中，但还是在C盘建了别的文件夹来放这些文件。我们将这些路径改为我们想让它存放的路径。我在PyCharm的安装目录下新建了一个”.PyCharmCE2022.3”文件夹，并将这个路径改到了该文件夹下。</p><ul><li>修改config路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># idea.config.path=$&#123;user.home&#125;/.PyCharmCE/config</span><br>idea.config.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/config<br></code></pre></td></tr></table></figure><ul><li>修改system路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># idea.system.path=$&#123;user.home&#125;/.PyCharmCE/system</span><br>idea.system.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/system<br></code></pre></td></tr></table></figure><ul><li>修改plugins路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># idea.plugins.path=$&#123;idea.config.path&#125;/plugins</span><br>idea.plugins.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/plugins<br></code></pre></td></tr></table></figure><ul><li>修改log路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># idea.log.path=$&#123;idea.system.path&#125;/log</span><br>idea.log.path=E:/PyCharm Community Edition 2022.3.2/.PyCharmCE2022.3/<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>之后重启PyCharm，它会自动检测之前的配置所在位置，并提示导入之前的配置</p><img src="/2023/03/15/PyCharm-Cache/image-20230315212412556.png" class="" title="image-20230315212412556"><p>点击ok就行了，然后就可以把之前C盘里的都删掉了。</p><p>不过因为前面提到的，它配置文件里那四个部分都默认是注释掉的，所以它实际存放的位置是在C盘别的位置，我的位置是在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:\Users\REINHARDT\AppData\Local\JetBrains\PyCharmCE2022.3<br>C:\Users\REINHARDT\AppData\Roaming\JetBrains\PyCharmCE2022.3<br></code></pre></td></tr></table></figure><p>不过删完那个4.4G的缓存文件之后我看这两占内存也不是很大我就没删，以防之后发现上面的配置方法有问题，我好回来找。不过一般也没问题，咬咬牙删了也没事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;越来越小的C盘&quot;&gt;&lt;a href=&quot;#越来越小的C盘&quot; class=&quot;headerlink&quot; title=&quot;越来越小的C盘&quot;&gt;&lt;/a&gt;越来越小的C盘&lt;/h2&gt;&lt;p&gt;最近C盘的空间越来越小了，于是便又开始找找有没有什么能删的垃圾文件。&lt;/p&gt;
&lt;p&gt;推荐一个软件“S</summary>
      
    
    
    
    <category term="C盘减负" scheme="http://example.com/categories/C%E7%9B%98%E5%87%8F%E8%B4%9F/"/>
    
    
    <category term="PyCharm" scheme="http://example.com/tags/PyCharm/"/>
    
  </entry>
  
  <entry>
    <title>PCL1.12.1+VS2022+Qt6.4 配置</title>
    <link href="http://example.com/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/"/>
    <id>http://example.com/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/</id>
    <published>2023-03-13T13:07:58.000Z</published>
    <updated>2024-04-18T02:35:14.630Z</updated>
    
    <content type="html"><![CDATA[<p>本教程分为两部分，第一部分为PCL+VS的配置，第二部分为PCL+VS+QT的配置。</p><p>如果只是要在VS用用PCL，学习一下PCL点云库，只看第一部分PCL+VS的配置即可。</p><p>而如果还需要配合QT做界面，相关的配置会在第二部分PCL+VS+QT的配置中介绍。</p><h1 id="PCL-VS-配置"><a href="#PCL-VS-配置" class="headerlink" title="PCL+VS 配置"></a>PCL+VS 配置</h1><h2 id="PCL安装"><a href="#PCL安装" class="headerlink" title="PCL安装"></a>PCL安装</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>PCL（Point Cloud Library）官方网站 <a href="https://pointclouds.org/">https://pointclouds.org/</a></p><p>官方github网站 <a href="https://github.com/PointCloudLibrary/pcl">https://github.com/PointCloudLibrary/pcl</a></p><p>PCL官方的github提供了各种版本的PCL源码，同时还提供了已经编译好的PCL供使用。</p><p>解释一下，PCL正常来配置的话，是需要自己安装PCL依赖的第三方库，一般有Boost、Eigen、FLANN、OpenNI2、Qhull、VTK，我们需要将这些第三方库从各自官网下载下来，分别用Cmake编译好，然后再编译PCL的源码，因为PCL编译时要依赖上述第三库编译出的文件，包括库文件（library）等二进制文件。这样的优势在于编译PCL的时候可以自选PCL的一些组件，比如可以指定PCL的GPU加速模块（默认是不带的），还可以指定要与Qt6配合使用，它应该就会在编译时往与Qt6适配这方面有进一步的优化。但缺点就是麻烦，要把上面每一个第三方库都安装编译一遍可不是一般的麻烦，而且各个第三方库版本之间的兼容性、适配度也需要自己摸索。</p><p>所以官方也提供了已经完全编译好的PCL安装包供我们使用，该安装包包含上述的所有第三方库编译好的文件，以及依赖它们所编译好的PCL文件。当然，官方提供的这种安装包得到的PCL只提供了最基本的功能，不含GPU模块等扩展。而且其中所带的第三库也都是最基本的配置，就比如其中自带的VTK，就没有针对Qt6做额外的配置，缺少与Qt6配合所需的文件。</p><p>因此，个人认为，最佳的PCL配置安装路线是，1、先使用官方提供的AllInOn安装包，就是之前提过的官方提供的自带编译好的第三方库及编译好的PCL的安装包。补充一下，这个安装包自带的第三方库安好后，从各自的文件夹名字基本能得知每个第三库的版本，即我们可以从中得知当前PCL版本要与第三方库的哪些版本配合兼容性好。2、根据自己的需求，自己安装编译对应版本的第三方库，并用它替换掉PCL自带的对应部分的第三方库。就比如，我要使用VTK配合Qt的组件，而PCL自带的VTK显然不带与Qt配合的部分。因此我去VTK官网自己下一个VTK源码，并自己编译，编译时配置与Qt配合，那我得到的编译后的文件就带有我所需的与Qt配合的部分。之后我用我自己编译好的VTK文件（包括bin、lib、include等），把PCL自带的VTK的这些文件都替换掉。当然，如果没有这类需求，只是想自己编译一下PCL，比如自己编译PCL增加一个GPU模块，那这第2步就没有必要。3、前面是编译PCL的准备步骤，准备好PCL编译所依赖的第三方库文件（编译好的），下面就是编译PCL，去官网下载对应版本的PCL源码，使用CMake编译即可，编译的时候绑定好这些第三方库的位置、选好要用的PCL模块。具体操作见本教程第二部分“PCL+VS+QT 配置” 。</p><h3 id="官方编译版安装"><a href="#官方编译版安装" class="headerlink" title="官方编译版安装"></a>官方编译版安装</h3><p>下面开始官方编译版PCL的安装教程，因为如果只是配合VS来学习PCL库，安这个也就够用了，有进一步的自定义需求的可以接着看第二部分。</p><p>在官方github网站（PCL项目）的右侧找到Releases部分</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230314105408267.png" class="" title="image-20230314105408267"><p>他这里把最新的版本放在前面，可以看到是PCL1.13.0版本，如果想安装其他版本就点“+30 releases”去找自己想安的版本，因为我之前安装的是PCL1.12.1，所以我还是以该版本为例来写。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230314113236986.png" class="" title="image-20230314113236986"><p>点开相应版本下的“Assets”，就能看到具体提供的安装资源，其中的AllInOne安装包就是官方提供的编译好的第三方库及PCL文件。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230314113530623.png" class="" title="image-20230314113530623"><p>之后点击安装即可，这里提点安装时的个人小建议，一是选择添加环境变量到PATH，能为后面配环境变量省一点事儿</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230314154142517.png" class="" title="image-20230314154142517"><p>然后是选择安装路径的时候，官方自动给的路径中“PCL 1.12.1”里面有个空格，为了方便后续编译PCL时的方便，建议把这个空格去掉，或是换成下划线之类的，总之路径里最后不要有空格，中文最好也别有（这个没试过，可能没事）</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230314155403828.png" class="" title="image-20230314155403828"><p>重要！！！后来我发现相比下划线”PCL_1.12.1”，用横杠更好看”PCL-1.12.1”，仅供参考。<span style="background:#000000;color:black">等之后找个空把我要把这些路径名都改过来。</span></p><p>ps:好久之后再来看这个笔记，为什么不要带空格来着？好像是用Cmake编译的时候，带空格的路径它好像是自动识别不到，需要自己手动配置一下，会麻烦一些，所以不怕麻烦可能带空格也没事？</p><p>然后在安装过程中如果之前没有安装过OpenNI2，会弹出窗口问是否安装OpenNI2，点击安装即可。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323170801047.png" class="" title="image-20230323170801047"><p> 比较坑的是，这个OpenNI2一般不会老老实实按照我们PCL安装路径安装，而是安装在C盘。不过也不用在意，等PCL安装程序全部安装完成后，找到安装目录\PCL_1.12.1\3rdParty，该目录下就是PCL官方为我们打包好的，编译好的第三方库</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323170910862.png" class="" title="image-20230323170910862"><p>打开其中的OpenNI2目录，如果里面是空的，只有一个OpenNI-Windows-x64-2.2.msi文件，那恭喜，这东西成功安到C盘去了。。。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323171100553.png" class="" title="image-20230323171100553"><p>但不用担心，这个msi文件就是OpenNI2的安装文件，我们可以通过它，把安在C盘的OpenNI2卸载</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323171136795.png" class="" title="image-20230323171136795"><p>然后再通过这个msi把它安装回来，主要是因为通过这个msi文件来安装的时候，它会让你选安装路径，我们就把安到\PCL_1.12.1\3rdParty\OpenNI2路径，这样就让PCL的第三库整整齐齐在一起了。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323171343610.png" class="" title="image-20230323171343610"><p>现在再看OpenNI2的文件夹，这就正常了。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323171445487.png" class="" title="image-20230323171445487"><p>当然，不介意OpenNI2安在C盘，与其他第三方库天各一方的话，就不用把它卸了又装。</p><p>现在打开系统环境变量来看一下，因为我们之前选择了添加PCL环境变量到PATH，所以这里已经自动帮我们配好了一部分。</p><p>在系统变量里帮我们配好了OPENNI2的三个相关变量（外：PCL_ROOT,OpenNI2三项；Path内：PCL/bin，VTK/bin）</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323171638424.png" class="" title="image-20230323171638424"><p>在Path里帮我们配好了最基本的PCL和VTK的bin路径</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323194457597.png" class="" title="image-20230323194457597"><p>除了他帮我们配好的这一部分，我们还需要把其他第三方库跟dll有关的路径添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">%PCL_ROOT%\3rdParty\FLANN\bin<br>%PCL_ROOT%\3rdParty\Qhull\bin<br>%PCL_ROOT%\3rdParty\OpenNI2\Tools<br>%PCL_ROOT%\3rdParty\OpenNI2\Redist<br></code></pre></td></tr></table></figure><p>另外因为他给我们配好PCL_ROOT了，可以直接拿来用</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323235808375.png" class="" title="image-20230323235808375"><p>一开始我以为我没用到上面的模块，这些环境变量没必要加，结果不加它们在运行的时候报了缺少OpenNI2.dll的错误，所以我估计虽然没有直接使用这些第三方库，但PCL毕竟是依赖它们编译出来的，在运行时估计还是需要用到这些东西，所以还是把上面这些都加到环境变量里吧。</p><p>对了，既然说到这了，提供一种程序运行时出现缺少xxx.dll文件时的解决思路</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230315105857343.png" class="" title="image-20230315105857343"><p>这种一般就是程序调试的时候找不到相关的dll导致的<span style="background:#000000;color:black">（废话。。。）</span>，所以我们首先要找到这个dll的位置，还是通过之前的软件“everything”，查找到这个dll所在位置</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230315110129274.png" class="" title="image-20230315110129274"><p>之后有两种办法 ，一是直接将这个dll文件复制到程序运行目录下，二是将这个dll文件所在的路径添加到环境变量Path中，然后在VS的调试属性中告诉它去哪里找这些dll文件。上面这么多路径，选一个加到环境变量里即可。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230315110339388.png" class="" title="image-20230315110339388"><p>在这个例子里，通过网上的参考，只要把下面两个路径加到环境变量里，应该就包含OpenNI2所需的所有dll文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">%PCL_ROOT%\3rdParty\OpenNI2\Tools<br>%PCL_ROOT%\3rdParty\OpenNI2\Redist<br></code></pre></td></tr></table></figure><p>而在不知道哪个路径里包含程序运行所需的所有dll文件的情况下，就只能是缺一个，找个一路径加一下这样。。。当然，因为你加的路径里包含多个dll文件，在有多个dll路径可选的时候，是有可能你选的那个路径，就是包含你当前程序运行所需的所有dll文件的路径。提这个就是想说，选哪个路径加到环境变量里的时候，还是可以稍微思考一下的，哎嘿。</p><p>题外话，不过让我纳闷的是，上面配置的所有PCL相关环境时，里面没有Boost相关的环境变量，甚至我程序中都显式地使用了Boost相关的代码，它也没报过缺少dll文件的错。而且其实在第三方库Boost的安装路径\PCL_1.12.1\3rdParty\Boost里，可以看到是没有bin文件夹的，找了找也没有像OpenNI2那样把dll分散到别的文件夹里，Boost好像就是没有dll文件。看样Boost在使用时跟别人都不一样，不需要这个dll文件就能用。这一段是见识短的我的一点小感慨，等我见识长了，看看能不能有什么新的认识补充。</p><h2 id="VS配置"><a href="#VS配置" class="headerlink" title="VS配置"></a>VS配置</h2><p>跟之前OCC在VS中的配置类似，主要三个部分。让程序能找到bin里的dll文件，找到inc里的.h头文件，找到lib里的lib库函数。</p><p>如何让程序能找到bin里的dll文件在上面已经给出了，就是在属性页的 “调试–&gt;环境” 里添加<code>PATH=%PATH%</code>，不过感觉不加好像也行，一般程序创建的时候都带着。</p><p>让程序能找到头文件，添加PCL所有关联的头文件目录。找到 属性页 -&gt; “C/C++” -&gt; “常规”-&gt;”附加包含目录”，把这些头文件路径添加进去即可。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323195932889.png" class="" title="image-20230323195932889"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:\PCL_1.12.1\include\pcl-1.12<br>E:\PCL_1.12.1\3rdParty\Boost\include\boost-1_78<br>E:\PCL_1.12.1\3rdParty\Eigen\eigen3<br>E:\PCL_1.12.1\3rdParty\FLANN\include<br>E:\PCL_1.12.1\3rdParty\OpenNI2\Include<br>E:\PCL_1.12.1\3rdParty\Qhull\include<br>E:\PCL_1.12.1\3rdParty\VTK\include\vtk-9.1<br></code></pre></td></tr></table></figure><p>让程序能找到lib文件，找到属性页-&gt;”链接器”-&gt;”常规”-&gt;”附加库目录”，添加lib库位置。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323201452080.png" class="" title="image-20230323201452080"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:\PCL_1.12.1\lib<br>E:\PCL_1.12.1\3rdParty\Boost\lib<br>E:\PCL_1.12.1\3rdParty\FLANN\lib<br>E:\PCL_1.12.1\3rdParty\OpenNI2\Lib<br>E:\PCL_1.12.1\3rdParty\Qhull\lib<br>E:\PCL_1.12.1\3rdParty\VTK\lib<br></code></pre></td></tr></table></figure><p>然后还是在链接器部分，找到“输入”-&gt;”附加依赖项”，把上面所有lib库路径下的lib文件名引入到附加依赖项里</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323200946499.png" class="" title="image-20230323200946499"><p>之前配OCC的时候提过了，在每个lib文件夹下，shift+右键，选择打开Powershell窗口，然后通过命令行<code>ls *.lib -n</code>来获取各个文件夹下的所有lib文件名即可。这里直接给出该PCL版本下所以的lib文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><code class="hljs plain">pcl_commond.lib<br>pcl_featuresd.lib<br>pcl_filtersd.lib<br>pcl_iod.lib<br>pcl_io_plyd.lib<br>pcl_kdtreed.lib<br>pcl_keypointsd.lib<br>pcl_mld.lib<br>pcl_octreed.lib<br>pcl_outofcored.lib<br>pcl_peopled.lib<br>pcl_recognitiond.lib<br>pcl_registrationd.lib<br>pcl_sample_consensusd.lib<br>pcl_searchd.lib<br>pcl_segmentationd.lib<br>pcl_stereod.lib<br>pcl_surfaced.lib<br>pcl_trackingd.lib<br>pcl_visualizationd.lib<br>libboost_atomic-vc142-mt-gd-x64-1_78.lib<br>libboost_bzip2-vc142-mt-gd-x64-1_78.lib<br>libboost_chrono-vc142-mt-gd-x64-1_78.lib<br>libboost_container-vc142-mt-gd-x64-1_78.lib<br>libboost_context-vc142-mt-gd-x64-1_78.lib<br>libboost_contract-vc142-mt-gd-x64-1_78.lib<br>libboost_coroutine-vc142-mt-gd-x64-1_78.lib<br>libboost_date_time-vc142-mt-gd-x64-1_78.lib<br>libboost_exception-vc142-mt-gd-x64-1_78.lib<br>libboost_filesystem-vc142-mt-gd-x64-1_78.lib<br>libboost_graph-vc142-mt-gd-x64-1_78.lib<br>libboost_graph_parallel-vc142-mt-gd-x64-1_78.lib<br>libboost_iostreams-vc142-mt-gd-x64-1_78.lib<br>libboost_json-vc142-mt-gd-x64-1_78.lib<br>libboost_locale-vc142-mt-gd-x64-1_78.lib<br>libboost_log-vc142-mt-gd-x64-1_78.lib<br>libboost_log_setup-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99f-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99l-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1f-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1l-vc142-mt-gd-x64-1_78.lib<br>libboost_mpi-vc142-mt-gd-x64-1_78.lib<br>libboost_nowide-vc142-mt-gd-x64-1_78.lib<br>libboost_numpy38-vc142-mt-gd-x64-1_78.lib<br>libboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.lib<br>libboost_program_options-vc142-mt-gd-x64-1_78.lib<br>libboost_python38-vc142-mt-gd-x64-1_78.lib<br>libboost_random-vc142-mt-gd-x64-1_78.lib<br>libboost_regex-vc142-mt-gd-x64-1_78.lib<br>libboost_serialization-vc142-mt-gd-x64-1_78.lib<br>libboost_system-vc142-mt-gd-x64-1_78.lib<br>libboost_test_exec_monitor-vc142-mt-gd-x64-1_78.lib<br>libboost_thread-vc142-mt-gd-x64-1_78.lib<br>libboost_timer-vc142-mt-gd-x64-1_78.lib<br>libboost_type_erasure-vc142-mt-gd-x64-1_78.lib<br>libboost_unit_test_framework-vc142-mt-gd-x64-1_78.lib<br>libboost_wave-vc142-mt-gd-x64-1_78.lib<br>libboost_wserialization-vc142-mt-gd-x64-1_78.lib<br>libboost_zlib-vc142-mt-gd-x64-1_78.lib<br>flann-gd.lib<br>flann_cpp-gd.lib<br>flann_cpp_s-gd.lib<br>flann_s-gd.lib<br>OpenNI2.lib<br>qhullcpp_d.lib<br>qhullstatic_d.lib<br>qhullstatic_rd.lib<br>qhull_rd.lib<br>vtkcgns-9.1.lib<br>vtkcgns-9.1d.lib<br>vtkChartsCore-9.1.lib<br>vtkChartsCore-9.1d.lib<br>vtkCommonColor-9.1.lib<br>vtkCommonColor-9.1d.lib<br>vtkCommonComputationalGeometry-9.1.lib<br>vtkCommonComputationalGeometry-9.1d.lib<br>vtkCommonCore-9.1.lib<br>vtkCommonCore-9.1d.lib<br>vtkCommonDataModel-9.1.lib<br>vtkCommonDataModel-9.1d.lib<br>vtkCommonExecutionModel-9.1.lib<br>vtkCommonExecutionModel-9.1d.lib<br>vtkCommonMath-9.1.lib<br>vtkCommonMath-9.1d.lib<br>vtkCommonMisc-9.1.lib<br>vtkCommonMisc-9.1d.lib<br>vtkCommonSystem-9.1.lib<br>vtkCommonSystem-9.1d.lib<br>vtkCommonTransforms-9.1.lib<br>vtkCommonTransforms-9.1d.lib<br>vtkDICOMParser-9.1.lib<br>vtkDICOMParser-9.1d.lib<br>vtkDomainsChemistry-9.1.lib<br>vtkDomainsChemistry-9.1d.lib<br>vtkDomainsChemistryOpenGL2-9.1.lib<br>vtkDomainsChemistryOpenGL2-9.1d.lib<br>vtkdoubleconversion-9.1.lib<br>vtkdoubleconversion-9.1d.lib<br>vtkexodusII-9.1.lib<br>vtkexodusII-9.1d.lib<br>vtkexpat-9.1.lib<br>vtkexpat-9.1d.lib<br>vtkFiltersAMR-9.1.lib<br>vtkFiltersAMR-9.1d.lib<br>vtkFiltersCore-9.1.lib<br>vtkFiltersCore-9.1d.lib<br>vtkFiltersExtraction-9.1.lib<br>vtkFiltersExtraction-9.1d.lib<br>vtkFiltersFlowPaths-9.1.lib<br>vtkFiltersFlowPaths-9.1d.lib<br>vtkFiltersGeneral-9.1.lib<br>vtkFiltersGeneral-9.1d.lib<br>vtkFiltersGeneric-9.1.lib<br>vtkFiltersGeneric-9.1d.lib<br>vtkFiltersGeometry-9.1.lib<br>vtkFiltersGeometry-9.1d.lib<br>vtkFiltersHybrid-9.1.lib<br>vtkFiltersHybrid-9.1d.lib<br>vtkFiltersHyperTree-9.1.lib<br>vtkFiltersHyperTree-9.1d.lib<br>vtkFiltersImaging-9.1.lib<br>vtkFiltersImaging-9.1d.lib<br>vtkFiltersModeling-9.1.lib<br>vtkFiltersModeling-9.1d.lib<br>vtkFiltersParallel-9.1.lib<br>vtkFiltersParallel-9.1d.lib<br>vtkFiltersParallelImaging-9.1.lib<br>vtkFiltersParallelImaging-9.1d.lib<br>vtkFiltersPoints-9.1.lib<br>vtkFiltersPoints-9.1d.lib<br>vtkFiltersProgrammable-9.1.lib<br>vtkFiltersProgrammable-9.1d.lib<br>vtkFiltersSelection-9.1.lib<br>vtkFiltersSelection-9.1d.lib<br>vtkFiltersSMP-9.1.lib<br>vtkFiltersSMP-9.1d.lib<br>vtkFiltersSources-9.1.lib<br>vtkFiltersSources-9.1d.lib<br>vtkFiltersStatistics-9.1.lib<br>vtkFiltersStatistics-9.1d.lib<br>vtkFiltersTexture-9.1.lib<br>vtkFiltersTexture-9.1d.lib<br>vtkFiltersTopology-9.1.lib<br>vtkFiltersTopology-9.1d.lib<br>vtkFiltersVerdict-9.1.lib<br>vtkFiltersVerdict-9.1d.lib<br>vtkfmt-9.1.lib<br>vtkfmt-9.1d.lib<br>vtkfreetype-9.1.lib<br>vtkfreetype-9.1d.lib<br>vtkGeovisCore-9.1.lib<br>vtkGeovisCore-9.1d.lib<br>vtkgl2ps-9.1.lib<br>vtkgl2ps-9.1d.lib<br>vtkglew-9.1.lib<br>vtkglew-9.1d.lib<br>vtkhdf5-9.1.lib<br>vtkhdf5-9.1d.lib<br>vtkhdf5_hl-9.1.lib<br>vtkhdf5_hl-9.1d.lib<br>vtkImagingColor-9.1.lib<br>vtkImagingColor-9.1d.lib<br>vtkImagingCore-9.1.lib<br>vtkImagingCore-9.1d.lib<br>vtkImagingFourier-9.1.lib<br>vtkImagingFourier-9.1d.lib<br>vtkImagingGeneral-9.1.lib<br>vtkImagingGeneral-9.1d.lib<br>vtkImagingHybrid-9.1.lib<br>vtkImagingHybrid-9.1d.lib<br>vtkImagingMath-9.1.lib<br>vtkImagingMath-9.1d.lib<br>vtkImagingMorphological-9.1.lib<br>vtkImagingMorphological-9.1d.lib<br>vtkImagingSources-9.1.lib<br>vtkImagingSources-9.1d.lib<br>vtkImagingStatistics-9.1.lib<br>vtkImagingStatistics-9.1d.lib<br>vtkImagingStencil-9.1.lib<br>vtkImagingStencil-9.1d.lib<br>vtkInfovisCore-9.1.lib<br>vtkInfovisCore-9.1d.lib<br>vtkInfovisLayout-9.1.lib<br>vtkInfovisLayout-9.1d.lib<br>vtkInteractionImage-9.1.lib<br>vtkInteractionImage-9.1d.lib<br>vtkInteractionStyle-9.1.lib<br>vtkInteractionStyle-9.1d.lib<br>vtkInteractionWidgets-9.1.lib<br>vtkInteractionWidgets-9.1d.lib<br>vtkIOAMR-9.1.lib<br>vtkIOAMR-9.1d.lib<br>vtkIOAsynchronous-9.1.lib<br>vtkIOAsynchronous-9.1d.lib<br>vtkIOCGNSReader-9.1.lib<br>vtkIOCGNSReader-9.1d.lib<br>vtkIOChemistry-9.1.lib<br>vtkIOChemistry-9.1d.lib<br>vtkIOCityGML-9.1.lib<br>vtkIOCityGML-9.1d.lib<br>vtkIOCONVERGECFD-9.1.lib<br>vtkIOCONVERGECFD-9.1d.lib<br>vtkIOCore-9.1.lib<br>vtkIOCore-9.1d.lib<br>vtkIOEnSight-9.1.lib<br>vtkIOEnSight-9.1d.lib<br>vtkIOExodus-9.1.lib<br>vtkIOExodus-9.1d.lib<br>vtkIOExport-9.1.lib<br>vtkIOExport-9.1d.lib<br>vtkIOExportGL2PS-9.1.lib<br>vtkIOExportGL2PS-9.1d.lib<br>vtkIOExportPDF-9.1.lib<br>vtkIOExportPDF-9.1d.lib<br>vtkIOGeometry-9.1.lib<br>vtkIOGeometry-9.1d.lib<br>vtkIOHDF-9.1.lib<br>vtkIOHDF-9.1d.lib<br>vtkIOImage-9.1.lib<br>vtkIOImage-9.1d.lib<br>vtkIOImport-9.1.lib<br>vtkIOImport-9.1d.lib<br>vtkIOInfovis-9.1.lib<br>vtkIOInfovis-9.1d.lib<br>vtkIOIOSS-9.1.lib<br>vtkIOIOSS-9.1d.lib<br>vtkIOLegacy-9.1.lib<br>vtkIOLegacy-9.1d.lib<br>vtkIOLSDyna-9.1.lib<br>vtkIOLSDyna-9.1d.lib<br>vtkIOMINC-9.1.lib<br>vtkIOMINC-9.1d.lib<br>vtkIOMotionFX-9.1.lib<br>vtkIOMotionFX-9.1d.lib<br>vtkIOMovie-9.1.lib<br>vtkIOMovie-9.1d.lib<br>vtkIONetCDF-9.1.lib<br>vtkIONetCDF-9.1d.lib<br>vtkIOOggTheora-9.1.lib<br>vtkIOOggTheora-9.1d.lib<br>vtkIOParallel-9.1.lib<br>vtkIOParallel-9.1d.lib<br>vtkIOParallelXML-9.1.lib<br>vtkIOParallelXML-9.1d.lib<br>vtkIOPLY-9.1.lib<br>vtkIOPLY-9.1d.lib<br>vtkIOSegY-9.1.lib<br>vtkIOSegY-9.1d.lib<br>vtkIOSQL-9.1.lib<br>vtkIOSQL-9.1d.lib<br>vtkioss-9.1.lib<br>vtkioss-9.1d.lib<br>vtkIOTecplotTable-9.1.lib<br>vtkIOTecplotTable-9.1d.lib<br>vtkIOVeraOut-9.1.lib<br>vtkIOVeraOut-9.1d.lib<br>vtkIOVideo-9.1.lib<br>vtkIOVideo-9.1d.lib<br>vtkIOXML-9.1.lib<br>vtkIOXML-9.1d.lib<br>vtkIOXMLParser-9.1.lib<br>vtkIOXMLParser-9.1d.lib<br>vtkjpeg-9.1.lib<br>vtkjpeg-9.1d.lib<br>vtkjsoncpp-9.1.lib<br>vtkjsoncpp-9.1d.lib<br>vtkkissfft-9.1.lib<br>vtkkissfft-9.1d.lib<br>vtklibharu-9.1.lib<br>vtklibharu-9.1d.lib<br>vtklibproj-9.1.lib<br>vtklibproj-9.1d.lib<br>vtklibxml2-9.1.lib<br>vtklibxml2-9.1d.lib<br>vtkloguru-9.1.lib<br>vtkloguru-9.1d.lib<br>vtklz4-9.1.lib<br>vtklz4-9.1d.lib<br>vtklzma-9.1.lib<br>vtklzma-9.1d.lib<br>vtkmetaio-9.1.lib<br>vtkmetaio-9.1d.lib<br>vtknetcdf-9.1.lib<br>vtknetcdf-9.1d.lib<br>vtkogg-9.1.lib<br>vtkogg-9.1d.lib<br>vtkParallelCore-9.1.lib<br>vtkParallelCore-9.1d.lib<br>vtkParallelDIY-9.1.lib<br>vtkParallelDIY-9.1d.lib<br>vtkpng-9.1.lib<br>vtkpng-9.1d.lib<br>vtkpugixml-9.1.lib<br>vtkpugixml-9.1d.lib<br>vtkRenderingAnnotation-9.1.lib<br>vtkRenderingAnnotation-9.1d.lib<br>vtkRenderingContext2D-9.1.lib<br>vtkRenderingContext2D-9.1d.lib<br>vtkRenderingContextOpenGL2-9.1.lib<br>vtkRenderingContextOpenGL2-9.1d.lib<br>vtkRenderingCore-9.1.lib<br>vtkRenderingCore-9.1d.lib<br>vtkRenderingFreeType-9.1.lib<br>vtkRenderingFreeType-9.1d.lib<br>vtkRenderingGL2PSOpenGL2-9.1.lib<br>vtkRenderingGL2PSOpenGL2-9.1d.lib<br>vtkRenderingImage-9.1.lib<br>vtkRenderingImage-9.1d.lib<br>vtkRenderingLabel-9.1.lib<br>vtkRenderingLabel-9.1d.lib<br>vtkRenderingLOD-9.1.lib<br>vtkRenderingLOD-9.1d.lib<br>vtkRenderingOpenGL2-9.1.lib<br>vtkRenderingOpenGL2-9.1d.lib<br>vtkRenderingSceneGraph-9.1.lib<br>vtkRenderingSceneGraph-9.1d.lib<br>vtkRenderingUI-9.1.lib<br>vtkRenderingUI-9.1d.lib<br>vtkRenderingVolume-9.1.lib<br>vtkRenderingVolume-9.1d.lib<br>vtkRenderingVolumeOpenGL2-9.1.lib<br>vtkRenderingVolumeOpenGL2-9.1d.lib<br>vtkRenderingVtkJS-9.1.lib<br>vtkRenderingVtkJS-9.1d.lib<br>vtksqlite-9.1.lib<br>vtksqlite-9.1d.lib<br>vtksys-9.1.lib<br>vtksys-9.1d.lib<br>vtkTestingRendering-9.1.lib<br>vtkTestingRendering-9.1d.lib<br>vtktheora-9.1.lib<br>vtktheora-9.1d.lib<br>vtktiff-9.1.lib<br>vtktiff-9.1d.lib<br>vtkverdict-9.1.lib<br>vtkverdict-9.1d.lib<br>vtkViewsContext2D-9.1.lib<br>vtkViewsContext2D-9.1d.lib<br>vtkViewsCore-9.1.lib<br>vtkViewsCore-9.1d.lib<br>vtkViewsInfovis-9.1.lib<br>vtkViewsInfovis-9.1d.lib<br>vtkWrappingTools-9.1.lib<br>vtkWrappingTools-9.1d.lib<br>vtkzlib-9.1.lib<br>vtkzlib-9.1d.lib<br></code></pre></td></tr></table></figure><p>至此，就可以在VS里使用PCL愉快开发了。</p><h3 id="debug和release"><a href="#debug和release" class="headerlink" title="debug和release"></a>debug和release</h3><p>上面配置的环境是在<code>debug</code>版本下用的，添加的<code>lib</code>都是带<code>d</code>的；如果要配置release版本的环境，添加的lib就是不带d的。</p><p>不过也有的库它只有一种版本的<code>lib</code>，都一样用就行了</p><p>之所以说这个，是因为有个同学把<code>PCL</code>相关的<code>lib</code>把带<code>d</code>和不带<code>d</code>的<code>lib</code>混在一起加到配置属性中，然后在用<code>PCL</code>功能的时候报错了。</p><p>所以配置的时候，能注意还是注意一点</p><h1 id="PCL-VS-QT-配置"><a href="#PCL-VS-QT-配置" class="headerlink" title="PCL+VS+QT 配置"></a>PCL+VS+QT 配置</h1><p>之前VS+PCL显示时用的是boost，但要配合Qt的ui界面来显示的话，需要用到VTK的一个组件QVTKOpenGLNativeWidget。使用这个组件需要重新编译VTK，让它生成配合Qt的相关文件。之后用我们新编译出的VTK文件替换PCL自带的VTK文件，再重新编译一下PCL，让PCL生成的文件好和现在的VTK配合起来。</p><h2 id="VTK编译"><a href="#VTK编译" class="headerlink" title="VTK编译"></a>VTK编译</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>去VTK的官网 <a href="https://vtk.org/">https://vtk.org/</a> 下载VTK的源文件。我们注意到PCL自带的VTK版本是9.1的，而官网只提供VTK9.2.6版本的源码了。无需担心，只要VTK的这个大版本一样就行，即都是VTK9的版本即可，别下成下面8.2.0或是7.1.1的版本就行。而且是在要找还是能在GitHub上找到VTK9.1版本的源码的。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323212423100.png" class="" title="image-20230323212423100"><h3 id="CMake编译"><a href="#CMake编译" class="headerlink" title="CMake编译"></a>CMake编译</h3><p>这里正好简单介绍一下使用CMake编译的流程，我们一般会用到3个文件夹，source文件夹用来放之前下载下来的源代码，build文件夹用来放CMake生成的文件，install文件夹用来放最后编译生成的文件。</p><p>这里我创建了一个VTK9.2.6文件夹，并在里面创建了上述三个文件夹，source、build、install</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323213855208.png" class="" title="image-20230323213855208"><p>之后把之前下载的源代码解压到了source文件夹下</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323213838465.png" class="" title="image-20230323213838465"><p>打开CMake的GUI界面，给出源文件路径和build路径，之后点configure</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323214900538.png" class="" title="image-20230323214900538"><p>编译器就用他检测到的我们现在的编译器版本VS2022，下面平台版本选一下x64</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323215046074.png" class="" title="image-20230323215046074"><p>第一次configure之后可以看到界面是红色的，表示这些选项我们还未确认过，这里有几项我们需要进行修改</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323215714672.png" class="" title="image-20230323215714672"><p>修改后结果如下。这个install的路径改成我们之前建的install文件夹，不然一会编译的时候生成的源码都跑到上面C盘的路径下了。然后就是把VTK配合Qt和Views的选项改为yes，之后编译才会生成与Qt配合相关的文件。确认好了之后再点一下Configure</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323220327445.png" class="" title="image-20230323220327445"><p>再次Configure会根据之前的选择而产生新的选项让我们确认，而之前的选项在我们点Configure的时候他就当我们确认好了，就变成白色了，当然变成白色的这些选项还是可以改的。在新出现的这些选项中，我们需要给他选定需要配合的Qt版本，以及对应的Qt文件夹路径。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323221344775.png" class="" title="image-20230323221344775"><p>其中Qt的版本根据自己要用的Qt版本来选，我用Qt6所以版本这里自然选6，然后再告诉它Qt6文件夹的路径。Qt5我不用所以不用管，如果用Qt5的话，照着这个Qt6的路径去找就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">E:\QT6\6.4.3\msvc2019_64\lib\cmake\Qt6<br></code></pre></td></tr></table></figure><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323221614344.png" class="" title="image-20230323221614344"><p>之后再点Configure，他就会根据之前提供的Qt6文件所在路径把Qt6一系列组件之类的文件路径自动填好了，大体看看，没事直接再点Configure就行</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323221817535.png" class="" title="image-20230323221817535"><p>这次Configure完之后所有的选项都是白色，代表没有新增选项需要确认了，也就是Configure部分结束了，现在可以点Generate了</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323222011218.png" class="" title="image-20230323222011218"><p>Generate完之后直接点旁边的Open Project打开VS编译器</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323222231142.png" class="" title="image-20230323222231142"><p>在VS编译器解决方案处，找到ALL_BUILD，右键生成。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323222409125.png" class="" title="image-20230323222409125"><p>等ALL_BUILD都生成完之后，往下找到INSTALL，右键生成。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323223957500.png" class="" title="image-20230323223957500"><p>生成完之后，就能在install文件夹找到我们需要的编译后的文件</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323224152087.png" class="" title="image-20230323224152087"><h2 id="PCL源码编译"><a href="#PCL源码编译" class="headerlink" title="PCL源码编译"></a>PCL源码编译</h2><p>VTK编译好后就可以开始PCL源码的编译，我们用上面编译好的VTK文件替换掉PCL自带的VTK文件</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323224418402.png" class="" title="image-20230323224418402"><p>至于其他的第三方库文件，我们就用它自带的就行</p><p>PCL原来自带的编译后的文件可以直接删掉就行</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323224542344.png" class="" title="image-20230323224542344"><p>然后就在这新建source、build、install三个文件夹，开始CMake。当然这只是我个人的喜好，完全可以在别的地方编译生成PCL源码，到时候把前面配的环境变量根据自己编译生成的代码的位置改好对应起来就行。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323225046947.png" class="" title="image-20230323225046947"><p>跟之前一样，先去下载PCL源码解压到source中</p><p>找到之前PCL官方的GitHub <a href="https://github.com/PointCloudLibrary/pcl">https://github.com/PointCloudLibrary/pcl</a> ，找到master-&gt;Tags-&gt;pcl1.12.1，这里的pcl版本对应你要编译的pcl版本。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323225220256.png" class="" title="image-20230323225220256"><p>选择之后界面提供的就是对应版本的pcl源码，点击下载即可。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323225449413.png" class="" title="image-20230323225449413"><p>源码解压好之后先别急，先在解压后的文件的cmake目录里找到“pcl_find_boost.cmake”这个文件。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323230410939.png" class="" title="image-20230323230410939"><p>编辑该文件，给出Boost的lib和include文件夹所在位置</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323230729136.png" class="" title="image-20230323230729136"><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#增加下面两行代码</span><br><span class="hljs-keyword">set</span>(Boost_LIBRARY_DIR E:/PCL_1.<span class="hljs-number">12.1</span>/<span class="hljs-number">3</span>rdParty/Boost/lib)<br><span class="hljs-keyword">set</span>(Boost_INCLUDE_DIR E:/PCL_1.<span class="hljs-number">12.1</span>/<span class="hljs-number">3</span>rdParty/Boost/<span class="hljs-keyword">include</span>/boost-<span class="hljs-number">1</span>_78)<br></code></pre></td></tr></table></figure><p>之后就跟之前VTK的编译过程一样了，打开CMake的GUI界面，配置好source和build位置，然后Configure</p><p>第一次编译还是先改install的位置，然后发现说EIGEN的路径没找到，所以我们也给它配置一下，再点Configure</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323230021064.png" class="" title="image-20230323230021064"><p>配置FLANN文件位置</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323231710412.png" class="" title="image-20230323231710412"><p>OPENNI2的路径他自己找到了给我省事了，Qt6文件夹路径还是没找到，我就自己给他配一下</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323231941937.png" class="" title="image-20230323231941937"><p>再确认一下VTK的路径，WITH_QT的版本</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323232050888.png" class="" title="image-20230323232050888"><p>然后选择PCL要生成的模块，这个新电脑没有GPU我就先没选GPU模块，选择all_in_one_installer就会生成一个官方那种的安装包，会根据我们的配置进行打包，之后还要在其他地方用这套配置直接用我们自己生成的all_in_one_installer安装即可。有些模块没选，到时候有需要的话可以再CMake，然后把需要的模块选上，然后在VS生成就行，不需要再配之前的路径了，因为上面那些选择已经记录在build文件中的cmake文件里了。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323232350022.png" class="" title="image-20230323232350022"><p>之后就是一路Configure，直到所有选项全白了，之后再Generate，然后Open Project打开VS，找到解决方案中的CMakePredefinedTargets，右键ALL_BUILD生成。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323233021933.png" class="" title="image-20230323233021933"><p>生成完再右键INSTALL生成。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323234044007.png" class="" title="image-20230323234044007"><p>搞定后就可以看到install中已经得到我们所需的编译好的文件。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323234510267.png" class="" title="image-20230323234510267"><p>这里要反思一下，之前CMake编译的时候，之所以找不到Eigen、FLANN，需要我手动添加，原因在于我在新电脑上配置的时候没有把这两个的路径加到环境变量里，你像OPENNI2因为它安装的时候自动配好了环境变量，所以CMake能直接找到，Qt6也是因为没有在环境变量里配置所以总是找不到，需要我手动配置。</p><p>然后因为我编译好的PCL源码路径发生了改变，所以环境变量的路径，在VS中配置的路径，也要稍微改一下。当然，你可以直接把这些新编译好的文件就放在之前VS配置的那个路径里，这样就不用变了。不过还有VTK的路径，之前自带的VTK文件夹名字里是9.1，现在变成9.2了也要改一下。</p><p>环境变量</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323235614665.png" class="" title="image-20230323235614665"><p>头文件位置</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323234635047.png" class="" title="image-20230323234635047"><p>lib库位置</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323234842387.png" class="" title="image-20230323234842387"><p>还有新编译生成的lib文件名也都是从之前的9.1变成9.2了，也要重新导入一下，把vtk9.1的lib都换成vtk9.2的lib。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230323235037235.png" class="" title="image-20230323235037235"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><code class="hljs plain">pcl_commond.lib<br>pcl_featuresd.lib<br>pcl_filtersd.lib<br>pcl_iod.lib<br>pcl_io_plyd.lib<br>pcl_kdtreed.lib<br>pcl_keypointsd.lib<br>pcl_mld.lib<br>pcl_octreed.lib<br>pcl_outofcored.lib<br>pcl_peopled.lib<br>pcl_recognitiond.lib<br>pcl_registrationd.lib<br>pcl_sample_consensusd.lib<br>pcl_searchd.lib<br>pcl_segmentationd.lib<br>pcl_stereod.lib<br>pcl_surfaced.lib<br>pcl_trackingd.lib<br>pcl_visualizationd.lib<br>libboost_atomic-vc142-mt-gd-x64-1_78.lib<br>libboost_bzip2-vc142-mt-gd-x64-1_78.lib<br>libboost_chrono-vc142-mt-gd-x64-1_78.lib<br>libboost_container-vc142-mt-gd-x64-1_78.lib<br>libboost_context-vc142-mt-gd-x64-1_78.lib<br>libboost_contract-vc142-mt-gd-x64-1_78.lib<br>libboost_coroutine-vc142-mt-gd-x64-1_78.lib<br>libboost_date_time-vc142-mt-gd-x64-1_78.lib<br>libboost_exception-vc142-mt-gd-x64-1_78.lib<br>libboost_filesystem-vc142-mt-gd-x64-1_78.lib<br>libboost_graph-vc142-mt-gd-x64-1_78.lib<br>libboost_graph_parallel-vc142-mt-gd-x64-1_78.lib<br>libboost_iostreams-vc142-mt-gd-x64-1_78.lib<br>libboost_json-vc142-mt-gd-x64-1_78.lib<br>libboost_locale-vc142-mt-gd-x64-1_78.lib<br>libboost_log-vc142-mt-gd-x64-1_78.lib<br>libboost_log_setup-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99f-vc142-mt-gd-x64-1_78.lib<br>libboost_math_c99l-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1f-vc142-mt-gd-x64-1_78.lib<br>libboost_math_tr1l-vc142-mt-gd-x64-1_78.lib<br>libboost_mpi-vc142-mt-gd-x64-1_78.lib<br>libboost_nowide-vc142-mt-gd-x64-1_78.lib<br>libboost_numpy38-vc142-mt-gd-x64-1_78.lib<br>libboost_prg_exec_monitor-vc142-mt-gd-x64-1_78.lib<br>libboost_program_options-vc142-mt-gd-x64-1_78.lib<br>libboost_python38-vc142-mt-gd-x64-1_78.lib<br>libboost_random-vc142-mt-gd-x64-1_78.lib<br>libboost_regex-vc142-mt-gd-x64-1_78.lib<br>libboost_serialization-vc142-mt-gd-x64-1_78.lib<br>libboost_system-vc142-mt-gd-x64-1_78.lib<br>libboost_test_exec_monitor-vc142-mt-gd-x64-1_78.lib<br>libboost_thread-vc142-mt-gd-x64-1_78.lib<br>libboost_timer-vc142-mt-gd-x64-1_78.lib<br>libboost_type_erasure-vc142-mt-gd-x64-1_78.lib<br>libboost_unit_test_framework-vc142-mt-gd-x64-1_78.lib<br>libboost_wave-vc142-mt-gd-x64-1_78.lib<br>libboost_wserialization-vc142-mt-gd-x64-1_78.lib<br>libboost_zlib-vc142-mt-gd-x64-1_78.lib<br>flann-gd.lib<br>flann_cpp-gd.lib<br>flann_cpp_s-gd.lib<br>flann_s-gd.lib<br>OpenNI2.lib<br>qhullcpp_d.lib<br>qhullstatic_d.lib<br>qhullstatic_rd.lib<br>qhull_rd.lib<br>vtkcgns-9.2d.lib<br>vtkChartsCore-9.2d.lib<br>vtkCommonColor-9.2d.lib<br>vtkCommonComputationalGeometry-9.2d.lib<br>vtkCommonCore-9.2d.lib<br>vtkCommonDataModel-9.2d.lib<br>vtkCommonExecutionModel-9.2d.lib<br>vtkCommonMath-9.2d.lib<br>vtkCommonMisc-9.2d.lib<br>vtkCommonSystem-9.2d.lib<br>vtkCommonTransforms-9.2d.lib<br>vtkDICOMParser-9.2d.lib<br>vtkDomainsChemistry-9.2d.lib<br>vtkDomainsChemistryOpenGL2-9.2d.lib<br>vtkdoubleconversion-9.2d.lib<br>vtkexodusII-9.2d.lib<br>vtkexpat-9.2d.lib<br>vtkFiltersAMR-9.2d.lib<br>vtkFiltersCore-9.2d.lib<br>vtkFiltersExtraction-9.2d.lib<br>vtkFiltersFlowPaths-9.2d.lib<br>vtkFiltersGeneral-9.2d.lib<br>vtkFiltersGeneric-9.2d.lib<br>vtkFiltersGeometry-9.2d.lib<br>vtkFiltersHybrid-9.2d.lib<br>vtkFiltersHyperTree-9.2d.lib<br>vtkFiltersImaging-9.2d.lib<br>vtkFiltersModeling-9.2d.lib<br>vtkFiltersParallel-9.2d.lib<br>vtkFiltersParallelImaging-9.2d.lib<br>vtkFiltersPoints-9.2d.lib<br>vtkFiltersProgrammable-9.2d.lib<br>vtkFiltersSelection-9.2d.lib<br>vtkFiltersSMP-9.2d.lib<br>vtkFiltersSources-9.2d.lib<br>vtkFiltersStatistics-9.2d.lib<br>vtkFiltersTexture-9.2d.lib<br>vtkFiltersTopology-9.2d.lib<br>vtkFiltersVerdict-9.2d.lib<br>vtkfmt-9.2d.lib<br>vtkfreetype-9.2d.lib<br>vtkGeovisCore-9.2d.lib<br>vtkgl2ps-9.2d.lib<br>vtkglew-9.2d.lib<br>vtkGUISupportQt-9.2d.lib<br>vtkGUISupportQtQuick-9.2d.lib<br>vtkGUISupportQtSQL-9.2d.lib<br>vtkhdf5-9.2d.lib<br>vtkhdf5_hl-9.2d.lib<br>vtkImagingColor-9.2d.lib<br>vtkImagingCore-9.2d.lib<br>vtkImagingFourier-9.2d.lib<br>vtkImagingGeneral-9.2d.lib<br>vtkImagingHybrid-9.2d.lib<br>vtkImagingMath-9.2d.lib<br>vtkImagingMorphological-9.2d.lib<br>vtkImagingSources-9.2d.lib<br>vtkImagingStatistics-9.2d.lib<br>vtkImagingStencil-9.2d.lib<br>vtkInfovisCore-9.2d.lib<br>vtkInfovisLayout-9.2d.lib<br>vtkInteractionImage-9.2d.lib<br>vtkInteractionStyle-9.2d.lib<br>vtkInteractionWidgets-9.2d.lib<br>vtkIOAMR-9.2d.lib<br>vtkIOAsynchronous-9.2d.lib<br>vtkIOCesium3DTiles-9.2d.lib<br>vtkIOCGNSReader-9.2d.lib<br>vtkIOChemistry-9.2d.lib<br>vtkIOCityGML-9.2d.lib<br>vtkIOCONVERGECFD-9.2d.lib<br>vtkIOCore-9.2d.lib<br>vtkIOEnSight-9.2d.lib<br>vtkIOExodus-9.2d.lib<br>vtkIOExport-9.2d.lib<br>vtkIOExportGL2PS-9.2d.lib<br>vtkIOExportPDF-9.2d.lib<br>vtkIOGeometry-9.2d.lib<br>vtkIOHDF-9.2d.lib<br>vtkIOImage-9.2d.lib<br>vtkIOImport-9.2d.lib<br>vtkIOInfovis-9.2d.lib<br>vtkIOIOSS-9.2d.lib<br>vtkIOLegacy-9.2d.lib<br>vtkIOLSDyna-9.2d.lib<br>vtkIOMINC-9.2d.lib<br>vtkIOMotionFX-9.2d.lib<br>vtkIOMovie-9.2d.lib<br>vtkIONetCDF-9.2d.lib<br>vtkIOOggTheora-9.2d.lib<br>vtkIOParallel-9.2d.lib<br>vtkIOParallelXML-9.2d.lib<br>vtkIOPLY-9.2d.lib<br>vtkIOSegY-9.2d.lib<br>vtkIOSQL-9.2d.lib<br>vtkioss-9.2d.lib<br>vtkIOTecplotTable-9.2d.lib<br>vtkIOVeraOut-9.2d.lib<br>vtkIOVideo-9.2d.lib<br>vtkIOXML-9.2d.lib<br>vtkIOXMLParser-9.2d.lib<br>vtkjpeg-9.2d.lib<br>vtkjsoncpp-9.2d.lib<br>vtkkissfft-9.2d.lib<br>vtklibharu-9.2d.lib<br>vtklibproj-9.2d.lib<br>vtklibxml2-9.2d.lib<br>vtkloguru-9.2d.lib<br>vtklz4-9.2d.lib<br>vtklzma-9.2d.lib<br>vtkmetaio-9.2d.lib<br>vtknetcdf-9.2d.lib<br>vtkogg-9.2d.lib<br>vtkParallelCore-9.2d.lib<br>vtkParallelDIY-9.2d.lib<br>vtkpng-9.2d.lib<br>vtkpugixml-9.2d.lib<br>vtkRenderingAnnotation-9.2d.lib<br>vtkRenderingContext2D-9.2d.lib<br>vtkRenderingContextOpenGL2-9.2d.lib<br>vtkRenderingCore-9.2d.lib<br>vtkRenderingFreeType-9.2d.lib<br>vtkRenderingGL2PSOpenGL2-9.2d.lib<br>vtkRenderingHyperTreeGrid-9.2d.lib<br>vtkRenderingImage-9.2d.lib<br>vtkRenderingLabel-9.2d.lib<br>vtkRenderingLICOpenGL2-9.2d.lib<br>vtkRenderingLOD-9.2d.lib<br>vtkRenderingOpenGL2-9.2d.lib<br>vtkRenderingQt-9.2d.lib<br>vtkRenderingSceneGraph-9.2d.lib<br>vtkRenderingUI-9.2d.lib<br>vtkRenderingVolume-9.2d.lib<br>vtkRenderingVolumeOpenGL2-9.2d.lib<br>vtkRenderingVtkJS-9.2d.lib<br>vtksqlite-9.2d.lib<br>vtksys-9.2d.lib<br>vtkTestingRendering-9.2d.lib<br>vtktheora-9.2d.lib<br>vtktiff-9.2d.lib<br>vtkverdict-9.2d.lib<br>vtkViewsContext2D-9.2d.lib<br>vtkViewsCore-9.2d.lib<br>vtkViewsInfovis-9.2d.lib<br>vtkViewsQt-9.2d.lib<br>vtkWrappingTools-9.2d.lib<br>vtkzlib-9.2d.lib<br></code></pre></td></tr></table></figure><p>至此，PCL+VS+QT的配置告一段落，可以通过VTK在QT的ui界面显示PCL点云数据了</p><p>多提一嘴，QVTKOpenGLNativeWidget继承自Qt的QOpenGLWidget，所以用的时候记得Qt组件里选上Qt OpenGLWidget</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20230324103455398.png" class="" title="image-20230324103455398"><p>关于使用QOpenGLNativeWidget组件进行点云数据可视化的具体代码见“QT+PCL+VTK点云可视化”</p><h1 id="关于编译好的文件"><a href="#关于编译好的文件" class="headerlink" title="关于编译好的文件"></a>关于编译好的文件</h1><p>这些编译好的文件可以直接拿去用，换电脑的时候也不用重新编译一遍，只需要从旧电脑把这些编译好的文件拷过去，配好路径就行了。这样搞害怕路径什么的有问题的话，最保险的办法就是之前说的，编译PCL的时候选上all_in_one_installer，然后用这个生成的安装器，去新电脑上安一下就行。</p><h1 id="使用时遇到的小问题"><a href="#使用时遇到的小问题" class="headerlink" title="使用时遇到的小问题"></a>使用时遇到的小问题</h1><p>在使用PCL可视化部分的时候，会用到boost相关部分，而这时发现编译器提升错误太多，导致intellisense引擎无法正常工作。</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20240115112330242.png" class="" title="image-20240115112330242"><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20240115112439969.png" class="" title="image-20240115112439969"><p>bing了半天也没找到什么原因，最后看到一个VS官方的问答区，说是VS编译器的问题，没有正确把boost识别导致的问题，更新一下编译器版本即可</p><img src="/2023/03/13/PCL1.12.1-VS2022-Qt6.4-config/image-20240115113048620.png" class="" title="image-20240115113048620"><p>然后我去更新了一下VS的版本，果然没事了。。。</p><p>有点难蚌。。。</p><p>我之前是17.5.2版本有问题，然后更新到当时最新的17.5.3就没事了</p><p>不过最近看同学的17.5.8还是别的什么版本，也遇到这个问题，不过更新到最新的版本也解决了</p><p>就是说这个地方好像很容易出问题，到时候如果看别人再遇到类似的问题，可以尝试更新一下VS版本，看看能不能解决。</p><p>那要是自己更新到最新版出现这种问题，应当如何？可能只能等一等，等微软下次的VS更新中把问题修复了吧。。。不过它这些小版本更新应该挺快就是了。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本教程分为两部分，第一部分为PCL+VS的配置，第二部分为PCL+VS+QT的配置。&lt;/p&gt;
&lt;p&gt;如果只是要在VS用用PCL，学习一下PCL点云库，只看第一部分PCL+VS的配置即可。&lt;/p&gt;
&lt;p&gt;而如果还需要配合QT做界面，相关的配置会在第二部分PCL+VS+QT的配</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="PCL" scheme="http://example.com/tags/PCL/"/>
    
  </entry>
  
</feed>
